/**
 * Lobby
 * The Lobby service is a flexible system for games to enable different styles of multiplayer experiences quickly and easily.  A lobby provides a way to browse and join public games, create private games that can be easily joined by others using a code, gather a group together in a party before matchmaking as a group, and more!
 *
 * The version of the OpenAPI document: v1
 * Contact: multiplayer-suite-devs@unity3d.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import { Configuration } from "./configuration";
import { AxiosPromise, AxiosInstance, AxiosRequestConfig } from "axios";
import { RequestArgs, BaseAPI } from "./base";
/**
 * The body of a Create Lobby request.
 * @export
 * @interface CreateRequest
 */
export interface CreateRequest {
    /**
     * The name of the lobby that should be displayed to users.  All whitespace will be trimmed from the name.
     * @type {string}
     * @memberof CreateRequest
     */
    name: string;
    /**
     * The maximum number of players that can be members of the lobby.
     * @type {number}
     * @memberof CreateRequest
     */
    maxPlayers: number;
    /**
     * Whether or not the lobby is private.  Private lobbies do not appear in query results.  If the lobby is not publicly visible, the creator can share the `lobbyCode` with other users who can use it to join this lobby.
     * @type {boolean}
     * @memberof CreateRequest
     */
    isPrivate?: boolean | null;
    /**
     * Whether or not the lobby is locked.  If true, new players will not be able to join.
     * @type {boolean}
     * @memberof CreateRequest
     */
    isLocked?: boolean | null;
    /**
     *
     * @type {Player}
     * @memberof CreateRequest
     */
    player?: Player;
    /**
     * Custom game-specific properties that apply to the lobby (e.g. `mapName` or `gameType`).
     * @type {{ [key: string]: DataObject; }}
     * @memberof CreateRequest
     */
    data?: {
        [key: string]: DataObject;
    } | null;
}
/**
 * Custom data property for a lobby.
 * @export
 * @interface DataObject
 */
export interface DataObject {
    /**
     * The value of the custom property.  This property can be set to null or an empty string.  If this property is indexed (by setting the `index` field) then the length of the value must be less than 128 bytes.
     * @type {string}
     * @memberof DataObject
     */
    value?: string | null;
    /**
     * Indicates for whom the property should be visible.  If `public`, the property will be visible to everyone and will be included in query results.  If `member`, the data will only be visible to users who are members of the lobby (i.e. those who have successfully joined).  If `private`, the metadata will only be visible to the host.
     * @type {string}
     * @memberof DataObject
     */
    visibility: DataObjectVisibilityEnum;
    /**
     * The name of the column to index this property value under, either `S#` for strings or `N#` for numeric values.  If an index is specified on a property, then you can use that index name in a `QueryFilter` to filter results by that property.  You will not be prevented from indexing multiple objects having properties with different names but the same index, but you will likely receive unexpected results from a query.
     * @type {string}
     * @memberof DataObject
     */
    index?: DataObjectIndexEnum;
}
export declare const DataObjectVisibilityEnum: {
    readonly Public: "public";
    readonly Member: "member";
    readonly Private: "private";
};
export declare type DataObjectVisibilityEnum = typeof DataObjectVisibilityEnum[keyof typeof DataObjectVisibilityEnum];
export declare const DataObjectIndexEnum: {
    readonly S1: "S1";
    readonly S2: "S2";
    readonly S3: "S3";
    readonly S4: "S4";
    readonly S5: "S5";
    readonly N1: "N1";
    readonly N2: "N2";
    readonly N3: "N3";
    readonly N4: "N4";
    readonly N5: "N5";
};
export declare type DataObjectIndexEnum = typeof DataObjectIndexEnum[keyof typeof DataObjectIndexEnum];
/**
 * Additional detail about an error.  This may include detailed validation failure messages, debugging information, troubleshooting steps, or more.
 * @export
 * @interface Detail
 */
export interface Detail {
    /**
     *
     * @type {string}
     * @memberof Detail
     */
    errorType?: string;
    /**
     *
     * @type {string}
     * @memberof Detail
     */
    message?: string;
}
/**
 * The body that will be returned for any failing request.  We are using the [RFC 7807 Error Format](https://www.rfc-editor.org/rfc/rfc7807.html#section-3.1).
 * @export
 * @interface ErrorStatus
 */
export interface ErrorStatus {
    /**
     * A URI that identifies the problem type and should provide documentation for the problem.
     * @type {string}
     * @memberof ErrorStatus
     */
    type?: string;
    /**
     * The HTTP status code of the response.
     * @type {number}
     * @memberof ErrorStatus
     */
    status?: number;
    /**
     * A short, human-readable summary of the problem type.  It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
     * @type {string}
     * @memberof ErrorStatus
     */
    title?: string;
    /**
     * A human-readable explanation specific to this occurrence of the problem.
     * @type {string}
     * @memberof ErrorStatus
     */
    detail?: string;
    /**
     * An integer in the range 16000-16999 that uniquely identifies an error type.  This can be used to programatically identify the type of error.
     * @type {number}
     * @memberof ErrorStatus
     */
    code?: number;
    /**
     * A list of additional details about specific errors.
     * @type {Array<Detail>}
     * @memberof ErrorStatus
     */
    details?: Array<Detail>;
}
/**
 * The body of a Join Lobby request using lobby code.
 * @export
 * @interface JoinByCodeRequest
 */
export interface JoinByCodeRequest {
    /**
     * The lobby code of the lobby to join.  Mutually exclusive with `id`.  This is used to join a private lobby where the lobby code was shared to other users manually.
     * @type {string}
     * @memberof JoinByCodeRequest
     */
    lobbyCode: string;
    /**
     *
     * @type {Player}
     * @memberof JoinByCodeRequest
     */
    player?: Player;
}
/**
 * Data about an individual lobby.
 * @export
 * @interface Lobby
 */
export interface Lobby {
    /**
     *
     * @type {string}
     * @memberof Lobby
     */
    id?: string;
    /**
     * A short code that can be used to join a lobby.  This is only visible to lobby members.  Typically this is displayed to the user so they can share it with other players out-of-game.  Users with the code can join a lobby even when it is private.
     * @type {string}
     * @memberof Lobby
     */
    lobbyCode?: string | null;
    /**
     * The Unity project ID of the game.
     * @type {string}
     * @memberof Lobby
     */
    upid?: string;
    /**
     * The ID of the environment this lobby exists in.
     * @type {string}
     * @memberof Lobby
     */
    environmentId?: string;
    /**
     * The name of the lobby.  Typically this is shown in game UI to represent the lobby.
     * @type {string}
     * @memberof Lobby
     */
    name?: string | null;
    /**
     * The maximum number of players that can be members of the lobby.
     * @type {number}
     * @memberof Lobby
     */
    maxPlayers?: number;
    /**
     * The number of remaining open slots for players before the lobby becomes full.
     * @type {number}
     * @memberof Lobby
     */
    availableSlots?: number;
    /**
     * Whether or not the lobby is private.  Private lobbies do not appear in query results.
     * @type {boolean}
     * @memberof Lobby
     */
    isPrivate?: boolean;
    /**
     * Whether or not the lobby is locked.  If true, new players will not be able to join.
     * @type {boolean}
     * @memberof Lobby
     */
    isLocked?: boolean;
    /**
     * The members of the lobby.
     * @type {Array<Player>}
     * @memberof Lobby
     */
    players?: Array<Player>;
    /**
     * Properties of the lobby set by the host.
     * @type {{ [key: string]: DataObject; }}
     * @memberof Lobby
     */
    data?: {
        [key: string]: DataObject;
    } | null;
    /**
     * The ID of the player that is the lobby host.
     * @type {string}
     * @memberof Lobby
     */
    hostId?: string;
    /**
     * When the lobby was created.  The timestamp is in UTC and conforms to ISO 8601.
     * @type {string}
     * @memberof Lobby
     */
    created?: string;
    /**
     * When the lobby was last updated.  The timestamp is in UTC and conforms to ISO 8601.
     * @type {string}
     * @memberof Lobby
     */
    lastUpdated?: string;
}
/**
 * Information about a specific player creating, joining, or already in a lobby.
 * @export
 * @interface Player
 */
export interface Player {
    /**
     * The unique identifier for the player.  If not provided for a create or join request, it will be set to the ID of the caller.
     * @type {string}
     * @memberof Player
     */
    id?: string | null;
    /**
     * Connection information for connecting to a relay with this player.
     * @type {string}
     * @memberof Player
     * @deprecated
     */
    connectionInfo?: string | null;
    /**
     * Custom game-specific properties that apply to an individual player (e.g. `role` or `skill`).
     * @type {{ [key: string]: PlayerDataObject; }}
     * @memberof Player
     */
    data?: {
        [key: string]: PlayerDataObject;
    } | null;
    /**
     * The `allocationId` from the Relay service which associates this player in this lobby with a persistent connection.  When a disconnect notification is received, this value is used to identify the associated player in a lobby to mark them as disconnected.
     * @type {string}
     * @memberof Player
     */
    allocationId?: string | null;
    /**
     * The time at which the player joined the lobby.
     * @type {string}
     * @memberof Player
     */
    joined?: string;
    /**
     * The last time the metadata for this player was updated.
     * @type {string}
     * @memberof Player
     */
    lastUpdated?: string;
}
/**
 * Custom data property for a player.
 * @export
 * @interface PlayerDataObject
 */
export interface PlayerDataObject {
    /**
     * The value of the custom property.  This property can be set to null or an empty string.
     * @type {string}
     * @memberof PlayerDataObject
     */
    value?: string | null;
    /**
     * Indicates for whom the property should be visible.  If `public`, the property will be visible to everyone and will be included in query results.  If `member`, the data will only be visible to users who are members of the lobby (i.e. those who have successfully joined).  If `private`, the metadata will only be visible to the player.
     * @type {string}
     * @memberof PlayerDataObject
     */
    visibility: PlayerDataObjectVisibilityEnum;
}
export declare const PlayerDataObjectVisibilityEnum: {
    readonly Public: "public";
    readonly Member: "member";
    readonly Private: "private";
};
export declare type PlayerDataObjectVisibilityEnum = typeof PlayerDataObjectVisibilityEnum[keyof typeof PlayerDataObjectVisibilityEnum];
/**
 * The body of an Update Player Data request.
 * @export
 * @interface PlayerUpdateRequest
 */
export interface PlayerUpdateRequest {
    /**
     * Connection information for connecting to a relay with this player.
     * @type {string}
     * @memberof PlayerUpdateRequest
     * @deprecated
     */
    connectionInfo?: string | null;
    /**
     * Custom game-specific properties to add, update, or remove from the player (e.g. `role` or `skill`).  To remove an existing property, include it in `data` but set the property object to `null`.  To update the value to `null`, set the `value` property of the object to `null`.
     * @type {{ [key: string]: PlayerDataObject; }}
     * @memberof PlayerUpdateRequest
     */
    data?: {
        [key: string]: PlayerDataObject;
    } | null;
    /**
     * The `allocationId` from the Relay service which associates this player in this lobby with a persistent connection.  When a disconnect notification is received, this value is used to identify the associated player in a lobby to mark them as disconnected.
     * @type {string}
     * @memberof PlayerUpdateRequest
     */
    allocationId?: string | null;
}
/**
 * A filter for an individual field that is applied to a query.
 * @export
 * @interface QueryFilter
 */
export interface QueryFilter {
    /**
     * The name of the field to filter on.  For custom data fields, the name of the index must be used instead of the field name.
     * @type {string}
     * @memberof QueryFilter
     */
    field: QueryFilterFieldEnum;
    /**
     * The value to compare to the field being filtered.  This value must be a string and it must be parsable as the same type as `field` (e.g. `integer` for MaxPlayers, `datetime` for Created, etc.).  The value for `datetime` fields (Created, LastUpdated) must be in RFC3339 format.  For example, in C# this can be achieved using the \"o\" format specifier: `return dateTime.ToString(\"o\", DateTimeFormatInfo.InvariantInfo);`.  Refer to your language documentation for other methods to generate RFC3339-compatible datetime strings.
     * @type {string}
     * @memberof QueryFilter
     */
    value: string;
    /**
     * The operator used to compare the field to the filter value.  Supports `CONTAINS` (only on the `Name` field), `EQ` (Equal), `NE` (Not Equal), `LT` (Less Than), `LE` (Less Than or Equal), `GT` (Greater Than), and `GE` (Greater Than or Equal).
     * @type {string}
     * @memberof QueryFilter
     */
    op: QueryFilterOpEnum;
}
export declare const QueryFilterFieldEnum: {
    readonly MaxPlayers: "MaxPlayers";
    readonly AvailableSlots: "AvailableSlots";
    readonly Name: "Name";
    readonly Created: "Created";
    readonly LastUpdated: "LastUpdated";
    readonly S1: "S1";
    readonly S2: "S2";
    readonly S3: "S3";
    readonly S4: "S4";
    readonly S5: "S5";
    readonly N1: "N1";
    readonly N2: "N2";
    readonly N3: "N3";
    readonly N4: "N4";
    readonly N5: "N5";
    readonly IsLocked: "IsLocked";
};
export declare type QueryFilterFieldEnum = typeof QueryFilterFieldEnum[keyof typeof QueryFilterFieldEnum];
export declare const QueryFilterOpEnum: {
    readonly Contains: "CONTAINS";
    readonly Eq: "EQ";
    readonly Ne: "NE";
    readonly Lt: "LT";
    readonly Le: "LE";
    readonly Gt: "GT";
    readonly Ge: "GE";
};
export declare type QueryFilterOpEnum = typeof QueryFilterOpEnum[keyof typeof QueryFilterOpEnum];
/**
 * An order for an individual field that is applied to a query.
 * @export
 * @interface QueryOrder
 */
export interface QueryOrder {
    /**
     * Whether to sort in ascending or descending order.
     * @type {boolean}
     * @memberof QueryOrder
     */
    asc?: boolean;
    /**
     * The name of the field to order on.
     * @type {string}
     * @memberof QueryOrder
     */
    field?: QueryOrderFieldEnum;
}
export declare const QueryOrderFieldEnum: {
    readonly Name: "Name";
    readonly MaxPlayers: "MaxPlayers";
    readonly AvailableSlots: "AvailableSlots";
    readonly Created: "Created";
    readonly LastUpdated: "LastUpdated";
    readonly Id: "ID";
    readonly S1: "S1";
    readonly S2: "S2";
    readonly S3: "S3";
    readonly S4: "S4";
    readonly S5: "S5";
    readonly N1: "N1";
    readonly N2: "N2";
    readonly N3: "N3";
    readonly N4: "N4";
    readonly N5: "N5";
};
export declare type QueryOrderFieldEnum = typeof QueryOrderFieldEnum[keyof typeof QueryOrderFieldEnum];
/**
 * The body of a Query request which defines how to sort and filter results, how many results to return, etc.
 * @export
 * @interface QueryRequest
 */
export interface QueryRequest {
    /**
     * The number of results to return.
     * @type {number}
     * @memberof QueryRequest
     */
    count?: number | null;
    /**
     * The number of results to skip before selecting results to return.
     * @type {number}
     * @memberof QueryRequest
     */
    skip?: number | null;
    /**
     * Whether a random sample of results that match the search filter should be returned.
     * @type {boolean}
     * @memberof QueryRequest
     */
    sampleResults?: boolean;
    /**
     * A list of filters which can be used to narrow down which lobbies to return.
     * @type {Array<QueryFilter>}
     * @memberof QueryRequest
     */
    filter?: Array<QueryFilter>;
    /**
     * A list of orders which define how the results should be ordered in the response.
     * @type {Array<QueryOrder>}
     * @memberof QueryRequest
     */
    order?: Array<QueryOrder>;
    /**
     * A continuation token that can be passed to subsequent query requests to fetch the next page of results.
     * @type {string}
     * @memberof QueryRequest
     */
    continuationToken?: string | null;
}
/**
 * A list of lobbies that matched the specified query.  Only the public top-level data and player data properties are returned.
 * @export
 * @interface QueryResponse
 */
export interface QueryResponse {
    /**
     *
     * @type {Array<Lobby>}
     * @memberof QueryResponse
     */
    results?: Array<Lobby>;
    /**
     *
     * @type {string}
     * @memberof QueryResponse
     */
    continuationToken?: string | null;
}
/**
 * The body of a QuickJoin request.
 * @export
 * @interface QuickJoinRequest
 */
export interface QuickJoinRequest {
    /**
     * A list of filters which can be used to narrow down which lobbies to attempt to join.
     * @type {Array<QueryFilter>}
     * @memberof QuickJoinRequest
     */
    filter?: Array<QueryFilter>;
    /**
     *
     * @type {Player}
     * @memberof QuickJoinRequest
     */
    player?: Player;
}
/**
 * The data associated with the token.
 * @export
 * @interface TokenData
 */
export interface TokenData {
    /**
     * The value of the token.
     * @type {string}
     * @memberof TokenData
     */
    tokenValue?: string;
    /**
     * The URI of the token, if applicable.
     * @type {string}
     * @memberof TokenData
     */
    uri?: string;
}
/**
 * Details about a token being requested.
 * @export
 * @interface TokenRequest
 */
export interface TokenRequest {
    /**
     *
     * @type {string}
     * @memberof TokenRequest
     */
    tokenType: TokenRequestTokenTypeEnum;
}
export declare const TokenRequestTokenTypeEnum: {
    readonly VivoxJoin: "vivoxJoin";
    readonly WireJoin: "wireJoin";
};
export declare type TokenRequestTokenTypeEnum = typeof TokenRequestTokenTypeEnum[keyof typeof TokenRequestTokenTypeEnum];
/**
 * The body of an Update Lobby request.
 * @export
 * @interface UpdateRequest
 */
export interface UpdateRequest {
    /**
     * The name of the lobby that should be displayed to users.  All whitespace will be trimmed from the name.
     * @type {string}
     * @memberof UpdateRequest
     */
    name?: string | null;
    /**
     * The maximum number of players that can be members of the lobby.  Must be greater than or equal to the current number of players in the lobby.
     * @type {number}
     * @memberof UpdateRequest
     */
    maxPlayers?: number | null;
    /**
     * Whether or not the lobby is private.  Private lobbies do not appear in query results.  If the lobby is not publicly visible, the creator can share the `lobbyCode` with other users who can use it to join this lobby.
     * @type {boolean}
     * @memberof UpdateRequest
     */
    isPrivate?: boolean | null;
    /**
     * Whether or not the lobby is locked.  If true, new players will not be able to join.
     * @type {boolean}
     * @memberof UpdateRequest
     */
    isLocked?: boolean | null;
    /**
     * Custom game-specific properties to add, update, or remove from the lobby (e.g. `mapName` or `gameType`).  To remove an existing property, include it in `data` but set the property object to `null`.  To update the value to `null`, set the `value` property of the object to `null`.
     * @type {{ [key: string]: DataObject; }}
     * @memberof UpdateRequest
     */
    data?: {
        [key: string]: DataObject;
    } | null;
    /**
     * The ID of the player to make the host of the lobby.  As soon as this is updated, the current host will no longer have permission to modify the lobby.
     * @type {string}
     * @memberof UpdateRequest
     */
    hostId?: string | null;
}
/**
 * LobbyApi - axios parameter creator
 * @export
 */
export declare const LobbyApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Create a new lobby and return the lobby metadata.
     * @summary Create a lobby
     * @param {CreateRequest} [createRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLobby: (createRequest?: CreateRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Delete a lobby so it\'s no longer discoverable/joinable.
     * @summary Delete a lobby
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLobby: (lobbyId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get a list of lobby IDs that the player is currently a member of.
     * @summary Get a player\'s joined lobbies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getJoinedLobbies: (options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Get the full details for a lobby including the game-specific metadata and player details.
     * @summary Get lobby details
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLobby: (lobbyId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Heartbeat a lobby, updating its `LastUpdated` property, to signify that the lobby is not stale.
     * @summary Heartbeat a lobby
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    heartbeat: (lobbyId: string, body?: object, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Join an existing lobby using the lobby code if there is space available (i.e. total number of players is less than the value of `MaxPlayers`).
     * @summary Join a lobby with lobby code
     * @param {JoinByCodeRequest} [joinByCodeRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    joinLobbyByCode: (joinByCodeRequest?: JoinByCodeRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Join an existing lobby using the lobby ID if there is space available (i.e. total number of players is less than the value of `MaxPlayers`).
     * @summary Join a lobby with lobby ID
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {Player} [player]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    joinLobbyById: (lobbyId: string, player?: Player, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Query all of the public lobbies for a title and filter them down according to parameters provided by the client.
     * @summary Query public lobbies
     * @param {QueryRequest} [queryRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryLobbies: (queryRequest?: QueryRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Query all of the available lobbies for a title and filter them down according to parameters provided by the client.  If possible, join one and return its information.
     * @summary Query available lobbies and join a random one
     * @param {QuickJoinRequest} [quickJoinRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    quickJoinLobby: (quickJoinRequest?: QuickJoinRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Reconnect a disconnected player to a lobby using the lobby ID.
     * @summary Reconnect to a lobby after disconnecting
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reconnect: (lobbyId: string, body?: object, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Remove an individual player from a lobby.  If the player being removed is the host, a random player is chosen as the new host.  Hosts can avoid this by changing the `hostId` to another player using the **Update Lobby** API before leaving.
     * @summary Remove a player
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {string} playerId The ID of the player to execute the request against.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removePlayer: (lobbyId: string, playerId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Request authentication tokens for use with other services that interact with Lobby.
     * @summary Authentication token request
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {Array<TokenRequest>} tokenRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestTokens: (lobbyId: string, tokenRequest: Array<TokenRequest>, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Update the properties of a lobby.  This could include the lobby name, number of max players, the lobby\'s `data` property, etc.
     * @summary Update lobby data
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {UpdateRequest} [updateRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLobby: (lobbyId: string, updateRequest?: UpdateRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Update the properties of a player.  Only the player matching the player ID can perform this action.  This could include updating the `data` property for an individual player to include game-specific metadata.  The index data property is not allowed on player data objects at this time.
     * @summary Update player data
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {string} playerId The ID of the player to execute the request against.
     * @param {PlayerUpdateRequest} [playerUpdateRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePlayer: (lobbyId: string, playerId: string, playerUpdateRequest?: PlayerUpdateRequest, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * LobbyApi - functional programming interface
 * @export
 */
export declare const LobbyApiFp: (configuration?: Configuration) => {
    /**
     * Create a new lobby and return the lobby metadata.
     * @summary Create a lobby
     * @param {CreateRequest} [createRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLobby(createRequest?: CreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Lobby>>;
    /**
     * Delete a lobby so it\'s no longer discoverable/joinable.
     * @summary Delete a lobby
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLobby(lobbyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Get a list of lobby IDs that the player is currently a member of.
     * @summary Get a player\'s joined lobbies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getJoinedLobbies(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>>;
    /**
     * Get the full details for a lobby including the game-specific metadata and player details.
     * @summary Get lobby details
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLobby(lobbyId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Lobby>>;
    /**
     * Heartbeat a lobby, updating its `LastUpdated` property, to signify that the lobby is not stale.
     * @summary Heartbeat a lobby
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    heartbeat(lobbyId: string, body?: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Join an existing lobby using the lobby code if there is space available (i.e. total number of players is less than the value of `MaxPlayers`).
     * @summary Join a lobby with lobby code
     * @param {JoinByCodeRequest} [joinByCodeRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    joinLobbyByCode(joinByCodeRequest?: JoinByCodeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Lobby>>;
    /**
     * Join an existing lobby using the lobby ID if there is space available (i.e. total number of players is less than the value of `MaxPlayers`).
     * @summary Join a lobby with lobby ID
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {Player} [player]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    joinLobbyById(lobbyId: string, player?: Player, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Lobby>>;
    /**
     * Query all of the public lobbies for a title and filter them down according to parameters provided by the client.
     * @summary Query public lobbies
     * @param {QueryRequest} [queryRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryLobbies(queryRequest?: QueryRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryResponse>>;
    /**
     * Query all of the available lobbies for a title and filter them down according to parameters provided by the client.  If possible, join one and return its information.
     * @summary Query available lobbies and join a random one
     * @param {QuickJoinRequest} [quickJoinRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    quickJoinLobby(quickJoinRequest?: QuickJoinRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Lobby>>;
    /**
     * Reconnect a disconnected player to a lobby using the lobby ID.
     * @summary Reconnect to a lobby after disconnecting
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reconnect(lobbyId: string, body?: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Lobby>>;
    /**
     * Remove an individual player from a lobby.  If the player being removed is the host, a random player is chosen as the new host.  Hosts can avoid this by changing the `hostId` to another player using the **Update Lobby** API before leaving.
     * @summary Remove a player
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {string} playerId The ID of the player to execute the request against.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removePlayer(lobbyId: string, playerId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Request authentication tokens for use with other services that interact with Lobby.
     * @summary Authentication token request
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {Array<TokenRequest>} tokenRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestTokens(lobbyId: string, tokenRequest: Array<TokenRequest>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{
        [key: string]: TokenData;
    }>>;
    /**
     * Update the properties of a lobby.  This could include the lobby name, number of max players, the lobby\'s `data` property, etc.
     * @summary Update lobby data
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {UpdateRequest} [updateRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLobby(lobbyId: string, updateRequest?: UpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Lobby>>;
    /**
     * Update the properties of a player.  Only the player matching the player ID can perform this action.  This could include updating the `data` property for an individual player to include game-specific metadata.  The index data property is not allowed on player data objects at this time.
     * @summary Update player data
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {string} playerId The ID of the player to execute the request against.
     * @param {PlayerUpdateRequest} [playerUpdateRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePlayer(lobbyId: string, playerId: string, playerUpdateRequest?: PlayerUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Lobby>>;
};
/**
 * LobbyApi - factory interface
 * @export
 */
export declare const LobbyApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Create a new lobby and return the lobby metadata.
     * @summary Create a lobby
     * @param {CreateRequest} [createRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLobby(createRequest?: CreateRequest, options?: any): AxiosPromise<Lobby>;
    /**
     * Delete a lobby so it\'s no longer discoverable/joinable.
     * @summary Delete a lobby
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLobby(lobbyId: string, options?: any): AxiosPromise<void>;
    /**
     * Get a list of lobby IDs that the player is currently a member of.
     * @summary Get a player\'s joined lobbies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getJoinedLobbies(options?: any): AxiosPromise<Array<string>>;
    /**
     * Get the full details for a lobby including the game-specific metadata and player details.
     * @summary Get lobby details
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLobby(lobbyId: string, options?: any): AxiosPromise<Lobby>;
    /**
     * Heartbeat a lobby, updating its `LastUpdated` property, to signify that the lobby is not stale.
     * @summary Heartbeat a lobby
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    heartbeat(lobbyId: string, body?: object, options?: any): AxiosPromise<void>;
    /**
     * Join an existing lobby using the lobby code if there is space available (i.e. total number of players is less than the value of `MaxPlayers`).
     * @summary Join a lobby with lobby code
     * @param {JoinByCodeRequest} [joinByCodeRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    joinLobbyByCode(joinByCodeRequest?: JoinByCodeRequest, options?: any): AxiosPromise<Lobby>;
    /**
     * Join an existing lobby using the lobby ID if there is space available (i.e. total number of players is less than the value of `MaxPlayers`).
     * @summary Join a lobby with lobby ID
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {Player} [player]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    joinLobbyById(lobbyId: string, player?: Player, options?: any): AxiosPromise<Lobby>;
    /**
     * Query all of the public lobbies for a title and filter them down according to parameters provided by the client.
     * @summary Query public lobbies
     * @param {QueryRequest} [queryRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryLobbies(queryRequest?: QueryRequest, options?: any): AxiosPromise<QueryResponse>;
    /**
     * Query all of the available lobbies for a title and filter them down according to parameters provided by the client.  If possible, join one and return its information.
     * @summary Query available lobbies and join a random one
     * @param {QuickJoinRequest} [quickJoinRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    quickJoinLobby(quickJoinRequest?: QuickJoinRequest, options?: any): AxiosPromise<Lobby>;
    /**
     * Reconnect a disconnected player to a lobby using the lobby ID.
     * @summary Reconnect to a lobby after disconnecting
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reconnect(lobbyId: string, body?: object, options?: any): AxiosPromise<Lobby>;
    /**
     * Remove an individual player from a lobby.  If the player being removed is the host, a random player is chosen as the new host.  Hosts can avoid this by changing the `hostId` to another player using the **Update Lobby** API before leaving.
     * @summary Remove a player
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {string} playerId The ID of the player to execute the request against.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removePlayer(lobbyId: string, playerId: string, options?: any): AxiosPromise<void>;
    /**
     * Request authentication tokens for use with other services that interact with Lobby.
     * @summary Authentication token request
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {Array<TokenRequest>} tokenRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestTokens(lobbyId: string, tokenRequest: Array<TokenRequest>, options?: any): AxiosPromise<{
        [key: string]: TokenData;
    }>;
    /**
     * Update the properties of a lobby.  This could include the lobby name, number of max players, the lobby\'s `data` property, etc.
     * @summary Update lobby data
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {UpdateRequest} [updateRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLobby(lobbyId: string, updateRequest?: UpdateRequest, options?: any): AxiosPromise<Lobby>;
    /**
     * Update the properties of a player.  Only the player matching the player ID can perform this action.  This could include updating the `data` property for an individual player to include game-specific metadata.  The index data property is not allowed on player data objects at this time.
     * @summary Update player data
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {string} playerId The ID of the player to execute the request against.
     * @param {PlayerUpdateRequest} [playerUpdateRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePlayer(lobbyId: string, playerId: string, playerUpdateRequest?: PlayerUpdateRequest, options?: any): AxiosPromise<Lobby>;
};
/**
 * LobbyApi - object-oriented interface
 * @export
 * @class LobbyApi
 * @extends {BaseAPI}
 */
export declare class LobbyApi extends BaseAPI {
    /**
     * Create a new lobby and return the lobby metadata.
     * @summary Create a lobby
     * @param {CreateRequest} [createRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LobbyApi
     */
    createLobby(createRequest?: CreateRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Lobby>>;
    /**
     * Delete a lobby so it\'s no longer discoverable/joinable.
     * @summary Delete a lobby
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LobbyApi
     */
    deleteLobby(lobbyId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Get a list of lobby IDs that the player is currently a member of.
     * @summary Get a player\'s joined lobbies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LobbyApi
     */
    getJoinedLobbies(options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<string[]>>;
    /**
     * Get the full details for a lobby including the game-specific metadata and player details.
     * @summary Get lobby details
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LobbyApi
     */
    getLobby(lobbyId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Lobby>>;
    /**
     * Heartbeat a lobby, updating its `LastUpdated` property, to signify that the lobby is not stale.
     * @summary Heartbeat a lobby
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LobbyApi
     */
    heartbeat(lobbyId: string, body?: object, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Join an existing lobby using the lobby code if there is space available (i.e. total number of players is less than the value of `MaxPlayers`).
     * @summary Join a lobby with lobby code
     * @param {JoinByCodeRequest} [joinByCodeRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LobbyApi
     */
    joinLobbyByCode(joinByCodeRequest?: JoinByCodeRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Lobby>>;
    /**
     * Join an existing lobby using the lobby ID if there is space available (i.e. total number of players is less than the value of `MaxPlayers`).
     * @summary Join a lobby with lobby ID
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {Player} [player]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LobbyApi
     */
    joinLobbyById(lobbyId: string, player?: Player, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Lobby>>;
    /**
     * Query all of the public lobbies for a title and filter them down according to parameters provided by the client.
     * @summary Query public lobbies
     * @param {QueryRequest} [queryRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LobbyApi
     */
    queryLobbies(queryRequest?: QueryRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<QueryResponse>>;
    /**
     * Query all of the available lobbies for a title and filter them down according to parameters provided by the client.  If possible, join one and return its information.
     * @summary Query available lobbies and join a random one
     * @param {QuickJoinRequest} [quickJoinRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LobbyApi
     */
    quickJoinLobby(quickJoinRequest?: QuickJoinRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Lobby>>;
    /**
     * Reconnect a disconnected player to a lobby using the lobby ID.
     * @summary Reconnect to a lobby after disconnecting
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LobbyApi
     */
    reconnect(lobbyId: string, body?: object, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Lobby>>;
    /**
     * Remove an individual player from a lobby.  If the player being removed is the host, a random player is chosen as the new host.  Hosts can avoid this by changing the `hostId` to another player using the **Update Lobby** API before leaving.
     * @summary Remove a player
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {string} playerId The ID of the player to execute the request against.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LobbyApi
     */
    removePlayer(lobbyId: string, playerId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Request authentication tokens for use with other services that interact with Lobby.
     * @summary Authentication token request
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {Array<TokenRequest>} tokenRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LobbyApi
     */
    requestTokens(lobbyId: string, tokenRequest: Array<TokenRequest>, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<{
        [key: string]: TokenData;
    }>>;
    /**
     * Update the properties of a lobby.  This could include the lobby name, number of max players, the lobby\'s `data` property, etc.
     * @summary Update lobby data
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {UpdateRequest} [updateRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LobbyApi
     */
    updateLobby(lobbyId: string, updateRequest?: UpdateRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Lobby>>;
    /**
     * Update the properties of a player.  Only the player matching the player ID can perform this action.  This could include updating the `data` property for an individual player to include game-specific metadata.  The index data property is not allowed on player data objects at this time.
     * @summary Update player data
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {string} playerId The ID of the player to execute the request against.
     * @param {PlayerUpdateRequest} [playerUpdateRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LobbyApi
     */
    updatePlayer(lobbyId: string, playerId: string, playerUpdateRequest?: PlayerUpdateRequest, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<Lobby>>;
}
