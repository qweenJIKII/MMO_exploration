/* tslint:disable */
/* eslint-disable */
/**
 * Economy API
 * # Introduction   This document outlines the API specification for the Economy API.   The Economy service allows the game client to retrieve and modify a player\'s economy resources in the cloud. ## Notes about the beta version   During the beta period, Unity cannot guarantee the information in this document. # Concepts   ## Resources   Economy currently allows interaction with the following types of resources:   - Currencies: A resource that, when defined, contains two parameters: Initial and Max. The Initial parameter determines how much of the currency a game assigns to a player upon first interacting with the Economy system. The Max parameter determines how much of the currency the player is allowed to have.   - Inventory Items: A resource that doesn\'t have any set parameters; its intended use is to indicate the ownership or acquisition of an item in-game, for example, Sword and Shield.     A game client can add, remove or update the associated data of an instance of a configured inventory item from the player\'s inventory.   - Virtual Purchases: A transactional resource to implement a shop or trade feature. Allows the player to buy items/currencies using the previously defined currencies or inventory items.     A game client can redeem a virtual purchase and the player\'s account updates with the rewards if the costs criteria are met.   - Real Money Purchases: A transactional resource with the intended use to facilitate a shop or trade feature. Allows the player to buy any amount of items/currencies through an in-app purchase. Only uses the previously defined currencies or inventory items.     A game client can redeem a real money purchase and the player\'s account updates with the rewards.      The above resources also have an optional Custom Data parameter that can be populated with JSON data from the dashboard to allow clients to read bespoke data.   ## Writelock   The WriteLock is an integer that is automatically incremented serverside whenever a request that changes the stored value of a player\'s account or inventory.   The purpose of the WriteLock is to help prevent requests from the same or other game clients happening out-of-sync.   This parameter is optional, but when supplied with a request, the service does a comparison with the stored WriteLock on the server, and returns an error on mismatch.   ## Rate Limits   The API has rate limiting in place. Requests are limited on a per-player basis up to 60 requests per minute.   The API responds with a `429` HTTP status code if the requests exceed the rate limit.   Responses with a `429` status code include a `Retry-After` header to be used in conjunction with a client\'s retry logic, the value is the number of seconds until a request for the given player is accepted.
 *
 * The version of the OpenAPI document: 2.0-beta
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration";
import globalAxios, {
  AxiosPromise,
  AxiosInstance,
  AxiosRequestConfig,
} from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from "./base";

/**
 *
 * @export
 * @interface AddInventoryRequest
 */
export interface AddInventoryRequest {
  /**
   * Resource ID of the inventory item.
   * @type {string}
   * @memberof AddInventoryRequest
   */
  inventoryItemId: string;
  /**
   * A `playersInventoryItemId` for the item being created. If not given, Economy automatically generates the ID. An ID must be unique for a player.
   * @type {string}
   * @memberof AddInventoryRequest
   */
  playersInventoryItemId?: string;
  /**
   * Instance data to be saved against the new inventory item. Max size when serialized 5 KB.
   * @type {object}
   * @memberof AddInventoryRequest
   */
  instanceData?: object | null;
}
/**
 * Referenced from - https://tools.ietf.org/html/rfc7807#page-3 Consumers MUST use the \'type\' string as the primary identifier for the problem type; the \'title\' string is advisory and included only for users who are not aware of the semantics of the URI and do not have the ability to discover them (for example, offline log analysis). Consumers SHOULD NOT automatically dereference the type URI. The \"status\" member, if present, is only advisory; it conveys the HTTP status code used for the convenience of the consumer. Generators MUST use the same status code in the actual HTTP response, to assure that generic HTTP software that does not understand this format still behaves correctly.  See Section 5 for further caveats regarding its use. Consumers can use the status member to determine what the original status code used by the generator was, in cases where it has been changed (for example, by an intermediary or cache), and when message bodies persist without HTTP information.  Generic HTTP software still uses the HTTP status code. The \"detail\" member, if present, should focus on helping the client correct the problem, rather than giving debugging information.
 * @export
 * @interface BasicErrorResponse
 */
export interface BasicErrorResponse {
  /**
   * A URI reference [RFC3986] that identifies the problem type. This specification encourages that, when dereferenced, it provide human-readable documentation for the problem type (for example, using HTML [W3C.REC-html5-20141028]). When this member is not present, its value is assumed to be \"about:blank\".
   * @type {string}
   * @memberof BasicErrorResponse
   */
  type: string;
  /**
   * A short, human-readable summary of the problem type. It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization (for example, using proactive content negotiation; see [RFC7231], Section 3.4).
   * @type {string}
   * @memberof BasicErrorResponse
   */
  title?: string;
  /**
   * The HTTP status code ([RFC7231], Section 6) generated by the origin server for this occurrence of the problem.
   * @type {number}
   * @memberof BasicErrorResponse
   */
  status?: number;
  /**
   * Service specific error code.
   * @type {number}
   * @memberof BasicErrorResponse
   */
  code?: number;
  /**
   * A human-readable explanation specific to this occurrence of the problem.
   * @type {string}
   * @memberof BasicErrorResponse
   */
  detail?: string;
  /**
   * A URI reference that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
   * @type {string}
   * @memberof BasicErrorResponse
   */
  instance?: string;
  /**
   * Machine readable service specific errors.
   * @type {Array<object>}
   * @memberof BasicErrorResponse
   */
  details?: Array<object>;
}
/**
 *
 * @export
 * @interface Cost
 */
export interface Cost {
  /**
   * The ID of the currency or inventory item that is deducted as part of the purchase.
   * @type {string}
   * @memberof Cost
   */
  resourceId: string;
  /**
   * The amount of the item deducted as part of the purchase.
   * @type {number}
   * @memberof Cost
   */
  amount: number;
}
/**
 *
 * @export
 * @interface CurrencyBalanceRequest
 */
export interface CurrencyBalanceRequest {
  /**
   * Resource ID of the currency.
   * @type {string}
   * @memberof CurrencyBalanceRequest
   */
  currencyId: string;
  /**
   * The player\'s balance.
   * @type {number}
   * @memberof CurrencyBalanceRequest
   */
  balance: number;
  /**
   * The write lock for the currency balance.
   * @type {string}
   * @memberof CurrencyBalanceRequest
   */
  writeLock?: string;
}
/**
 *
 * @export
 * @interface CurrencyBalanceResponse
 */
export interface CurrencyBalanceResponse {
  /**
   * Resource ID of the currency.
   * @type {string}
   * @memberof CurrencyBalanceResponse
   */
  currencyId: string;
  /**
   * The player\'s balance.
   * @type {number}
   * @memberof CurrencyBalanceResponse
   */
  balance: number;
  /**
   * The write lock for the currency balance.
   * @type {string}
   * @memberof CurrencyBalanceResponse
   */
  writeLock: string;
  /**
   *
   * @type {ModifiedMetadata}
   * @memberof CurrencyBalanceResponse
   */
  created: ModifiedMetadata;
  /**
   *
   * @type {ModifiedMetadata}
   * @memberof CurrencyBalanceResponse
   */
  modified: ModifiedMetadata;
}
/**
 *
 * @export
 * @interface CurrencyExchangeItem
 */
export interface CurrencyExchangeItem {
  /**
   * ID of the currency.
   * @type {string}
   * @memberof CurrencyExchangeItem
   */
  id: string;
  /**
   * Amount of currency added or deducted.
   * @type {number}
   * @memberof CurrencyExchangeItem
   */
  amount: number;
}
/**
 *
 * @export
 * @interface CurrencyModifyBalanceRequest
 */
export interface CurrencyModifyBalanceRequest {
  /**
   * Resource ID of the currency.
   * @type {string}
   * @memberof CurrencyModifyBalanceRequest
   */
  currencyId: string;
  /**
   * The value by which to increment or decrement. Zero is allowed but results in no change to the currency balance.
   * @type {number}
   * @memberof CurrencyModifyBalanceRequest
   */
  amount: number;
  /**
   * The write lock for the currency balance.
   * @type {string}
   * @memberof CurrencyModifyBalanceRequest
   */
  writeLock?: string;
}
/**
 * The definition for a economy resource that represents a currency.
 * @export
 * @interface CurrencyResource
 */
export interface CurrencyResource {
  /**
   * Identifier for the resource.
   * @type {string}
   * @memberof CurrencyResource
   */
  id: string;
  /**
   * Name of the resource.
   * @type {string}
   * @memberof CurrencyResource
   */
  name: string;
  /**
   * Type of the resource, for example `CURRENCY`, `INVENTORY_ITEM`, `VIRTUAL_PURCHASE`, `MONEY_PURCHASE`.
   * @type {string}
   * @memberof CurrencyResource
   */
  type: CurrencyResourceTypeEnum;
  /**
   *
   * @type {ModifiedMetadata}
   * @memberof CurrencyResource
   */
  created: ModifiedMetadata;
  /**
   *
   * @type {ModifiedMetadata}
   * @memberof CurrencyResource
   */
  modified: ModifiedMetadata;
  /**
   *
   * @type {number}
   * @memberof CurrencyResource
   */
  initial?: number;
  /**
   *
   * @type {number}
   * @memberof CurrencyResource
   */
  max?: number;
  /**
   *
   * @type {object}
   * @memberof CurrencyResource
   */
  customData?: object | null;
}

export const CurrencyResourceTypeEnum = {
  Currency: "CURRENCY",
} as const;

export type CurrencyResourceTypeEnum =
  typeof CurrencyResourceTypeEnum[keyof typeof CurrencyResourceTypeEnum];

/**
 * An error response sent back upon currency balance conflict.
 * @export
 * @interface ErrorResponseConflictCurrencyBalance
 */
export interface ErrorResponseConflictCurrencyBalance {
  /**
   *
   * @type {string}
   * @memberof ErrorResponseConflictCurrencyBalance
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof ErrorResponseConflictCurrencyBalance
   */
  title: string;
  /**
   * For example 409
   * @type {number}
   * @memberof ErrorResponseConflictCurrencyBalance
   */
  status: number;
  /**
   * For example 10204
   * @type {number}
   * @memberof ErrorResponseConflictCurrencyBalance
   */
  code: number;
  /**
   *
   * @type {string}
   * @memberof ErrorResponseConflictCurrencyBalance
   */
  detail: string;
  /**
   *
   * @type {string}
   * @memberof ErrorResponseConflictCurrencyBalance
   */
  instance?: string;
  /**
   *
   * @type {ErrorResponseConflictCurrencyBalanceData}
   * @memberof ErrorResponseConflictCurrencyBalance
   */
  data: ErrorResponseConflictCurrencyBalanceData;
}
/**
 *
 * @export
 * @interface ErrorResponseConflictCurrencyBalanceData
 */
export interface ErrorResponseConflictCurrencyBalanceData {
  /**
   *
   * @type {CurrencyBalanceRequest}
   * @memberof ErrorResponseConflictCurrencyBalanceData
   */
  attempted: CurrencyBalanceRequest;
  /**
   *
   * @type {CurrencyBalanceResponse}
   * @memberof ErrorResponseConflictCurrencyBalanceData
   */
  existing: CurrencyBalanceResponse | null;
}
/**
 * An error response sent back upon player inventory item conflict.
 * @export
 * @interface ErrorResponseConflictInventory
 */
export interface ErrorResponseConflictInventory {
  /**
   *
   * @type {string}
   * @memberof ErrorResponseConflictInventory
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof ErrorResponseConflictInventory
   */
  title: string;
  /**
   * e.g 409
   * @type {number}
   * @memberof ErrorResponseConflictInventory
   */
  status: number;
  /**
   * For example 10204
   * @type {number}
   * @memberof ErrorResponseConflictInventory
   */
  code: number;
  /**
   *
   * @type {string}
   * @memberof ErrorResponseConflictInventory
   */
  detail: string;
  /**
   *
   * @type {string}
   * @memberof ErrorResponseConflictInventory
   */
  instance?: string;
  /**
   *
   * @type {ErrorResponseConflictInventoryUpdateData}
   * @memberof ErrorResponseConflictInventory
   */
  data: ErrorResponseConflictInventoryUpdateData;
}
/**
 * An error response sent back upon player inventory item conflict.
 * @export
 * @interface ErrorResponseConflictInventoryDelete
 */
export interface ErrorResponseConflictInventoryDelete {
  /**
   *
   * @type {string}
   * @memberof ErrorResponseConflictInventoryDelete
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof ErrorResponseConflictInventoryDelete
   */
  title: string;
  /**
   * e.g 409
   * @type {number}
   * @memberof ErrorResponseConflictInventoryDelete
   */
  status: number;
  /**
   * For example 10204
   * @type {number}
   * @memberof ErrorResponseConflictInventoryDelete
   */
  code: number;
  /**
   *
   * @type {string}
   * @memberof ErrorResponseConflictInventoryDelete
   */
  detail: string;
  /**
   *
   * @type {string}
   * @memberof ErrorResponseConflictInventoryDelete
   */
  instance?: string;
  /**
   *
   * @type {ErrorResponseConflictInventoryDeleteData}
   * @memberof ErrorResponseConflictInventoryDelete
   */
  data: ErrorResponseConflictInventoryDeleteData;
}
/**
 *
 * @export
 * @interface ErrorResponseConflictInventoryDeleteData
 */
export interface ErrorResponseConflictInventoryDeleteData {
  /**
   *
   * @type {InventoryDeleteRequest}
   * @memberof ErrorResponseConflictInventoryDeleteData
   */
  attempted: InventoryDeleteRequest;
  /**
   *
   * @type {InventoryResponse}
   * @memberof ErrorResponseConflictInventoryDeleteData
   */
  existing: InventoryResponse;
}
/**
 * An error response sent back upon player inventory item conflict.
 * @export
 * @interface ErrorResponseConflictInventoryUpdate
 */
export interface ErrorResponseConflictInventoryUpdate {
  /**
   *
   * @type {string}
   * @memberof ErrorResponseConflictInventoryUpdate
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof ErrorResponseConflictInventoryUpdate
   */
  title: string;
  /**
   * e.g 409
   * @type {number}
   * @memberof ErrorResponseConflictInventoryUpdate
   */
  status: number;
  /**
   * For example 10204
   * @type {number}
   * @memberof ErrorResponseConflictInventoryUpdate
   */
  code: number;
  /**
   *
   * @type {string}
   * @memberof ErrorResponseConflictInventoryUpdate
   */
  detail: string;
  /**
   *
   * @type {string}
   * @memberof ErrorResponseConflictInventoryUpdate
   */
  instance?: string;
  /**
   *
   * @type {ErrorResponseConflictInventoryUpdateData}
   * @memberof ErrorResponseConflictInventoryUpdate
   */
  data: ErrorResponseConflictInventoryUpdateData;
}
/**
 *
 * @export
 * @interface ErrorResponseConflictInventoryUpdateData
 */
export interface ErrorResponseConflictInventoryUpdateData {
  /**
   *
   * @type {AddInventoryRequest}
   * @memberof ErrorResponseConflictInventoryUpdateData
   */
  attempted: AddInventoryRequest;
  /**
   *
   * @type {InventoryResponse}
   * @memberof ErrorResponseConflictInventoryUpdateData
   */
  existing: InventoryResponse | null;
}
/**
 * An error response sent back upon a redeem Apple App Store purchase.
 * @export
 * @interface ErrorResponsePurchaseAppleappstoreFailed
 */
export interface ErrorResponsePurchaseAppleappstoreFailed {
  /**
   *
   * @type {string}
   * @memberof ErrorResponsePurchaseAppleappstoreFailed
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof ErrorResponsePurchaseAppleappstoreFailed
   */
  title: string;
  /**
   * e.g 409
   * @type {number}
   * @memberof ErrorResponsePurchaseAppleappstoreFailed
   */
  status: number;
  /**
   * For example 10204
   * @type {number}
   * @memberof ErrorResponsePurchaseAppleappstoreFailed
   */
  code: number;
  /**
   *
   * @type {string}
   * @memberof ErrorResponsePurchaseAppleappstoreFailed
   */
  detail: string;
  /**
   *
   * @type {string}
   * @memberof ErrorResponsePurchaseAppleappstoreFailed
   */
  instance?: string;
  /**
   *
   * @type {PlayerPurchaseAppleappstoreResponse}
   * @memberof ErrorResponsePurchaseAppleappstoreFailed
   */
  data: PlayerPurchaseAppleappstoreResponse;
}
/**
 * An error response sent back upon a redeem Google Play purchase.
 * @export
 * @interface ErrorResponsePurchaseGoogleplaystoreFailed
 */
export interface ErrorResponsePurchaseGoogleplaystoreFailed {
  /**
   *
   * @type {string}
   * @memberof ErrorResponsePurchaseGoogleplaystoreFailed
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof ErrorResponsePurchaseGoogleplaystoreFailed
   */
  title: string;
  /**
   * e.g 409
   * @type {number}
   * @memberof ErrorResponsePurchaseGoogleplaystoreFailed
   */
  status: number;
  /**
   * For example 10204
   * @type {number}
   * @memberof ErrorResponsePurchaseGoogleplaystoreFailed
   */
  code: number;
  /**
   *
   * @type {string}
   * @memberof ErrorResponsePurchaseGoogleplaystoreFailed
   */
  detail: string;
  /**
   *
   * @type {string}
   * @memberof ErrorResponsePurchaseGoogleplaystoreFailed
   */
  instance?: string;
  /**
   *
   * @type {PlayerPurchaseGoogleplaystoreResponse}
   * @memberof ErrorResponsePurchaseGoogleplaystoreFailed
   */
  data: PlayerPurchaseGoogleplaystoreResponse;
}
/**
 *
 * @export
 * @interface InventoryDeleteRequest
 */
export interface InventoryDeleteRequest {
  /**
   * The write lock for the inventory item instance.
   * @type {string}
   * @memberof InventoryDeleteRequest
   */
  writeLock?: string;
}
/**
 *
 * @export
 * @interface InventoryExchangeItem
 */
export interface InventoryExchangeItem {
  /**
   * ID of the inventory item.
   * @type {string}
   * @memberof InventoryExchangeItem
   */
  id: string;
  /**
   * Number of player inventory items.
   * @type {number}
   * @memberof InventoryExchangeItem
   */
  amount: number;
  /**
   * The `playersInventoryItemIds` for the player\'s items to be added or removed.
   * @type {Set<string>}
   * @memberof InventoryExchangeItem
   */
  playersInventoryItemIds: Set<string>;
}
/**
 * The definition for a economy resource that represents a inventory item.
 * @export
 * @interface InventoryItemResource
 */
export interface InventoryItemResource {
  /**
   * Identifier for the resource.
   * @type {string}
   * @memberof InventoryItemResource
   */
  id: string;
  /**
   * Name of the resource.
   * @type {string}
   * @memberof InventoryItemResource
   */
  name: string;
  /**
   * Type of the resource, for example `CURRENCY`, `INVENTORY_ITEM`, `VIRTUAL_PURCHASE`, `MONEY_PURCHASE`.
   * @type {string}
   * @memberof InventoryItemResource
   */
  type: InventoryItemResourceTypeEnum;
  /**
   *
   * @type {ModifiedMetadata}
   * @memberof InventoryItemResource
   */
  created: ModifiedMetadata;
  /**
   *
   * @type {ModifiedMetadata}
   * @memberof InventoryItemResource
   */
  modified: ModifiedMetadata;
  /**
   *
   * @type {object}
   * @memberof InventoryItemResource
   */
  customData?: object | null;
}

export const InventoryItemResourceTypeEnum = {
  InventoryItem: "INVENTORY_ITEM",
} as const;

export type InventoryItemResourceTypeEnum =
  typeof InventoryItemResourceTypeEnum[keyof typeof InventoryItemResourceTypeEnum];

/**
 *
 * @export
 * @interface InventoryRequestUpdate
 */
export interface InventoryRequestUpdate {
  /**
   * Instance data to be saved against the inventory item. Max size when serialized 5 KB.
   * @type {object}
   * @memberof InventoryRequestUpdate
   */
  instanceData: object | null;
  /**
   * The write lock for the inventory item instance.
   * @type {string}
   * @memberof InventoryRequestUpdate
   */
  writeLock?: string;
}
/**
 *
 * @export
 * @interface InventoryResponse
 */
export interface InventoryResponse {
  /**
   * ID of the player\'s inventory item.
   * @type {string}
   * @memberof InventoryResponse
   */
  playersInventoryItemId: string;
  /**
   * Resource ID of the inventory item configuration associated with this instance.
   * @type {string}
   * @memberof InventoryResponse
   */
  inventoryItemId: string;
  /**
   * Instance data. Max size when serialized 5 KB.
   * @type {object}
   * @memberof InventoryResponse
   */
  instanceData?: object | null;
  /**
   * The write lock for the inventory item instance.
   * @type {string}
   * @memberof InventoryResponse
   */
  writeLock: string;
  /**
   *
   * @type {ModifiedMetadata}
   * @memberof InventoryResponse
   */
  created: ModifiedMetadata;
  /**
   *
   * @type {ModifiedMetadata}
   * @memberof InventoryResponse
   */
  modified: ModifiedMetadata;
}
/**
 *
 * @export
 * @interface ModifiedMetadata
 */
export interface ModifiedMetadata {
  /**
   * Date time in ISO 8601 format. `null` if there is no associated value.
   * @type {string}
   * @memberof ModifiedMetadata
   */
  date: string | null;
}
/**
 *
 * @export
 * @interface PlayerConfigurationResponse
 */
export interface PlayerConfigurationResponse {
  /**
   * Hash representing the exact version of the configuration in the response.
   * @type {string}
   * @memberof PlayerConfigurationResponse
   */
  configAssignmentHash: string;
  /**
   * Array of resource definitions.
   * @type {Array<CurrencyResource | InventoryItemResource | VirtualPurchaseResource | RealMoneyPurchaseResource>}
   * @memberof PlayerConfigurationResponse
   */
  results: Array<
    | CurrencyResource
    | InventoryItemResource
    | VirtualPurchaseResource
    | RealMoneyPurchaseResource
  >;
}
/**
 *
 * @export
 * @interface PlayerCurrencyBalanceResponse
 */
export interface PlayerCurrencyBalanceResponse {
  /**
   * List of currency balances.
   * @type {Array<CurrencyBalanceResponse>}
   * @memberof PlayerCurrencyBalanceResponse
   */
  results: Array<CurrencyBalanceResponse>;
  /**
   *
   * @type {PlayerCurrencyBalanceResponseLinks}
   * @memberof PlayerCurrencyBalanceResponse
   */
  links: PlayerCurrencyBalanceResponseLinks;
}
/**
 *
 * @export
 * @interface PlayerCurrencyBalanceResponseLinks
 */
export interface PlayerCurrencyBalanceResponseLinks {
  /**
   * Contains the URL path for requesting the next page of results. This value is `null` when there are no pages remaining.
   * @type {string}
   * @memberof PlayerCurrencyBalanceResponseLinks
   */
  next: string | null;
}
/**
 *
 * @export
 * @interface PlayerInventoryResponse
 */
export interface PlayerInventoryResponse {
  /**
   * List of player\'s inventory items.
   * @type {Array<InventoryResponse>}
   * @memberof PlayerInventoryResponse
   */
  results: Array<InventoryResponse>;
  /**
   *
   * @type {PlayerCurrencyBalanceResponseLinks}
   * @memberof PlayerInventoryResponse
   */
  links: PlayerCurrencyBalanceResponseLinks;
}
/**
 *
 * @export
 * @interface PlayerPurchaseAppleappstoreRequest
 */
export interface PlayerPurchaseAppleappstoreRequest {
  /**
   * ID of the purchase.
   * @type {string}
   * @memberof PlayerPurchaseAppleappstoreRequest
   */
  id: string;
  /**
   * Receipt data returned from the Apple App Store as a result of a successful purchase. This should be base64 encoded.
   * @type {string}
   * @memberof PlayerPurchaseAppleappstoreRequest
   */
  receipt: string;
  /**
   * The cost of the purchase as an integer in the minor currency format, for example, $1.99 USD would be 199.
   * @type {number}
   * @memberof PlayerPurchaseAppleappstoreRequest
   */
  localCost: number;
  /**
   * The ISO-4217 currency code with which the player purchased the IAP.
   * @type {string}
   * @memberof PlayerPurchaseAppleappstoreRequest
   */
  localCurrency: string;
}
/**
 *
 * @export
 * @interface PlayerPurchaseAppleappstoreResponse
 */
export interface PlayerPurchaseAppleappstoreResponse {
  /**
   *
   * @type {PlayerPurchaseAppleappstoreResponseVerification}
   * @memberof PlayerPurchaseAppleappstoreResponse
   */
  verification: PlayerPurchaseAppleappstoreResponseVerification;
  /**
   *
   * @type {PlayerPurchaseVirtualResponseRewards}
   * @memberof PlayerPurchaseAppleappstoreResponse
   */
  rewards: PlayerPurchaseVirtualResponseRewards;
}
/**
 *
 * @export
 * @interface PlayerPurchaseAppleappstoreResponseVerification
 */
export interface PlayerPurchaseAppleappstoreResponseVerification {
  /**
   * Status of the receipt verification.  * `VALID`: The purchase was valid.  * `VALID_NOT_REDEEMED`: The purchase was valid but seen before, and had not yet been redeemed.  * `INVALID_ALREADY_REDEEMED`: The purchase has already been redeemed.  * `INVALID_VERIFICATION_FAILED`: The receipt verification Service returned that the receipt data was not valid.  * `INVALID_ANOTHER_PLAYER`: The receipt has previously been used by a different player and validated.  * `INVALID_CONFIGURATION`: The service configuration is invalid, further information in the details section of the response.  * `INVALID_PRODUCT_ID_MISMATCH`: The purchase configuration store product identifier does not match the one in the receipt.
   * @type {string}
   * @memberof PlayerPurchaseAppleappstoreResponseVerification
   */
  status: PlayerPurchaseAppleappstoreResponseVerificationStatusEnum;
  /**
   *
   * @type {PlayerPurchaseAppleappstoreResponseVerificationStore}
   * @memberof PlayerPurchaseAppleappstoreResponseVerification
   */
  store: PlayerPurchaseAppleappstoreResponseVerificationStore;
}

export const PlayerPurchaseAppleappstoreResponseVerificationStatusEnum = {
  Valid: "VALID",
  ValidNotRedeemed: "VALID_NOT_REDEEMED",
  InvalidAlreadyRedeemed: "INVALID_ALREADY_REDEEMED",
  InvalidVerificationFailed: "INVALID_VERIFICATION_FAILED",
  InvalidAnotherPlayer: "INVALID_ANOTHER_PLAYER",
  InvalidConfiguration: "INVALID_CONFIGURATION",
  InvalidProductIdMismatch: "INVALID_PRODUCT_ID_MISMATCH",
} as const;

export type PlayerPurchaseAppleappstoreResponseVerificationStatusEnum =
  typeof PlayerPurchaseAppleappstoreResponseVerificationStatusEnum[keyof typeof PlayerPurchaseAppleappstoreResponseVerificationStatusEnum];

/**
 * Details from the receipt validation service.
 * @export
 * @interface PlayerPurchaseAppleappstoreResponseVerificationStore
 */
export interface PlayerPurchaseAppleappstoreResponseVerificationStore {
  /**
   * The status code sent back from the Apple App Store verification service.
   * @type {string}
   * @memberof PlayerPurchaseAppleappstoreResponseVerificationStore
   */
  code: string | null;
  /**
   * A textual description of the returned status code.
   * @type {string}
   * @memberof PlayerPurchaseAppleappstoreResponseVerificationStore
   */
  message: string | null;
  /**
   * The full response from the Apple App Store verification service as a JSON encoded string.
   * @type {string}
   * @memberof PlayerPurchaseAppleappstoreResponseVerificationStore
   */
  receipt: string | null;
}
/**
 *
 * @export
 * @interface PlayerPurchaseGoogleplaystoreRequest
 */
export interface PlayerPurchaseGoogleplaystoreRequest {
  /**
   * ID of the purchase.
   * @type {string}
   * @memberof PlayerPurchaseGoogleplaystoreRequest
   */
  id: string;
  /**
   * A JSON encoded string returned from a successful in-app billing purchase.
   * @type {string}
   * @memberof PlayerPurchaseGoogleplaystoreRequest
   */
  purchaseData: string;
  /**
   * A signature of the `purchaseData` returned from a successful in-app billing purchase.
   * @type {string}
   * @memberof PlayerPurchaseGoogleplaystoreRequest
   */
  purchaseDataSignature: string;
  /**
   * The cost of the purchase as an integer in the minor currency format, for example, $1.99 USD would be 199.
   * @type {number}
   * @memberof PlayerPurchaseGoogleplaystoreRequest
   */
  localCost: number;
  /**
   * The ISO-4217 currency code with which the player purchased the IAP.
   * @type {string}
   * @memberof PlayerPurchaseGoogleplaystoreRequest
   */
  localCurrency: string;
}
/**
 *
 * @export
 * @interface PlayerPurchaseGoogleplaystoreResponse
 */
export interface PlayerPurchaseGoogleplaystoreResponse {
  /**
   *
   * @type {PlayerPurchaseGoogleplaystoreResponseVerification}
   * @memberof PlayerPurchaseGoogleplaystoreResponse
   */
  verification: PlayerPurchaseGoogleplaystoreResponseVerification;
  /**
   *
   * @type {PlayerPurchaseVirtualResponseRewards}
   * @memberof PlayerPurchaseGoogleplaystoreResponse
   */
  rewards: PlayerPurchaseVirtualResponseRewards;
}
/**
 *
 * @export
 * @interface PlayerPurchaseGoogleplaystoreResponseVerification
 */
export interface PlayerPurchaseGoogleplaystoreResponseVerification {
  /**
   * Status of the receipt verification.  * `VALID`: The purchase was valid.  * `VALID_NOT_REDEEMED`: The purchase was valid but seen before, and had not yet been redeemed.  * `INVALID_ALREADY_REDEEMED`: The purchase has already been redeemed.  * `INVALID_VERIFICATION_FAILED`: The receipt verification Service returned that the receipt data was not valid.  * `INVALID_ANOTHER_PLAYER`: The receipt has previously been used by a different player and validated.  * `INVALID_CONFIGURATION`: The service configuration is invalid, further information in the details section of the response.  * `INVALID_PRODUCT_ID_MISMATCH`: The purchase configuration store product identifier does not match the one in the receipt.
   * @type {string}
   * @memberof PlayerPurchaseGoogleplaystoreResponseVerification
   */
  status: PlayerPurchaseGoogleplaystoreResponseVerificationStatusEnum;
  /**
   *
   * @type {PlayerPurchaseGoogleplaystoreResponseVerificationStore}
   * @memberof PlayerPurchaseGoogleplaystoreResponseVerification
   */
  store: PlayerPurchaseGoogleplaystoreResponseVerificationStore;
}

export const PlayerPurchaseGoogleplaystoreResponseVerificationStatusEnum = {
  Valid: "VALID",
  ValidNotRedeemed: "VALID_NOT_REDEEMED",
  InvalidAlreadyRedeemed: "INVALID_ALREADY_REDEEMED",
  InvalidVerificationFailed: "INVALID_VERIFICATION_FAILED",
  InvalidAnotherPlayer: "INVALID_ANOTHER_PLAYER",
  InvalidConfiguration: "INVALID_CONFIGURATION",
  InvalidProductIdMismatch: "INVALID_PRODUCT_ID_MISMATCH",
} as const;

export type PlayerPurchaseGoogleplaystoreResponseVerificationStatusEnum =
  typeof PlayerPurchaseGoogleplaystoreResponseVerificationStatusEnum[keyof typeof PlayerPurchaseGoogleplaystoreResponseVerificationStatusEnum];

/**
 * Details from the receipt validation service.
 * @export
 * @interface PlayerPurchaseGoogleplaystoreResponseVerificationStore
 */
export interface PlayerPurchaseGoogleplaystoreResponseVerificationStore {
  /**
   * Receipt that was sent in the request
   * @type {string}
   * @memberof PlayerPurchaseGoogleplaystoreResponseVerificationStore
   */
  receipt?: string;
}
/**
 *
 * @export
 * @interface PlayerPurchaseVirtualRequest
 */
export interface PlayerPurchaseVirtualRequest {
  /**
   * ID of the purchase.
   * @type {string}
   * @memberof PlayerPurchaseVirtualRequest
   */
  id: string;
  /**
   * IDs of the player\'s inventory items that should be used for any item costs associated with the purchase.
   * @type {Set<string>}
   * @memberof PlayerPurchaseVirtualRequest
   */
  playersInventoryItemIds?: Set<string>;
}
/**
 *
 * @export
 * @interface PlayerPurchaseVirtualResponse
 */
export interface PlayerPurchaseVirtualResponse {
  /**
   *
   * @type {PlayerPurchaseVirtualResponseCosts}
   * @memberof PlayerPurchaseVirtualResponse
   */
  costs: PlayerPurchaseVirtualResponseCosts;
  /**
   *
   * @type {PlayerPurchaseVirtualResponseRewards}
   * @memberof PlayerPurchaseVirtualResponse
   */
  rewards: PlayerPurchaseVirtualResponseRewards;
}
/**
 * Costs of the purchase.
 * @export
 * @interface PlayerPurchaseVirtualResponseCosts
 */
export interface PlayerPurchaseVirtualResponseCosts {
  /**
   * Currency that was deducted in the purchase.
   * @type {Array<CurrencyExchangeItem>}
   * @memberof PlayerPurchaseVirtualResponseCosts
   */
  currency?: Array<CurrencyExchangeItem>;
  /**
   * Inventory that was deducted in the purchase.
   * @type {Array<InventoryExchangeItem>}
   * @memberof PlayerPurchaseVirtualResponseCosts
   */
  inventory: Array<InventoryExchangeItem>;
}
/**
 * Rewards of the purchase.
 * @export
 * @interface PlayerPurchaseVirtualResponseRewards
 */
export interface PlayerPurchaseVirtualResponseRewards {
  /**
   * Currency that was credited in the purchase.
   * @type {Array<CurrencyExchangeItem>}
   * @memberof PlayerPurchaseVirtualResponseRewards
   */
  currency?: Array<CurrencyExchangeItem>;
  /**
   * Inventory that was credited in the purchase.
   * @type {Array<InventoryExchangeItem>}
   * @memberof PlayerPurchaseVirtualResponseRewards
   */
  inventory: Array<InventoryExchangeItem>;
}
/**
 * The definition for a economy resource that represents a real money purchase.
 * @export
 * @interface RealMoneyPurchaseResource
 */
export interface RealMoneyPurchaseResource {
  /**
   * ID of the resource.
   * @type {string}
   * @memberof RealMoneyPurchaseResource
   */
  id: string;
  /**
   * A descriptive name for the resource.
   * @type {string}
   * @memberof RealMoneyPurchaseResource
   */
  name: string;
  /**
   * Type of the item, for example `CURRENCY`, `INVENTORY_ITEM`, `VIRTUAL_PURCHASE`, `MONEY_PURCHASE`.
   * @type {string}
   * @memberof RealMoneyPurchaseResource
   */
  type: RealMoneyPurchaseResourceTypeEnum;
  /**
   *
   * @type {RealMoneyPurchaseResourceStoreIdentifiers}
   * @memberof RealMoneyPurchaseResource
   */
  storeIdentifiers: RealMoneyPurchaseResourceStoreIdentifiers;
  /**
   * The rewards credited to the player when making the purchase. A reward is composed of the ID of a currency or inventory item, the amount of that currency or item, and the default instance data (for inventory items).
   * @type {Array<Reward>}
   * @memberof RealMoneyPurchaseResource
   */
  rewards: Array<Reward>;
  /**
   * Max size when serialised 5 KB.
   * @type {object}
   * @memberof RealMoneyPurchaseResource
   */
  customData: object | null;
  /**
   *
   * @type {ModifiedMetadata}
   * @memberof RealMoneyPurchaseResource
   */
  created: ModifiedMetadata;
  /**
   *
   * @type {ModifiedMetadata}
   * @memberof RealMoneyPurchaseResource
   */
  modified: ModifiedMetadata;
}

export const RealMoneyPurchaseResourceTypeEnum = {
  MoneyPurchase: "MONEY_PURCHASE",
} as const;

export type RealMoneyPurchaseResourceTypeEnum =
  typeof RealMoneyPurchaseResourceTypeEnum[keyof typeof RealMoneyPurchaseResourceTypeEnum];

/**
 * Store identifiers.
 * @export
 * @interface RealMoneyPurchaseResourceStoreIdentifiers
 */
export interface RealMoneyPurchaseResourceStoreIdentifiers {
  /**
   * Apple App Store identifier.
   * @type {string}
   * @memberof RealMoneyPurchaseResourceStoreIdentifiers
   */
  appleAppStore?: string;
  /**
   * Google Play Store identifier.
   * @type {string}
   * @memberof RealMoneyPurchaseResourceStoreIdentifiers
   */
  googlePlayStore?: string;
}
/**
 *
 * @export
 * @interface Reward
 */
export interface Reward {
  /**
   * The ID of a currency or inventory item resource that is credited as part of the purchase.
   * @type {string}
   * @memberof Reward
   */
  resourceId: string;
  /**
   * The amount of the resource credited as part of the purchase.
   * @type {number}
   * @memberof Reward
   */
  amount: number;
  /**
   * When the reward is an inventory item resource, this specifies instance data automatically saved against the new inventory item. Max size when serialised 5 KB.
   * @type {object}
   * @memberof Reward
   */
  defaultInstanceData?: object | null;
}
/**
 * Single error in the Validation Error Response.
 * @export
 * @interface ValidationErrorBody
 */
export interface ValidationErrorBody {
  /**
   *
   * @type {string}
   * @memberof ValidationErrorBody
   */
  field: string;
  /**
   *
   * @type {Array<string>}
   * @memberof ValidationErrorBody
   */
  messages: Array<string>;
}
/**
 * Validation error response when a value provided from the client does not pass validation on server.
 * @export
 * @interface ValidationErrorResponse
 */
export interface ValidationErrorResponse {
  /**
   *
   * @type {string}
   * @memberof ValidationErrorResponse
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof ValidationErrorResponse
   */
  title: string;
  /**
   *
   * @type {number}
   * @memberof ValidationErrorResponse
   */
  status: number;
  /**
   *
   * @type {number}
   * @memberof ValidationErrorResponse
   */
  code: number;
  /**
   *
   * @type {string}
   * @memberof ValidationErrorResponse
   */
  detail: string;
  /**
   *
   * @type {string}
   * @memberof ValidationErrorResponse
   */
  instance?: string;
  /**
   *
   * @type {Array<ValidationErrorBody>}
   * @memberof ValidationErrorResponse
   */
  errors: Array<ValidationErrorBody>;
}
/**
 * The definition for a economy resource that represents a virtual purchase.
 * @export
 * @interface VirtualPurchaseResource
 */
export interface VirtualPurchaseResource {
  /**
   * Identifier for the resource.
   * @type {string}
   * @memberof VirtualPurchaseResource
   */
  id: string;
  /**
   * Name of the resource.
   * @type {string}
   * @memberof VirtualPurchaseResource
   */
  name: string;
  /**
   * Type of the item, for example `CURRENCY`, `INVENTORY_ITEM`, `VIRTUAL_PURCHASE`, `MONEY_PURCHASE`.
   * @type {string}
   * @memberof VirtualPurchaseResource
   */
  type: VirtualPurchaseResourceTypeEnum;
  /**
   *
   * @type {ModifiedMetadata}
   * @memberof VirtualPurchaseResource
   */
  created: ModifiedMetadata;
  /**
   *
   * @type {ModifiedMetadata}
   * @memberof VirtualPurchaseResource
   */
  modified: ModifiedMetadata;
  /**
   * The costs deducted from the player when making the purchase. A cost is an ID of a currency or inventory item, plus an amount.
   * @type {Array<Cost>}
   * @memberof VirtualPurchaseResource
   */
  costs?: Array<Cost>;
  /**
   * The rewards credited to the player when making the purchase. A reward is composed of the ID of a currency or inventory item, the amount of that currency or item, and the default instance data (for inventory items).
   * @type {Array<Reward>}
   * @memberof VirtualPurchaseResource
   */
  rewards?: Array<Reward>;
  /**
   *
   * @type {string}
   * @memberof VirtualPurchaseResource
   */
  customData?: string;
}

export const VirtualPurchaseResourceTypeEnum = {
  VirtualPurchase: "VIRTUAL_PURCHASE",
} as const;

export type VirtualPurchaseResourceTypeEnum =
  typeof VirtualPurchaseResourceTypeEnum[keyof typeof VirtualPurchaseResourceTypeEnum];

/**
 * ConfigurationApi - axios parameter creator
 * @export
 */
export const ConfigurationApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Returns the economy configuration for the player with any overrides applied.
     * @summary Get player\'s configuration
     * @param {string} projectId ID of the project.
     * @param {string} playerId ID of the player.
     * @param {string} [configAssignmentHash] Configuration assignment hash that should be used when processing this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPlayerConfiguration: async (
      projectId: string,
      playerId: string,
      configAssignmentHash?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("getPlayerConfiguration", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("getPlayerConfiguration", "playerId", playerId);
      const localVarPath =
        `/v2/projects/{projectId}/players/{playerId}/config/resources`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication JWT required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (configAssignmentHash !== undefined) {
        localVarQueryParameter["configAssignmentHash"] = configAssignmentHash;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ConfigurationApi - functional programming interface
 * @export
 */
export const ConfigurationApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    ConfigurationApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns the economy configuration for the player with any overrides applied.
     * @summary Get player\'s configuration
     * @param {string} projectId ID of the project.
     * @param {string} playerId ID of the player.
     * @param {string} [configAssignmentHash] Configuration assignment hash that should be used when processing this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPlayerConfiguration(
      projectId: string,
      playerId: string,
      configAssignmentHash?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PlayerConfigurationResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPlayerConfiguration(
          projectId,
          playerId,
          configAssignmentHash,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * ConfigurationApi - factory interface
 * @export
 */
export const ConfigurationApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ConfigurationApiFp(configuration);
  return {
    /**
     * Returns the economy configuration for the player with any overrides applied.
     * @summary Get player\'s configuration
     * @param {string} projectId ID of the project.
     * @param {string} playerId ID of the player.
     * @param {string} [configAssignmentHash] Configuration assignment hash that should be used when processing this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPlayerConfiguration(
      projectId: string,
      playerId: string,
      configAssignmentHash?: string,
      options?: any
    ): AxiosPromise<PlayerConfigurationResponse> {
      return localVarFp
        .getPlayerConfiguration(
          projectId,
          playerId,
          configAssignmentHash,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for getPlayerConfiguration operation in ConfigurationApi.
 * @export
 * @interface ConfigurationApiGetPlayerConfigurationRequest
 */
export interface ConfigurationApiGetPlayerConfigurationRequest {
  /**
   * ID of the project.
   * @type {string}
   * @memberof ConfigurationApiGetPlayerConfiguration
   */
  readonly projectId: string;

  /**
   * ID of the player.
   * @type {string}
   * @memberof ConfigurationApiGetPlayerConfiguration
   */
  readonly playerId: string;

  /**
   * Configuration assignment hash that should be used when processing this request.
   * @type {string}
   * @memberof ConfigurationApiGetPlayerConfiguration
   */
  readonly configAssignmentHash?: string;
}

/**
 * ConfigurationApi - object-oriented interface
 * @export
 * @class ConfigurationApi
 * @extends {BaseAPI}
 */
export class ConfigurationApi extends BaseAPI {
  /**
   * Returns the economy configuration for the player with any overrides applied.
   * @summary Get player\'s configuration
   * @param {ConfigurationApiGetPlayerConfigurationRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ConfigurationApi
   */
  public getPlayerConfiguration(
    requestParameters: ConfigurationApiGetPlayerConfigurationRequest,
    options?: AxiosRequestConfig
  ) {
    return ConfigurationApiFp(this.configuration)
      .getPlayerConfiguration(
        requestParameters.projectId,
        requestParameters.playerId,
        requestParameters.configAssignmentHash,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * CurrenciesApi - axios parameter creator
 * @export
 */
export const CurrenciesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Decrements a player\'s currency balance by a given value.
     * @summary Decrement currency balance
     * @param {string} projectId ID of the project.
     * @param {string} playerId ID of the player.
     * @param {string} currencyId Resource ID of the currency.
     * @param {CurrencyModifyBalanceRequest} currencyModifyBalanceRequest
     * @param {string} [configAssignmentHash] Configuration assignment hash that should be used when processing this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    decrementPlayerCurrencyBalance: async (
      projectId: string,
      playerId: string,
      currencyId: string,
      currencyModifyBalanceRequest: CurrencyModifyBalanceRequest,
      configAssignmentHash?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        "decrementPlayerCurrencyBalance",
        "projectId",
        projectId
      );
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("decrementPlayerCurrencyBalance", "playerId", playerId);
      // verify required parameter 'currencyId' is not null or undefined
      assertParamExists(
        "decrementPlayerCurrencyBalance",
        "currencyId",
        currencyId
      );
      // verify required parameter 'currencyModifyBalanceRequest' is not null or undefined
      assertParamExists(
        "decrementPlayerCurrencyBalance",
        "currencyModifyBalanceRequest",
        currencyModifyBalanceRequest
      );
      const localVarPath =
        `/v2/projects/{projectId}/players/{playerId}/currencies/{currencyId}/decrement`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)))
          .replace(`{${"currencyId"}}`, encodeURIComponent(String(currencyId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication JWT required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (configAssignmentHash !== undefined) {
        localVarQueryParameter["configAssignmentHash"] = configAssignmentHash;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        currencyModifyBalanceRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of currency balances for a player. Results ordered in ascending currency ID.
     * @summary Player currency balances
     * @param {string} projectId ID of the project.
     * @param {string} playerId ID of the player.
     * @param {string} [configAssignmentHash] Configuration assignment hash that should be used when processing this request.
     * @param {string} [after] The currency ID after which to retrieve the next page of balances.
     * @param {number} [limit] Number of currencies to be returned. Defaults to 20.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPlayerCurrencies: async (
      projectId: string,
      playerId: string,
      configAssignmentHash?: string,
      after?: string,
      limit?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("getPlayerCurrencies", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("getPlayerCurrencies", "playerId", playerId);
      const localVarPath =
        `/v2/projects/{projectId}/players/{playerId}/currencies`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication JWT required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (configAssignmentHash !== undefined) {
        localVarQueryParameter["configAssignmentHash"] = configAssignmentHash;
      }

      if (after !== undefined) {
        localVarQueryParameter["after"] = after;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Increment a player\'s currency balance by a given value.
     * @summary Increment currency balance
     * @param {string} projectId ID of the project.
     * @param {string} playerId ID of the player.
     * @param {string} currencyId Resource ID of the currency.
     * @param {CurrencyModifyBalanceRequest} currencyModifyBalanceRequest
     * @param {string} [configAssignmentHash] Configuration assignment hash that should be used when processing this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    incrementPlayerCurrencyBalance: async (
      projectId: string,
      playerId: string,
      currencyId: string,
      currencyModifyBalanceRequest: CurrencyModifyBalanceRequest,
      configAssignmentHash?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        "incrementPlayerCurrencyBalance",
        "projectId",
        projectId
      );
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("incrementPlayerCurrencyBalance", "playerId", playerId);
      // verify required parameter 'currencyId' is not null or undefined
      assertParamExists(
        "incrementPlayerCurrencyBalance",
        "currencyId",
        currencyId
      );
      // verify required parameter 'currencyModifyBalanceRequest' is not null or undefined
      assertParamExists(
        "incrementPlayerCurrencyBalance",
        "currencyModifyBalanceRequest",
        currencyModifyBalanceRequest
      );
      const localVarPath =
        `/v2/projects/{projectId}/players/{playerId}/currencies/{currencyId}/increment`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)))
          .replace(`{${"currencyId"}}`, encodeURIComponent(String(currencyId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication JWT required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (configAssignmentHash !== undefined) {
        localVarQueryParameter["configAssignmentHash"] = configAssignmentHash;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        currencyModifyBalanceRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Set a player\'s currency balance.
     * @summary Set currency balance
     * @param {string} projectId ID of the project.
     * @param {string} playerId ID of the player.
     * @param {string} currencyId Resource ID of the currency.
     * @param {CurrencyBalanceRequest} currencyBalanceRequest
     * @param {string} [configAssignmentHash] Configuration assignment hash that should be used when processing this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setPlayerCurrencyBalance: async (
      projectId: string,
      playerId: string,
      currencyId: string,
      currencyBalanceRequest: CurrencyBalanceRequest,
      configAssignmentHash?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("setPlayerCurrencyBalance", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("setPlayerCurrencyBalance", "playerId", playerId);
      // verify required parameter 'currencyId' is not null or undefined
      assertParamExists("setPlayerCurrencyBalance", "currencyId", currencyId);
      // verify required parameter 'currencyBalanceRequest' is not null or undefined
      assertParamExists(
        "setPlayerCurrencyBalance",
        "currencyBalanceRequest",
        currencyBalanceRequest
      );
      const localVarPath =
        `/v2/projects/{projectId}/players/{playerId}/currencies/{currencyId}`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)))
          .replace(`{${"currencyId"}}`, encodeURIComponent(String(currencyId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication JWT required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (configAssignmentHash !== undefined) {
        localVarQueryParameter["configAssignmentHash"] = configAssignmentHash;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        currencyBalanceRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CurrenciesApi - functional programming interface
 * @export
 */
export const CurrenciesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    CurrenciesApiAxiosParamCreator(configuration);
  return {
    /**
     * Decrements a player\'s currency balance by a given value.
     * @summary Decrement currency balance
     * @param {string} projectId ID of the project.
     * @param {string} playerId ID of the player.
     * @param {string} currencyId Resource ID of the currency.
     * @param {CurrencyModifyBalanceRequest} currencyModifyBalanceRequest
     * @param {string} [configAssignmentHash] Configuration assignment hash that should be used when processing this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async decrementPlayerCurrencyBalance(
      projectId: string,
      playerId: string,
      currencyId: string,
      currencyModifyBalanceRequest: CurrencyModifyBalanceRequest,
      configAssignmentHash?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CurrencyBalanceResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.decrementPlayerCurrencyBalance(
          projectId,
          playerId,
          currencyId,
          currencyModifyBalanceRequest,
          configAssignmentHash,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a list of currency balances for a player. Results ordered in ascending currency ID.
     * @summary Player currency balances
     * @param {string} projectId ID of the project.
     * @param {string} playerId ID of the player.
     * @param {string} [configAssignmentHash] Configuration assignment hash that should be used when processing this request.
     * @param {string} [after] The currency ID after which to retrieve the next page of balances.
     * @param {number} [limit] Number of currencies to be returned. Defaults to 20.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPlayerCurrencies(
      projectId: string,
      playerId: string,
      configAssignmentHash?: string,
      after?: string,
      limit?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PlayerCurrencyBalanceResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPlayerCurrencies(
          projectId,
          playerId,
          configAssignmentHash,
          after,
          limit,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Increment a player\'s currency balance by a given value.
     * @summary Increment currency balance
     * @param {string} projectId ID of the project.
     * @param {string} playerId ID of the player.
     * @param {string} currencyId Resource ID of the currency.
     * @param {CurrencyModifyBalanceRequest} currencyModifyBalanceRequest
     * @param {string} [configAssignmentHash] Configuration assignment hash that should be used when processing this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async incrementPlayerCurrencyBalance(
      projectId: string,
      playerId: string,
      currencyId: string,
      currencyModifyBalanceRequest: CurrencyModifyBalanceRequest,
      configAssignmentHash?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CurrencyBalanceResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.incrementPlayerCurrencyBalance(
          projectId,
          playerId,
          currencyId,
          currencyModifyBalanceRequest,
          configAssignmentHash,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Set a player\'s currency balance.
     * @summary Set currency balance
     * @param {string} projectId ID of the project.
     * @param {string} playerId ID of the player.
     * @param {string} currencyId Resource ID of the currency.
     * @param {CurrencyBalanceRequest} currencyBalanceRequest
     * @param {string} [configAssignmentHash] Configuration assignment hash that should be used when processing this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setPlayerCurrencyBalance(
      projectId: string,
      playerId: string,
      currencyId: string,
      currencyBalanceRequest: CurrencyBalanceRequest,
      configAssignmentHash?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CurrencyBalanceResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.setPlayerCurrencyBalance(
          projectId,
          playerId,
          currencyId,
          currencyBalanceRequest,
          configAssignmentHash,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * CurrenciesApi - factory interface
 * @export
 */
export const CurrenciesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = CurrenciesApiFp(configuration);
  return {
    /**
     * Decrements a player\'s currency balance by a given value.
     * @summary Decrement currency balance
     * @param {string} projectId ID of the project.
     * @param {string} playerId ID of the player.
     * @param {string} currencyId Resource ID of the currency.
     * @param {CurrencyModifyBalanceRequest} currencyModifyBalanceRequest
     * @param {string} [configAssignmentHash] Configuration assignment hash that should be used when processing this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    decrementPlayerCurrencyBalance(
      projectId: string,
      playerId: string,
      currencyId: string,
      currencyModifyBalanceRequest: CurrencyModifyBalanceRequest,
      configAssignmentHash?: string,
      options?: any
    ): AxiosPromise<CurrencyBalanceResponse> {
      return localVarFp
        .decrementPlayerCurrencyBalance(
          projectId,
          playerId,
          currencyId,
          currencyModifyBalanceRequest,
          configAssignmentHash,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a list of currency balances for a player. Results ordered in ascending currency ID.
     * @summary Player currency balances
     * @param {string} projectId ID of the project.
     * @param {string} playerId ID of the player.
     * @param {string} [configAssignmentHash] Configuration assignment hash that should be used when processing this request.
     * @param {string} [after] The currency ID after which to retrieve the next page of balances.
     * @param {number} [limit] Number of currencies to be returned. Defaults to 20.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPlayerCurrencies(
      projectId: string,
      playerId: string,
      configAssignmentHash?: string,
      after?: string,
      limit?: number,
      options?: any
    ): AxiosPromise<PlayerCurrencyBalanceResponse> {
      return localVarFp
        .getPlayerCurrencies(
          projectId,
          playerId,
          configAssignmentHash,
          after,
          limit,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Increment a player\'s currency balance by a given value.
     * @summary Increment currency balance
     * @param {string} projectId ID of the project.
     * @param {string} playerId ID of the player.
     * @param {string} currencyId Resource ID of the currency.
     * @param {CurrencyModifyBalanceRequest} currencyModifyBalanceRequest
     * @param {string} [configAssignmentHash] Configuration assignment hash that should be used when processing this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    incrementPlayerCurrencyBalance(
      projectId: string,
      playerId: string,
      currencyId: string,
      currencyModifyBalanceRequest: CurrencyModifyBalanceRequest,
      configAssignmentHash?: string,
      options?: any
    ): AxiosPromise<CurrencyBalanceResponse> {
      return localVarFp
        .incrementPlayerCurrencyBalance(
          projectId,
          playerId,
          currencyId,
          currencyModifyBalanceRequest,
          configAssignmentHash,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Set a player\'s currency balance.
     * @summary Set currency balance
     * @param {string} projectId ID of the project.
     * @param {string} playerId ID of the player.
     * @param {string} currencyId Resource ID of the currency.
     * @param {CurrencyBalanceRequest} currencyBalanceRequest
     * @param {string} [configAssignmentHash] Configuration assignment hash that should be used when processing this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setPlayerCurrencyBalance(
      projectId: string,
      playerId: string,
      currencyId: string,
      currencyBalanceRequest: CurrencyBalanceRequest,
      configAssignmentHash?: string,
      options?: any
    ): AxiosPromise<CurrencyBalanceResponse> {
      return localVarFp
        .setPlayerCurrencyBalance(
          projectId,
          playerId,
          currencyId,
          currencyBalanceRequest,
          configAssignmentHash,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for decrementPlayerCurrencyBalance operation in CurrenciesApi.
 * @export
 * @interface CurrenciesApiDecrementPlayerCurrencyBalanceRequest
 */
export interface CurrenciesApiDecrementPlayerCurrencyBalanceRequest {
  /**
   * ID of the project.
   * @type {string}
   * @memberof CurrenciesApiDecrementPlayerCurrencyBalance
   */
  readonly projectId: string;

  /**
   * ID of the player.
   * @type {string}
   * @memberof CurrenciesApiDecrementPlayerCurrencyBalance
   */
  readonly playerId: string;

  /**
   * Resource ID of the currency.
   * @type {string}
   * @memberof CurrenciesApiDecrementPlayerCurrencyBalance
   */
  readonly currencyId: string;

  /**
   *
   * @type {CurrencyModifyBalanceRequest}
   * @memberof CurrenciesApiDecrementPlayerCurrencyBalance
   */
  readonly currencyModifyBalanceRequest: CurrencyModifyBalanceRequest;

  /**
   * Configuration assignment hash that should be used when processing this request.
   * @type {string}
   * @memberof CurrenciesApiDecrementPlayerCurrencyBalance
   */
  readonly configAssignmentHash?: string;
}

/**
 * Request parameters for getPlayerCurrencies operation in CurrenciesApi.
 * @export
 * @interface CurrenciesApiGetPlayerCurrenciesRequest
 */
export interface CurrenciesApiGetPlayerCurrenciesRequest {
  /**
   * ID of the project.
   * @type {string}
   * @memberof CurrenciesApiGetPlayerCurrencies
   */
  readonly projectId: string;

  /**
   * ID of the player.
   * @type {string}
   * @memberof CurrenciesApiGetPlayerCurrencies
   */
  readonly playerId: string;

  /**
   * Configuration assignment hash that should be used when processing this request.
   * @type {string}
   * @memberof CurrenciesApiGetPlayerCurrencies
   */
  readonly configAssignmentHash?: string;

  /**
   * The currency ID after which to retrieve the next page of balances.
   * @type {string}
   * @memberof CurrenciesApiGetPlayerCurrencies
   */
  readonly after?: string;

  /**
   * Number of currencies to be returned. Defaults to 20.
   * @type {number}
   * @memberof CurrenciesApiGetPlayerCurrencies
   */
  readonly limit?: number;
}

/**
 * Request parameters for incrementPlayerCurrencyBalance operation in CurrenciesApi.
 * @export
 * @interface CurrenciesApiIncrementPlayerCurrencyBalanceRequest
 */
export interface CurrenciesApiIncrementPlayerCurrencyBalanceRequest {
  /**
   * ID of the project.
   * @type {string}
   * @memberof CurrenciesApiIncrementPlayerCurrencyBalance
   */
  readonly projectId: string;

  /**
   * ID of the player.
   * @type {string}
   * @memberof CurrenciesApiIncrementPlayerCurrencyBalance
   */
  readonly playerId: string;

  /**
   * Resource ID of the currency.
   * @type {string}
   * @memberof CurrenciesApiIncrementPlayerCurrencyBalance
   */
  readonly currencyId: string;

  /**
   *
   * @type {CurrencyModifyBalanceRequest}
   * @memberof CurrenciesApiIncrementPlayerCurrencyBalance
   */
  readonly currencyModifyBalanceRequest: CurrencyModifyBalanceRequest;

  /**
   * Configuration assignment hash that should be used when processing this request.
   * @type {string}
   * @memberof CurrenciesApiIncrementPlayerCurrencyBalance
   */
  readonly configAssignmentHash?: string;
}

/**
 * Request parameters for setPlayerCurrencyBalance operation in CurrenciesApi.
 * @export
 * @interface CurrenciesApiSetPlayerCurrencyBalanceRequest
 */
export interface CurrenciesApiSetPlayerCurrencyBalanceRequest {
  /**
   * ID of the project.
   * @type {string}
   * @memberof CurrenciesApiSetPlayerCurrencyBalance
   */
  readonly projectId: string;

  /**
   * ID of the player.
   * @type {string}
   * @memberof CurrenciesApiSetPlayerCurrencyBalance
   */
  readonly playerId: string;

  /**
   * Resource ID of the currency.
   * @type {string}
   * @memberof CurrenciesApiSetPlayerCurrencyBalance
   */
  readonly currencyId: string;

  /**
   *
   * @type {CurrencyBalanceRequest}
   * @memberof CurrenciesApiSetPlayerCurrencyBalance
   */
  readonly currencyBalanceRequest: CurrencyBalanceRequest;

  /**
   * Configuration assignment hash that should be used when processing this request.
   * @type {string}
   * @memberof CurrenciesApiSetPlayerCurrencyBalance
   */
  readonly configAssignmentHash?: string;
}

/**
 * CurrenciesApi - object-oriented interface
 * @export
 * @class CurrenciesApi
 * @extends {BaseAPI}
 */
export class CurrenciesApi extends BaseAPI {
  /**
   * Decrements a player\'s currency balance by a given value.
   * @summary Decrement currency balance
   * @param {CurrenciesApiDecrementPlayerCurrencyBalanceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CurrenciesApi
   */
  public decrementPlayerCurrencyBalance(
    requestParameters: CurrenciesApiDecrementPlayerCurrencyBalanceRequest,
    options?: AxiosRequestConfig
  ) {
    return CurrenciesApiFp(this.configuration)
      .decrementPlayerCurrencyBalance(
        requestParameters.projectId,
        requestParameters.playerId,
        requestParameters.currencyId,
        requestParameters.currencyModifyBalanceRequest,
        requestParameters.configAssignmentHash,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of currency balances for a player. Results ordered in ascending currency ID.
   * @summary Player currency balances
   * @param {CurrenciesApiGetPlayerCurrenciesRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CurrenciesApi
   */
  public getPlayerCurrencies(
    requestParameters: CurrenciesApiGetPlayerCurrenciesRequest,
    options?: AxiosRequestConfig
  ) {
    return CurrenciesApiFp(this.configuration)
      .getPlayerCurrencies(
        requestParameters.projectId,
        requestParameters.playerId,
        requestParameters.configAssignmentHash,
        requestParameters.after,
        requestParameters.limit,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Increment a player\'s currency balance by a given value.
   * @summary Increment currency balance
   * @param {CurrenciesApiIncrementPlayerCurrencyBalanceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CurrenciesApi
   */
  public incrementPlayerCurrencyBalance(
    requestParameters: CurrenciesApiIncrementPlayerCurrencyBalanceRequest,
    options?: AxiosRequestConfig
  ) {
    return CurrenciesApiFp(this.configuration)
      .incrementPlayerCurrencyBalance(
        requestParameters.projectId,
        requestParameters.playerId,
        requestParameters.currencyId,
        requestParameters.currencyModifyBalanceRequest,
        requestParameters.configAssignmentHash,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Set a player\'s currency balance.
   * @summary Set currency balance
   * @param {CurrenciesApiSetPlayerCurrencyBalanceRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CurrenciesApi
   */
  public setPlayerCurrencyBalance(
    requestParameters: CurrenciesApiSetPlayerCurrencyBalanceRequest,
    options?: AxiosRequestConfig
  ) {
    return CurrenciesApiFp(this.configuration)
      .setPlayerCurrencyBalance(
        requestParameters.projectId,
        requestParameters.playerId,
        requestParameters.currencyId,
        requestParameters.currencyBalanceRequest,
        requestParameters.configAssignmentHash,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * InventoryApi - axios parameter creator
 * @export
 */
export const InventoryApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Add an item to a player\'s inventory.
     * @summary Add inventory item
     * @param {string} projectId ID of the project.
     * @param {string} playerId ID of the player.
     * @param {AddInventoryRequest} addInventoryRequest
     * @param {string} [configAssignmentHash] Configuration assignment hash that should be used when processing this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addInventoryItem: async (
      projectId: string,
      playerId: string,
      addInventoryRequest: AddInventoryRequest,
      configAssignmentHash?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("addInventoryItem", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("addInventoryItem", "playerId", playerId);
      // verify required parameter 'addInventoryRequest' is not null or undefined
      assertParamExists(
        "addInventoryItem",
        "addInventoryRequest",
        addInventoryRequest
      );
      const localVarPath =
        `/v2/projects/{projectId}/players/{playerId}/inventory`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication JWT required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (configAssignmentHash !== undefined) {
        localVarQueryParameter["configAssignmentHash"] = configAssignmentHash;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        addInventoryRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a player\'s inventory item.
     * @summary Delete player\'s inventory item
     * @param {string} projectId ID of the project.
     * @param {string} playerId ID of the player.
     * @param {string} playersInventoryItemId The &#x60;playersInventoryItemId&#x60; of the item to be updated.
     * @param {InventoryDeleteRequest} inventoryDeleteRequest
     * @param {string} [configAssignmentHash] Configuration assignment hash that should be used when processing this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteInventoryItem: async (
      projectId: string,
      playerId: string,
      playersInventoryItemId: string,
      inventoryDeleteRequest: InventoryDeleteRequest,
      configAssignmentHash?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("deleteInventoryItem", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("deleteInventoryItem", "playerId", playerId);
      // verify required parameter 'playersInventoryItemId' is not null or undefined
      assertParamExists(
        "deleteInventoryItem",
        "playersInventoryItemId",
        playersInventoryItemId
      );
      // verify required parameter 'inventoryDeleteRequest' is not null or undefined
      assertParamExists(
        "deleteInventoryItem",
        "inventoryDeleteRequest",
        inventoryDeleteRequest
      );
      const localVarPath =
        `/v2/projects/{projectId}/players/{playerId}/inventory/{playersInventoryItemId}`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)))
          .replace(
            `{${"playersInventoryItemId"}}`,
            encodeURIComponent(String(playersInventoryItemId))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication JWT required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (configAssignmentHash !== undefined) {
        localVarQueryParameter["configAssignmentHash"] = configAssignmentHash;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inventoryDeleteRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of inventory for a player. Results ordered by ascending `playersInventoryItemId`. `playersIventoryItemIds` and `inventoryItemIds` filters are optional, if not given all items will be returned. If both are given an item must match both to be returned.
     * @summary List player inventory
     * @param {string} projectId ID of the project.
     * @param {string} playerId ID of the player.
     * @param {string} [configAssignmentHash] Configuration assignment hash that should be used when processing this request.
     * @param {string} [after] The &#x60;playersInventoryItemId&#x60; after which to retrieve the next page of balances.
     * @param {number} [limit] Number of items to be returned. Defaults to 20.
     * @param {Array<string>} [playersInventoryItemIds] List of &#x60;playersInventoryItemIds&#x60; in array notation, for example, &#x60;playersInventoryItemIds[]&#x3D;ID1&amp;playersInventoryItemIds[]&#x3D;ID2&#x60;.
     * @param {Array<string>} [inventoryItemIds] List of inventory item IDs in array notation, for example, &#x60;inventoryItemIds[]&#x3D;ID1&amp;inventoryItemIds[]&#x3D;ID2&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPlayerInventory: async (
      projectId: string,
      playerId: string,
      configAssignmentHash?: string,
      after?: string,
      limit?: number,
      playersInventoryItemIds?: Array<string>,
      inventoryItemIds?: Array<string>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("getPlayerInventory", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("getPlayerInventory", "playerId", playerId);
      const localVarPath =
        `/v2/projects/{projectId}/players/{playerId}/inventory`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication JWT required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (configAssignmentHash !== undefined) {
        localVarQueryParameter["configAssignmentHash"] = configAssignmentHash;
      }

      if (after !== undefined) {
        localVarQueryParameter["after"] = after;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (playersInventoryItemIds) {
        localVarQueryParameter["playersInventoryItemIds"] =
          playersInventoryItemIds;
      }

      if (inventoryItemIds) {
        localVarQueryParameter["inventoryItemIds"] = inventoryItemIds;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update a player\'s inventory item.
     * @summary Update player\'s inventory item
     * @param {string} projectId ID of the project.
     * @param {string} playerId ID of the player.
     * @param {string} playersInventoryItemId The &#x60;playersInventoryItemId&#x60; of the item to be updated.
     * @param {InventoryRequestUpdate} inventoryRequestUpdate
     * @param {string} [configAssignmentHash] Configuration assignment hash that should be used when processing this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateInventoryItem: async (
      projectId: string,
      playerId: string,
      playersInventoryItemId: string,
      inventoryRequestUpdate: InventoryRequestUpdate,
      configAssignmentHash?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("updateInventoryItem", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("updateInventoryItem", "playerId", playerId);
      // verify required parameter 'playersInventoryItemId' is not null or undefined
      assertParamExists(
        "updateInventoryItem",
        "playersInventoryItemId",
        playersInventoryItemId
      );
      // verify required parameter 'inventoryRequestUpdate' is not null or undefined
      assertParamExists(
        "updateInventoryItem",
        "inventoryRequestUpdate",
        inventoryRequestUpdate
      );
      const localVarPath =
        `/v2/projects/{projectId}/players/{playerId}/inventory/{playersInventoryItemId}`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)))
          .replace(
            `{${"playersInventoryItemId"}}`,
            encodeURIComponent(String(playersInventoryItemId))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication JWT required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (configAssignmentHash !== undefined) {
        localVarQueryParameter["configAssignmentHash"] = configAssignmentHash;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inventoryRequestUpdate,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * InventoryApi - functional programming interface
 * @export
 */
export const InventoryApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    InventoryApiAxiosParamCreator(configuration);
  return {
    /**
     * Add an item to a player\'s inventory.
     * @summary Add inventory item
     * @param {string} projectId ID of the project.
     * @param {string} playerId ID of the player.
     * @param {AddInventoryRequest} addInventoryRequest
     * @param {string} [configAssignmentHash] Configuration assignment hash that should be used when processing this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addInventoryItem(
      projectId: string,
      playerId: string,
      addInventoryRequest: AddInventoryRequest,
      configAssignmentHash?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InventoryResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.addInventoryItem(
          projectId,
          playerId,
          addInventoryRequest,
          configAssignmentHash,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Delete a player\'s inventory item.
     * @summary Delete player\'s inventory item
     * @param {string} projectId ID of the project.
     * @param {string} playerId ID of the player.
     * @param {string} playersInventoryItemId The &#x60;playersInventoryItemId&#x60; of the item to be updated.
     * @param {InventoryDeleteRequest} inventoryDeleteRequest
     * @param {string} [configAssignmentHash] Configuration assignment hash that should be used when processing this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteInventoryItem(
      projectId: string,
      playerId: string,
      playersInventoryItemId: string,
      inventoryDeleteRequest: InventoryDeleteRequest,
      configAssignmentHash?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteInventoryItem(
          projectId,
          playerId,
          playersInventoryItemId,
          inventoryDeleteRequest,
          configAssignmentHash,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a list of inventory for a player. Results ordered by ascending `playersInventoryItemId`. `playersIventoryItemIds` and `inventoryItemIds` filters are optional, if not given all items will be returned. If both are given an item must match both to be returned.
     * @summary List player inventory
     * @param {string} projectId ID of the project.
     * @param {string} playerId ID of the player.
     * @param {string} [configAssignmentHash] Configuration assignment hash that should be used when processing this request.
     * @param {string} [after] The &#x60;playersInventoryItemId&#x60; after which to retrieve the next page of balances.
     * @param {number} [limit] Number of items to be returned. Defaults to 20.
     * @param {Array<string>} [playersInventoryItemIds] List of &#x60;playersInventoryItemIds&#x60; in array notation, for example, &#x60;playersInventoryItemIds[]&#x3D;ID1&amp;playersInventoryItemIds[]&#x3D;ID2&#x60;.
     * @param {Array<string>} [inventoryItemIds] List of inventory item IDs in array notation, for example, &#x60;inventoryItemIds[]&#x3D;ID1&amp;inventoryItemIds[]&#x3D;ID2&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPlayerInventory(
      projectId: string,
      playerId: string,
      configAssignmentHash?: string,
      after?: string,
      limit?: number,
      playersInventoryItemIds?: Array<string>,
      inventoryItemIds?: Array<string>,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PlayerInventoryResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPlayerInventory(
          projectId,
          playerId,
          configAssignmentHash,
          after,
          limit,
          playersInventoryItemIds,
          inventoryItemIds,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Update a player\'s inventory item.
     * @summary Update player\'s inventory item
     * @param {string} projectId ID of the project.
     * @param {string} playerId ID of the player.
     * @param {string} playersInventoryItemId The &#x60;playersInventoryItemId&#x60; of the item to be updated.
     * @param {InventoryRequestUpdate} inventoryRequestUpdate
     * @param {string} [configAssignmentHash] Configuration assignment hash that should be used when processing this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateInventoryItem(
      projectId: string,
      playerId: string,
      playersInventoryItemId: string,
      inventoryRequestUpdate: InventoryRequestUpdate,
      configAssignmentHash?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InventoryResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateInventoryItem(
          projectId,
          playerId,
          playersInventoryItemId,
          inventoryRequestUpdate,
          configAssignmentHash,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * InventoryApi - factory interface
 * @export
 */
export const InventoryApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = InventoryApiFp(configuration);
  return {
    /**
     * Add an item to a player\'s inventory.
     * @summary Add inventory item
     * @param {string} projectId ID of the project.
     * @param {string} playerId ID of the player.
     * @param {AddInventoryRequest} addInventoryRequest
     * @param {string} [configAssignmentHash] Configuration assignment hash that should be used when processing this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addInventoryItem(
      projectId: string,
      playerId: string,
      addInventoryRequest: AddInventoryRequest,
      configAssignmentHash?: string,
      options?: any
    ): AxiosPromise<InventoryResponse> {
      return localVarFp
        .addInventoryItem(
          projectId,
          playerId,
          addInventoryRequest,
          configAssignmentHash,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete a player\'s inventory item.
     * @summary Delete player\'s inventory item
     * @param {string} projectId ID of the project.
     * @param {string} playerId ID of the player.
     * @param {string} playersInventoryItemId The &#x60;playersInventoryItemId&#x60; of the item to be updated.
     * @param {InventoryDeleteRequest} inventoryDeleteRequest
     * @param {string} [configAssignmentHash] Configuration assignment hash that should be used when processing this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteInventoryItem(
      projectId: string,
      playerId: string,
      playersInventoryItemId: string,
      inventoryDeleteRequest: InventoryDeleteRequest,
      configAssignmentHash?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteInventoryItem(
          projectId,
          playerId,
          playersInventoryItemId,
          inventoryDeleteRequest,
          configAssignmentHash,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a list of inventory for a player. Results ordered by ascending `playersInventoryItemId`. `playersIventoryItemIds` and `inventoryItemIds` filters are optional, if not given all items will be returned. If both are given an item must match both to be returned.
     * @summary List player inventory
     * @param {string} projectId ID of the project.
     * @param {string} playerId ID of the player.
     * @param {string} [configAssignmentHash] Configuration assignment hash that should be used when processing this request.
     * @param {string} [after] The &#x60;playersInventoryItemId&#x60; after which to retrieve the next page of balances.
     * @param {number} [limit] Number of items to be returned. Defaults to 20.
     * @param {Array<string>} [playersInventoryItemIds] List of &#x60;playersInventoryItemIds&#x60; in array notation, for example, &#x60;playersInventoryItemIds[]&#x3D;ID1&amp;playersInventoryItemIds[]&#x3D;ID2&#x60;.
     * @param {Array<string>} [inventoryItemIds] List of inventory item IDs in array notation, for example, &#x60;inventoryItemIds[]&#x3D;ID1&amp;inventoryItemIds[]&#x3D;ID2&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPlayerInventory(
      projectId: string,
      playerId: string,
      configAssignmentHash?: string,
      after?: string,
      limit?: number,
      playersInventoryItemIds?: Array<string>,
      inventoryItemIds?: Array<string>,
      options?: any
    ): AxiosPromise<PlayerInventoryResponse> {
      return localVarFp
        .getPlayerInventory(
          projectId,
          playerId,
          configAssignmentHash,
          after,
          limit,
          playersInventoryItemIds,
          inventoryItemIds,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Update a player\'s inventory item.
     * @summary Update player\'s inventory item
     * @param {string} projectId ID of the project.
     * @param {string} playerId ID of the player.
     * @param {string} playersInventoryItemId The &#x60;playersInventoryItemId&#x60; of the item to be updated.
     * @param {InventoryRequestUpdate} inventoryRequestUpdate
     * @param {string} [configAssignmentHash] Configuration assignment hash that should be used when processing this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateInventoryItem(
      projectId: string,
      playerId: string,
      playersInventoryItemId: string,
      inventoryRequestUpdate: InventoryRequestUpdate,
      configAssignmentHash?: string,
      options?: any
    ): AxiosPromise<InventoryResponse> {
      return localVarFp
        .updateInventoryItem(
          projectId,
          playerId,
          playersInventoryItemId,
          inventoryRequestUpdate,
          configAssignmentHash,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for addInventoryItem operation in InventoryApi.
 * @export
 * @interface InventoryApiAddInventoryItemRequest
 */
export interface InventoryApiAddInventoryItemRequest {
  /**
   * ID of the project.
   * @type {string}
   * @memberof InventoryApiAddInventoryItem
   */
  readonly projectId: string;

  /**
   * ID of the player.
   * @type {string}
   * @memberof InventoryApiAddInventoryItem
   */
  readonly playerId: string;

  /**
   *
   * @type {AddInventoryRequest}
   * @memberof InventoryApiAddInventoryItem
   */
  readonly addInventoryRequest: AddInventoryRequest;

  /**
   * Configuration assignment hash that should be used when processing this request.
   * @type {string}
   * @memberof InventoryApiAddInventoryItem
   */
  readonly configAssignmentHash?: string;
}

/**
 * Request parameters for deleteInventoryItem operation in InventoryApi.
 * @export
 * @interface InventoryApiDeleteInventoryItemRequest
 */
export interface InventoryApiDeleteInventoryItemRequest {
  /**
   * ID of the project.
   * @type {string}
   * @memberof InventoryApiDeleteInventoryItem
   */
  readonly projectId: string;

  /**
   * ID of the player.
   * @type {string}
   * @memberof InventoryApiDeleteInventoryItem
   */
  readonly playerId: string;

  /**
   * The &#x60;playersInventoryItemId&#x60; of the item to be updated.
   * @type {string}
   * @memberof InventoryApiDeleteInventoryItem
   */
  readonly playersInventoryItemId: string;

  /**
   *
   * @type {InventoryDeleteRequest}
   * @memberof InventoryApiDeleteInventoryItem
   */
  readonly inventoryDeleteRequest: InventoryDeleteRequest;

  /**
   * Configuration assignment hash that should be used when processing this request.
   * @type {string}
   * @memberof InventoryApiDeleteInventoryItem
   */
  readonly configAssignmentHash?: string;
}

/**
 * Request parameters for getPlayerInventory operation in InventoryApi.
 * @export
 * @interface InventoryApiGetPlayerInventoryRequest
 */
export interface InventoryApiGetPlayerInventoryRequest {
  /**
   * ID of the project.
   * @type {string}
   * @memberof InventoryApiGetPlayerInventory
   */
  readonly projectId: string;

  /**
   * ID of the player.
   * @type {string}
   * @memberof InventoryApiGetPlayerInventory
   */
  readonly playerId: string;

  /**
   * Configuration assignment hash that should be used when processing this request.
   * @type {string}
   * @memberof InventoryApiGetPlayerInventory
   */
  readonly configAssignmentHash?: string;

  /**
   * The &#x60;playersInventoryItemId&#x60; after which to retrieve the next page of balances.
   * @type {string}
   * @memberof InventoryApiGetPlayerInventory
   */
  readonly after?: string;

  /**
   * Number of items to be returned. Defaults to 20.
   * @type {number}
   * @memberof InventoryApiGetPlayerInventory
   */
  readonly limit?: number;

  /**
   * List of &#x60;playersInventoryItemIds&#x60; in array notation, for example, &#x60;playersInventoryItemIds[]&#x3D;ID1&amp;playersInventoryItemIds[]&#x3D;ID2&#x60;.
   * @type {Array<string>}
   * @memberof InventoryApiGetPlayerInventory
   */
  readonly playersInventoryItemIds?: Array<string>;

  /**
   * List of inventory item IDs in array notation, for example, &#x60;inventoryItemIds[]&#x3D;ID1&amp;inventoryItemIds[]&#x3D;ID2&#x60;.
   * @type {Array<string>}
   * @memberof InventoryApiGetPlayerInventory
   */
  readonly inventoryItemIds?: Array<string>;
}

/**
 * Request parameters for updateInventoryItem operation in InventoryApi.
 * @export
 * @interface InventoryApiUpdateInventoryItemRequest
 */
export interface InventoryApiUpdateInventoryItemRequest {
  /**
   * ID of the project.
   * @type {string}
   * @memberof InventoryApiUpdateInventoryItem
   */
  readonly projectId: string;

  /**
   * ID of the player.
   * @type {string}
   * @memberof InventoryApiUpdateInventoryItem
   */
  readonly playerId: string;

  /**
   * The &#x60;playersInventoryItemId&#x60; of the item to be updated.
   * @type {string}
   * @memberof InventoryApiUpdateInventoryItem
   */
  readonly playersInventoryItemId: string;

  /**
   *
   * @type {InventoryRequestUpdate}
   * @memberof InventoryApiUpdateInventoryItem
   */
  readonly inventoryRequestUpdate: InventoryRequestUpdate;

  /**
   * Configuration assignment hash that should be used when processing this request.
   * @type {string}
   * @memberof InventoryApiUpdateInventoryItem
   */
  readonly configAssignmentHash?: string;
}

/**
 * InventoryApi - object-oriented interface
 * @export
 * @class InventoryApi
 * @extends {BaseAPI}
 */
export class InventoryApi extends BaseAPI {
  /**
   * Add an item to a player\'s inventory.
   * @summary Add inventory item
   * @param {InventoryApiAddInventoryItemRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InventoryApi
   */
  public addInventoryItem(
    requestParameters: InventoryApiAddInventoryItemRequest,
    options?: AxiosRequestConfig
  ) {
    return InventoryApiFp(this.configuration)
      .addInventoryItem(
        requestParameters.projectId,
        requestParameters.playerId,
        requestParameters.addInventoryRequest,
        requestParameters.configAssignmentHash,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete a player\'s inventory item.
   * @summary Delete player\'s inventory item
   * @param {InventoryApiDeleteInventoryItemRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InventoryApi
   */
  public deleteInventoryItem(
    requestParameters: InventoryApiDeleteInventoryItemRequest,
    options?: AxiosRequestConfig
  ) {
    return InventoryApiFp(this.configuration)
      .deleteInventoryItem(
        requestParameters.projectId,
        requestParameters.playerId,
        requestParameters.playersInventoryItemId,
        requestParameters.inventoryDeleteRequest,
        requestParameters.configAssignmentHash,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of inventory for a player. Results ordered by ascending `playersInventoryItemId`. `playersIventoryItemIds` and `inventoryItemIds` filters are optional, if not given all items will be returned. If both are given an item must match both to be returned.
   * @summary List player inventory
   * @param {InventoryApiGetPlayerInventoryRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InventoryApi
   */
  public getPlayerInventory(
    requestParameters: InventoryApiGetPlayerInventoryRequest,
    options?: AxiosRequestConfig
  ) {
    return InventoryApiFp(this.configuration)
      .getPlayerInventory(
        requestParameters.projectId,
        requestParameters.playerId,
        requestParameters.configAssignmentHash,
        requestParameters.after,
        requestParameters.limit,
        requestParameters.playersInventoryItemIds,
        requestParameters.inventoryItemIds,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update a player\'s inventory item.
   * @summary Update player\'s inventory item
   * @param {InventoryApiUpdateInventoryItemRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InventoryApi
   */
  public updateInventoryItem(
    requestParameters: InventoryApiUpdateInventoryItemRequest,
    options?: AxiosRequestConfig
  ) {
    return InventoryApiFp(this.configuration)
      .updateInventoryItem(
        requestParameters.projectId,
        requestParameters.playerId,
        requestParameters.playersInventoryItemId,
        requestParameters.inventoryRequestUpdate,
        requestParameters.configAssignmentHash,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PurchasesApi - axios parameter creator
 * @export
 */
export const PurchasesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Make a virtual purchase for a player.
     * @summary Make virtual purchase
     * @param {string} projectId ID of the project.
     * @param {string} playerId ID of the player.
     * @param {PlayerPurchaseVirtualRequest} playerPurchaseVirtualRequest
     * @param {string} [configAssignmentHash] Configuration assignment hash that should be used when processing this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    makeVirtualPurchase: async (
      projectId: string,
      playerId: string,
      playerPurchaseVirtualRequest: PlayerPurchaseVirtualRequest,
      configAssignmentHash?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("makeVirtualPurchase", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("makeVirtualPurchase", "playerId", playerId);
      // verify required parameter 'playerPurchaseVirtualRequest' is not null or undefined
      assertParamExists(
        "makeVirtualPurchase",
        "playerPurchaseVirtualRequest",
        playerPurchaseVirtualRequest
      );
      const localVarPath =
        `/v2/projects/{projectId}/players/{playerId}/purchases/virtual`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication JWT required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (configAssignmentHash !== undefined) {
        localVarQueryParameter["configAssignmentHash"] = configAssignmentHash;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        playerPurchaseVirtualRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Redeem an Apple App Store purchase for a player.
     * @summary Redeem Apple App Store purchase
     * @param {string} projectId ID of the project.
     * @param {string} playerId ID of the player.
     * @param {PlayerPurchaseAppleappstoreRequest} playerPurchaseAppleappstoreRequest
     * @param {string} [configAssignmentHash] Configuration assignment hash that should be used when processing this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    redeemAppleAppStorePurchase: async (
      projectId: string,
      playerId: string,
      playerPurchaseAppleappstoreRequest: PlayerPurchaseAppleappstoreRequest,
      configAssignmentHash?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("redeemAppleAppStorePurchase", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("redeemAppleAppStorePurchase", "playerId", playerId);
      // verify required parameter 'playerPurchaseAppleappstoreRequest' is not null or undefined
      assertParamExists(
        "redeemAppleAppStorePurchase",
        "playerPurchaseAppleappstoreRequest",
        playerPurchaseAppleappstoreRequest
      );
      const localVarPath =
        `/v2/projects/{projectId}/players/{playerId}/purchases/appleappstore`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication JWT required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (configAssignmentHash !== undefined) {
        localVarQueryParameter["configAssignmentHash"] = configAssignmentHash;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        playerPurchaseAppleappstoreRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Redeem a Google Play store purchase for a player.
     * @summary Redeem Google Play purchase
     * @param {string} projectId ID of the project.
     * @param {string} playerId ID of the player.
     * @param {PlayerPurchaseGoogleplaystoreRequest} playerPurchaseGoogleplaystoreRequest
     * @param {string} [configAssignmentHash] Configuration assignment hash that should be used when processing this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    redeemGooglePlayPurchase: async (
      projectId: string,
      playerId: string,
      playerPurchaseGoogleplaystoreRequest: PlayerPurchaseGoogleplaystoreRequest,
      configAssignmentHash?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("redeemGooglePlayPurchase", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("redeemGooglePlayPurchase", "playerId", playerId);
      // verify required parameter 'playerPurchaseGoogleplaystoreRequest' is not null or undefined
      assertParamExists(
        "redeemGooglePlayPurchase",
        "playerPurchaseGoogleplaystoreRequest",
        playerPurchaseGoogleplaystoreRequest
      );
      const localVarPath =
        `/v2/projects/{projectId}/players/{playerId}/purchases/googleplaystore`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication JWT required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (configAssignmentHash !== undefined) {
        localVarQueryParameter["configAssignmentHash"] = configAssignmentHash;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        playerPurchaseGoogleplaystoreRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PurchasesApi - functional programming interface
 * @export
 */
export const PurchasesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    PurchasesApiAxiosParamCreator(configuration);
  return {
    /**
     * Make a virtual purchase for a player.
     * @summary Make virtual purchase
     * @param {string} projectId ID of the project.
     * @param {string} playerId ID of the player.
     * @param {PlayerPurchaseVirtualRequest} playerPurchaseVirtualRequest
     * @param {string} [configAssignmentHash] Configuration assignment hash that should be used when processing this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async makeVirtualPurchase(
      projectId: string,
      playerId: string,
      playerPurchaseVirtualRequest: PlayerPurchaseVirtualRequest,
      configAssignmentHash?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PlayerPurchaseVirtualResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.makeVirtualPurchase(
          projectId,
          playerId,
          playerPurchaseVirtualRequest,
          configAssignmentHash,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Redeem an Apple App Store purchase for a player.
     * @summary Redeem Apple App Store purchase
     * @param {string} projectId ID of the project.
     * @param {string} playerId ID of the player.
     * @param {PlayerPurchaseAppleappstoreRequest} playerPurchaseAppleappstoreRequest
     * @param {string} [configAssignmentHash] Configuration assignment hash that should be used when processing this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async redeemAppleAppStorePurchase(
      projectId: string,
      playerId: string,
      playerPurchaseAppleappstoreRequest: PlayerPurchaseAppleappstoreRequest,
      configAssignmentHash?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PlayerPurchaseAppleappstoreResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.redeemAppleAppStorePurchase(
          projectId,
          playerId,
          playerPurchaseAppleappstoreRequest,
          configAssignmentHash,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Redeem a Google Play store purchase for a player.
     * @summary Redeem Google Play purchase
     * @param {string} projectId ID of the project.
     * @param {string} playerId ID of the player.
     * @param {PlayerPurchaseGoogleplaystoreRequest} playerPurchaseGoogleplaystoreRequest
     * @param {string} [configAssignmentHash] Configuration assignment hash that should be used when processing this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async redeemGooglePlayPurchase(
      projectId: string,
      playerId: string,
      playerPurchaseGoogleplaystoreRequest: PlayerPurchaseGoogleplaystoreRequest,
      configAssignmentHash?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PlayerPurchaseGoogleplaystoreResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.redeemGooglePlayPurchase(
          projectId,
          playerId,
          playerPurchaseGoogleplaystoreRequest,
          configAssignmentHash,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * PurchasesApi - factory interface
 * @export
 */
export const PurchasesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PurchasesApiFp(configuration);
  return {
    /**
     * Make a virtual purchase for a player.
     * @summary Make virtual purchase
     * @param {string} projectId ID of the project.
     * @param {string} playerId ID of the player.
     * @param {PlayerPurchaseVirtualRequest} playerPurchaseVirtualRequest
     * @param {string} [configAssignmentHash] Configuration assignment hash that should be used when processing this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    makeVirtualPurchase(
      projectId: string,
      playerId: string,
      playerPurchaseVirtualRequest: PlayerPurchaseVirtualRequest,
      configAssignmentHash?: string,
      options?: any
    ): AxiosPromise<PlayerPurchaseVirtualResponse> {
      return localVarFp
        .makeVirtualPurchase(
          projectId,
          playerId,
          playerPurchaseVirtualRequest,
          configAssignmentHash,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Redeem an Apple App Store purchase for a player.
     * @summary Redeem Apple App Store purchase
     * @param {string} projectId ID of the project.
     * @param {string} playerId ID of the player.
     * @param {PlayerPurchaseAppleappstoreRequest} playerPurchaseAppleappstoreRequest
     * @param {string} [configAssignmentHash] Configuration assignment hash that should be used when processing this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    redeemAppleAppStorePurchase(
      projectId: string,
      playerId: string,
      playerPurchaseAppleappstoreRequest: PlayerPurchaseAppleappstoreRequest,
      configAssignmentHash?: string,
      options?: any
    ): AxiosPromise<PlayerPurchaseAppleappstoreResponse> {
      return localVarFp
        .redeemAppleAppStorePurchase(
          projectId,
          playerId,
          playerPurchaseAppleappstoreRequest,
          configAssignmentHash,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Redeem a Google Play store purchase for a player.
     * @summary Redeem Google Play purchase
     * @param {string} projectId ID of the project.
     * @param {string} playerId ID of the player.
     * @param {PlayerPurchaseGoogleplaystoreRequest} playerPurchaseGoogleplaystoreRequest
     * @param {string} [configAssignmentHash] Configuration assignment hash that should be used when processing this request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    redeemGooglePlayPurchase(
      projectId: string,
      playerId: string,
      playerPurchaseGoogleplaystoreRequest: PlayerPurchaseGoogleplaystoreRequest,
      configAssignmentHash?: string,
      options?: any
    ): AxiosPromise<PlayerPurchaseGoogleplaystoreResponse> {
      return localVarFp
        .redeemGooglePlayPurchase(
          projectId,
          playerId,
          playerPurchaseGoogleplaystoreRequest,
          configAssignmentHash,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * Request parameters for makeVirtualPurchase operation in PurchasesApi.
 * @export
 * @interface PurchasesApiMakeVirtualPurchaseRequest
 */
export interface PurchasesApiMakeVirtualPurchaseRequest {
  /**
   * ID of the project.
   * @type {string}
   * @memberof PurchasesApiMakeVirtualPurchase
   */
  readonly projectId: string;

  /**
   * ID of the player.
   * @type {string}
   * @memberof PurchasesApiMakeVirtualPurchase
   */
  readonly playerId: string;

  /**
   *
   * @type {PlayerPurchaseVirtualRequest}
   * @memberof PurchasesApiMakeVirtualPurchase
   */
  readonly playerPurchaseVirtualRequest: PlayerPurchaseVirtualRequest;

  /**
   * Configuration assignment hash that should be used when processing this request.
   * @type {string}
   * @memberof PurchasesApiMakeVirtualPurchase
   */
  readonly configAssignmentHash?: string;
}

/**
 * Request parameters for redeemAppleAppStorePurchase operation in PurchasesApi.
 * @export
 * @interface PurchasesApiRedeemAppleAppStorePurchaseRequest
 */
export interface PurchasesApiRedeemAppleAppStorePurchaseRequest {
  /**
   * ID of the project.
   * @type {string}
   * @memberof PurchasesApiRedeemAppleAppStorePurchase
   */
  readonly projectId: string;

  /**
   * ID of the player.
   * @type {string}
   * @memberof PurchasesApiRedeemAppleAppStorePurchase
   */
  readonly playerId: string;

  /**
   *
   * @type {PlayerPurchaseAppleappstoreRequest}
   * @memberof PurchasesApiRedeemAppleAppStorePurchase
   */
  readonly playerPurchaseAppleappstoreRequest: PlayerPurchaseAppleappstoreRequest;

  /**
   * Configuration assignment hash that should be used when processing this request.
   * @type {string}
   * @memberof PurchasesApiRedeemAppleAppStorePurchase
   */
  readonly configAssignmentHash?: string;
}

/**
 * Request parameters for redeemGooglePlayPurchase operation in PurchasesApi.
 * @export
 * @interface PurchasesApiRedeemGooglePlayPurchaseRequest
 */
export interface PurchasesApiRedeemGooglePlayPurchaseRequest {
  /**
   * ID of the project.
   * @type {string}
   * @memberof PurchasesApiRedeemGooglePlayPurchase
   */
  readonly projectId: string;

  /**
   * ID of the player.
   * @type {string}
   * @memberof PurchasesApiRedeemGooglePlayPurchase
   */
  readonly playerId: string;

  /**
   *
   * @type {PlayerPurchaseGoogleplaystoreRequest}
   * @memberof PurchasesApiRedeemGooglePlayPurchase
   */
  readonly playerPurchaseGoogleplaystoreRequest: PlayerPurchaseGoogleplaystoreRequest;

  /**
   * Configuration assignment hash that should be used when processing this request.
   * @type {string}
   * @memberof PurchasesApiRedeemGooglePlayPurchase
   */
  readonly configAssignmentHash?: string;
}

/**
 * PurchasesApi - object-oriented interface
 * @export
 * @class PurchasesApi
 * @extends {BaseAPI}
 */
export class PurchasesApi extends BaseAPI {
  /**
   * Make a virtual purchase for a player.
   * @summary Make virtual purchase
   * @param {PurchasesApiMakeVirtualPurchaseRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PurchasesApi
   */
  public makeVirtualPurchase(
    requestParameters: PurchasesApiMakeVirtualPurchaseRequest,
    options?: AxiosRequestConfig
  ) {
    return PurchasesApiFp(this.configuration)
      .makeVirtualPurchase(
        requestParameters.projectId,
        requestParameters.playerId,
        requestParameters.playerPurchaseVirtualRequest,
        requestParameters.configAssignmentHash,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Redeem an Apple App Store purchase for a player.
   * @summary Redeem Apple App Store purchase
   * @param {PurchasesApiRedeemAppleAppStorePurchaseRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PurchasesApi
   */
  public redeemAppleAppStorePurchase(
    requestParameters: PurchasesApiRedeemAppleAppStorePurchaseRequest,
    options?: AxiosRequestConfig
  ) {
    return PurchasesApiFp(this.configuration)
      .redeemAppleAppStorePurchase(
        requestParameters.projectId,
        requestParameters.playerId,
        requestParameters.playerPurchaseAppleappstoreRequest,
        requestParameters.configAssignmentHash,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Redeem a Google Play store purchase for a player.
   * @summary Redeem Google Play purchase
   * @param {PurchasesApiRedeemGooglePlayPurchaseRequest} requestParameters Request parameters.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PurchasesApi
   */
  public redeemGooglePlayPurchase(
    requestParameters: PurchasesApiRedeemGooglePlayPurchaseRequest,
    options?: AxiosRequestConfig
  ) {
    return PurchasesApiFp(this.configuration)
      .redeemGooglePlayPurchase(
        requestParameters.projectId,
        requestParameters.playerId,
        requestParameters.playerPurchaseGoogleplaystoreRequest,
        requestParameters.configAssignmentHash,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}
