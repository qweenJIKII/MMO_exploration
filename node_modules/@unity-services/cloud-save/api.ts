/* tslint:disable */
/* eslint-disable */
/**
 * Cloud Save API
 * # Introduction This is the API specification for the Unity Cloud Save service that allows player state to be persisted from a game client.  To use this API, you must first enable it through Unity Dashboard.  ### Notes about the Alpha version This API is currently in its alpha phase and is only available to invited users.  During the Alpha period, the information in this document is not guaranteed to be up-to-date and may change without notice.  # General Information  ## Concepts There are two concepts for saving state in the Cloud Save service, \'Data\' and \'Files\'. Both types of state are stored against a specific player.  ### Data \'Data\' are small JSON serializable data, up to 1KB in size, stored as key/value pairs.  Limits: - Max 1KB in size - Max 200 items per player  ### Files \'Files\' are larger blobs of arbitrary data, up to 100MB.  Limits: - Max 100MB in size - Max 20 files per player  ## Rate Limits  The API has rate limiting in place. Request are limited on a per-player basis up to 900 requests per minute which would allow for a sustained 15 requests per second.  The API responds with a `429` HTTP status code if the rate limit is exceeded. It will also respond with a `Retry-After` header to be used in conjunction with a client\'s retry logic. The value is the number of seconds until a request for the given player will be accepted.
 *
 * The version of the OpenAPI document: 1.0-alpha
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration";
import globalAxios, { AxiosPromise, AxiosInstance } from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from "./base";

/**
 * Response type for an attempted Data Item sent to the Cloud Save service.
 * @export
 * @interface AttemptedItem
 */
export interface AttemptedItem {
  /**
   * Item key
   * @type {string}
   * @memberof AttemptedItem
   */
  key: string;
  /**
   * Any JSON serializable structure
   * @type {object}
   * @memberof AttemptedItem
   */
  value: object;
  /**
   * Enforces conflict checking when updating an existing data item. This field should be omitted when creating a new data item. When updating an existing item, omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
   * @type {string}
   * @memberof AttemptedItem
   */
  writeLock: string;
}
/**
 * Referenced from - https://tools.ietf.org/html/rfc7807#page-3  Consumers MUST use the \'type\' string as the primary identifier for the problem type; the \'title\' string is advisory and included only for users who are not aware of the semantics of the URI and do not have the ability to discover them (e.g., offline log analysis). Consumers SHOULD NOT automatically dereference the type URI.  The \"status\" member, if present, is only advisory; it conveys the HTTP status code used for the convenience of the consumer. Generators MUST use the same status code in the actual HTTP response, to assure that generic HTTP software that does not understand this format still behaves correctly.  See Section 5 for further caveats regarding its use. Consumers can use the status member to determine what the original status code used by the generator was, in cases where it has been changed (e.g., by an intermediary or cache), and when message bodies persist without HTTP information.  Generic HTTP software will still use the HTTP status code.  The \"detail\" member, if present, ought to focus on helping the client correct the problem, rather than giving debugging information.
 * @export
 * @interface BasicErrorResponse
 */
export interface BasicErrorResponse {
  /**
   * A URI reference [RFC3986] that identifies the problem type. This specification encourages that, when dereferenced, it provide human-readable documentation for the problem type (e.g., using HTML [W3C.REC-html5-20141028]). When this member is not present, its value is assumed to be \"about:blank\".
   * @type {string}
   * @memberof BasicErrorResponse
   */
  type: string;
  /**
   * A short, human-readable summary of the problem type. It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization (e.g., using proactive content negotiation; see [RFC7231], Section 3.4).
   * @type {string}
   * @memberof BasicErrorResponse
   */
  title?: string;
  /**
   * The HTTP status code ([RFC7231], Section 6) generated by the origin server for this occurrence of the problem.
   * @type {number}
   * @memberof BasicErrorResponse
   */
  status?: number;
  /**
   * Service specific error code
   * @type {number}
   * @memberof BasicErrorResponse
   */
  code?: number;
  /**
   * A human-readable explanation specific to this occurrence of the problem.
   * @type {string}
   * @memberof BasicErrorResponse
   */
  detail?: string;
  /**
   * A URI reference that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
   * @type {string}
   * @memberof BasicErrorResponse
   */
  instance?: string;
  /**
   * Machine readable service specific errors.
   * @type {Array<object>}
   * @memberof BasicErrorResponse
   */
  details?: Array<object>;
}
/**
 * Single error in the Batch Basic Error Response.
 * @export
 * @interface BatchBasicErrorBody
 */
export interface BatchBasicErrorBody {
  /**
   *
   * @type {Array<string>}
   * @memberof BatchBasicErrorBody
   */
  messages: Array<string>;
  /**
   *
   * @type {string}
   * @memberof BatchBasicErrorBody
   */
  key: string;
}
/**
 * Batch basic error response when one or more values provided from the client fails some condition
 * @export
 * @interface BatchBasicErrorResponse
 */
export interface BatchBasicErrorResponse {
  /**
   *
   * @type {string}
   * @memberof BatchBasicErrorResponse
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof BatchBasicErrorResponse
   */
  title: string;
  /**
   *
   * @type {number}
   * @memberof BatchBasicErrorResponse
   */
  status: number;
  /**
   *
   * @type {number}
   * @memberof BatchBasicErrorResponse
   */
  code: number;
  /**
   *
   * @type {string}
   * @memberof BatchBasicErrorResponse
   */
  detail: string;
  /**
   *
   * @type {string}
   * @memberof BatchBasicErrorResponse
   */
  instance?: string;
  /**
   *
   * @type {Array<BatchBasicErrorBody>}
   * @memberof BatchBasicErrorResponse
   */
  errors: Array<BatchBasicErrorBody>;
}
/**
 * An error response sent back upon a batch update containing a resource conflict. All Data Items within the request should be considered unprocessed. The error response data[] property contains the Data Items that conflicted
 * @export
 * @interface BatchConflictErrorResponse
 */
export interface BatchConflictErrorResponse {
  /**
   *
   * @type {string}
   * @memberof BatchConflictErrorResponse
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof BatchConflictErrorResponse
   */
  title: string;
  /**
   * e.g 409
   * @type {number}
   * @memberof BatchConflictErrorResponse
   */
  status: number;
  /**
   * e.g. 1013
   * @type {number}
   * @memberof BatchConflictErrorResponse
   */
  code: number;
  /**
   *
   * @type {string}
   * @memberof BatchConflictErrorResponse
   */
  detail: string;
  /**
   *
   * @type {string}
   * @memberof BatchConflictErrorResponse
   */
  instance?: string;
  /**
   *
   * @type {Array<BatchConflictErrorResponseData>}
   * @memberof BatchConflictErrorResponse
   */
  data: Array<BatchConflictErrorResponseData>;
}
/**
 *
 * @export
 * @interface BatchConflictErrorResponseData
 */
export interface BatchConflictErrorResponseData {
  /**
   *
   * @type {AttemptedItem}
   * @memberof BatchConflictErrorResponseData
   */
  attempted?: AttemptedItem;
  /**
   *
   * @type {Item}
   * @memberof BatchConflictErrorResponseData
   */
  existing?: Item;
}
/**
 * Single error in the Batch Validation Error Response.
 * @export
 * @interface BatchValidationErrorBody
 */
export interface BatchValidationErrorBody {
  /**
   *
   * @type {string}
   * @memberof BatchValidationErrorBody
   */
  field: string;
  /**
   *
   * @type {Array<string>}
   * @memberof BatchValidationErrorBody
   */
  messages: Array<string>;
  /**
   *
   * @type {string}
   * @memberof BatchValidationErrorBody
   */
  key: string;
}
/**
 * Batch validation error response when one or more values provided from the client does not pass validation on server
 * @export
 * @interface BatchValidationErrorResponse
 */
export interface BatchValidationErrorResponse {
  /**
   *
   * @type {string}
   * @memberof BatchValidationErrorResponse
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof BatchValidationErrorResponse
   */
  title: string;
  /**
   *
   * @type {number}
   * @memberof BatchValidationErrorResponse
   */
  status: number;
  /**
   *
   * @type {number}
   * @memberof BatchValidationErrorResponse
   */
  code: number;
  /**
   *
   * @type {string}
   * @memberof BatchValidationErrorResponse
   */
  detail: string;
  /**
   *
   * @type {string}
   * @memberof BatchValidationErrorResponse
   */
  instance?: string;
  /**
   *
   * @type {Array<BatchValidationErrorBody>}
   * @memberof BatchValidationErrorResponse
   */
  errors: Array<BatchValidationErrorBody>;
}
/**
 * An error response sent back upon resource conflict
 * @export
 * @interface ConflictErrorResponse
 */
export interface ConflictErrorResponse {
  /**
   *
   * @type {string}
   * @memberof ConflictErrorResponse
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof ConflictErrorResponse
   */
  title: string;
  /**
   * e.g 409
   * @type {number}
   * @memberof ConflictErrorResponse
   */
  status: number;
  /**
   * e.g. 1013
   * @type {number}
   * @memberof ConflictErrorResponse
   */
  code: number;
  /**
   *
   * @type {string}
   * @memberof ConflictErrorResponse
   */
  detail: string;
  /**
   *
   * @type {string}
   * @memberof ConflictErrorResponse
   */
  instance?: string;
  /**
   *
   * @type {ConflictErrorResponseData}
   * @memberof ConflictErrorResponse
   */
  data: ConflictErrorResponseData;
}
/**
 *
 * @export
 * @interface ConflictErrorResponseData
 */
export interface ConflictErrorResponseData {
  /**
   *
   * @type {AttemptedItem}
   * @memberof ConflictErrorResponseData
   */
  attempted: AttemptedItem;
  /**
   *
   * @type {Item}
   * @memberof ConflictErrorResponseData
   */
  existing: Item;
}
/**
 *
 * @export
 * @interface GetItemsResponse
 */
export interface GetItemsResponse {
  /**
   *
   * @type {Array<Item>}
   * @memberof GetItemsResponse
   */
  results: Array<Item>;
  /**
   *
   * @type {GetItemsResponseLinks}
   * @memberof GetItemsResponse
   */
  links: GetItemsResponseLinks;
}
/**
 *
 * @export
 * @interface GetItemsResponseLinks
 */
export interface GetItemsResponseLinks {
  /**
   * Contains the URL path for requesting the next page of results. This value is null when there are no pages remaining.
   * @type {string}
   * @memberof GetItemsResponseLinks
   */
  next: string | null;
}
/**
 *
 * @export
 * @interface GetKeysResponse
 */
export interface GetKeysResponse {
  /**
   *
   * @type {Array<KeyMetadata>}
   * @memberof GetKeysResponse
   */
  results: Array<KeyMetadata>;
  /**
   *
   * @type {GetItemsResponseLinks}
   * @memberof GetKeysResponse
   */
  links: GetItemsResponseLinks;
}
/**
 * Response type for a Data Item stored in the Cloud Save service.
 * @export
 * @interface Item
 */
export interface Item {
  /**
   * Item key
   * @type {string}
   * @memberof Item
   */
  key: string;
  /**
   * Any JSON serializable structure
   * @type {object}
   * @memberof Item
   */
  value: object;
  /**
   * Enforces conflict checking when updating an existing data item. This field should be omitted when creating a new data item. When updating an existing item, omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
   * @type {string}
   * @memberof Item
   */
  writeLock: string;
  /**
   *
   * @type {ModifiedMetadata}
   * @memberof Item
   */
  modified: ModifiedMetadata;
  /**
   *
   * @type {ModifiedMetadata}
   * @memberof Item
   */
  created: ModifiedMetadata;
}
/**
 * Response type Key + Metadata for an individual data item stored in the Cloud Save service.
 * @export
 * @interface KeyMetadata
 */
export interface KeyMetadata {
  /**
   * Item key
   * @type {string}
   * @memberof KeyMetadata
   */
  key: string;
  /**
   * Enforces conflict checking when updating an existing data item. This field should be omitted when creating a new data item. When updating an existing item, omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
   * @type {string}
   * @memberof KeyMetadata
   */
  writeLock: string;
  /**
   *
   * @type {ModifiedMetadata}
   * @memberof KeyMetadata
   */
  modified: ModifiedMetadata;
}
/**
 *
 * @export
 * @interface ModifiedMetadata
 */
export interface ModifiedMetadata {
  /**
   * Date time in ISO 8601 format. Null if there is no associated value.
   * @type {string}
   * @memberof ModifiedMetadata
   */
  date: string | null;
}
/**
 *
 * @export
 * @interface SetItemBatchBody
 */
export interface SetItemBatchBody {
  /**
   *
   * @type {Array<SetItemBody>}
   * @memberof SetItemBatchBody
   */
  data?: Array<SetItemBody>;
}
/**
 *
 * @export
 * @interface SetItemBatchResponse
 */
export interface SetItemBatchResponse {
  /**
   *
   * @type {Array<SetItemBatchResponseResults>}
   * @memberof SetItemBatchResponse
   */
  results?: Array<SetItemBatchResponseResults>;
}
/**
 *
 * @export
 * @interface SetItemBatchResponseResults
 */
export interface SetItemBatchResponseResults {
  /**
   * Item key
   * @type {string}
   * @memberof SetItemBatchResponseResults
   */
  key: string;
  /**
   * Enforces conflict checking when updating an existing data item. This field should be omitted when creating a new data item. When updating an existing item, omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
   * @type {string}
   * @memberof SetItemBatchResponseResults
   */
  writeLock: string;
}
/**
 * Request type for a Data Item to store in the Cloud Save service.
 * @export
 * @interface SetItemBody
 */
export interface SetItemBody {
  /**
   * The key will be created if it does not exist, provided the item limit has not been reached for this entity.
   * @type {string}
   * @memberof SetItemBody
   */
  key: string;
  /**
   * Any JSON serializable structure
   * @type {object}
   * @memberof SetItemBody
   */
  value: object;
  /**
   * Enforces conflict checking when updating an existing data item. This field should be omitted when creating a new data item. When updating an existing item, omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
   * @type {string}
   * @memberof SetItemBody
   */
  writeLock?: string;
}
/**
 *
 * @export
 * @interface SetItemResponse
 */
export interface SetItemResponse {
  /**
   * Enforces conflict checking when updating an existing data item. This field should be omitted when creating a new data item. When updating an existing item, omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
   * @type {string}
   * @memberof SetItemResponse
   */
  writeLock: string;
}
/**
 * Single error in the Validation Error Response.
 * @export
 * @interface ValidationErrorBody
 */
export interface ValidationErrorBody {
  /**
   *
   * @type {string}
   * @memberof ValidationErrorBody
   */
  field: string;
  /**
   *
   * @type {Array<string>}
   * @memberof ValidationErrorBody
   */
  messages: Array<string>;
}
/**
 * Validation error response when a value provided from the client does not pass validation on server
 * @export
 * @interface ValidationErrorResponse
 */
export interface ValidationErrorResponse {
  /**
   *
   * @type {string}
   * @memberof ValidationErrorResponse
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof ValidationErrorResponse
   */
  title: string;
  /**
   *
   * @type {number}
   * @memberof ValidationErrorResponse
   */
  status: number;
  /**
   *
   * @type {number}
   * @memberof ValidationErrorResponse
   */
  code: number;
  /**
   *
   * @type {string}
   * @memberof ValidationErrorResponse
   */
  detail: string;
  /**
   *
   * @type {string}
   * @memberof ValidationErrorResponse
   */
  instance?: string;
  /**
   *
   * @type {Array<ValidationErrorBody>}
   * @memberof ValidationErrorResponse
   */
  errors: Array<ValidationErrorBody>;
}

/**
 * DataApi - axios parameter creator
 * @export
 */
export const DataApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Deletes a data item by the specified key.
     * @summary Delete Item
     * @param {string} key
     * @param {string} projectId
     * @param {string} playerId
     * @param {string} [writeLock] Enforces conflict checking when deleting an existing data item.   Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteItem: async (
      key: string,
      projectId: string,
      playerId: string,
      writeLock?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'key' is not null or undefined
      assertParamExists("deleteItem", "key", key);
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("deleteItem", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("deleteItem", "playerId", playerId);
      const localVarPath =
        `/v1/data/projects/{projectId}/players/{playerId}/items/{key}`
          .replace(`{${"key"}}`, encodeURIComponent(String(key)))
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication JWT required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (writeLock !== undefined) {
        localVarQueryParameter["writeLock"] = writeLock;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves save data values for all keys specified, ordered alphabetically in pages of 20.  If no keys are supplied then returns all keys, ordered alphabetically in pages of 20.
     * @summary Get Items
     * @param {string} projectId
     * @param {string} playerId
     * @param {Array<string>} [keys] The keys to retrieve, in exploded form style, e.g. &#x60;keys&#x3D;KEY1&amp;keys&#x3D;KEY2&amp;keys&#x3D;KEY3&#x60;
     * @param {string} [after] The key after which to retrieve the next page of keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getItems: async (
      projectId: string,
      playerId: string,
      keys?: Array<string>,
      after?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("getItems", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("getItems", "playerId", playerId);
      const localVarPath =
        `/v1/data/projects/{projectId}/players/{playerId}/items`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication JWT required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (keys) {
        localVarQueryParameter["keys"] = keys;
      }

      if (after !== undefined) {
        localVarQueryParameter["after"] = after;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Gets a paged list of keys for the given player, ordered alphabetically in pages of 100.
     * @summary Get Keys
     * @param {string} projectId
     * @param {string} playerId
     * @param {string} [after] Returns the page of results after the key specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getKeys: async (
      projectId: string,
      playerId: string,
      after?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("getKeys", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("getKeys", "playerId", playerId);
      const localVarPath =
        `/v1/data/projects/{projectId}/players/{playerId}/keys`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication JWT required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (after !== undefined) {
        localVarQueryParameter["after"] = after;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Set a data item with a given key and value for the specified player. The value is limited to a maximum size of 1KB.  The entire save state for a player is limited to 200 keys. Attempting to set a new key beyond this limit will result in an error.
     * @summary Set Item
     * @param {string} projectId
     * @param {string} playerId
     * @param {SetItemBody} [setItemBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setItem: async (
      projectId: string,
      playerId: string,
      setItemBody?: SetItemBody,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("setItem", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("setItem", "playerId", playerId);
      const localVarPath =
        `/v1/data/projects/{projectId}/players/{playerId}/items`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication JWT required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        setItemBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Set up to 20 data items with key, value and optional writeLock. The values are each limited to a maximum size of 1KB.  The entire save state for a player is limited to 200 keys. Attempting to set a new key beyond this limit will result in an error.  The batch set operation is considered atomic and if any of the set key operation fails, the entire operation is failed. Error responses should identify the affected key operations that failed.
     * @summary Set Item Batch
     * @param {string} projectId
     * @param {string} playerId
     * @param {SetItemBatchBody} [setItemBatchBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setItemBatch: async (
      projectId: string,
      playerId: string,
      setItemBatchBody?: SetItemBatchBody,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("setItemBatch", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("setItemBatch", "playerId", playerId);
      const localVarPath =
        `/v1/data/projects/{projectId}/players/{playerId}/item-batch`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication JWT required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        setItemBatchBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DataApi - functional programming interface
 * @export
 */
export const DataApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DataApiAxiosParamCreator(configuration);
  return {
    /**
     * Deletes a data item by the specified key.
     * @summary Delete Item
     * @param {string} key
     * @param {string} projectId
     * @param {string} playerId
     * @param {string} [writeLock] Enforces conflict checking when deleting an existing data item.   Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteItem(
      key: string,
      projectId: string,
      playerId: string,
      writeLock?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItem(
        key,
        projectId,
        playerId,
        writeLock,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Retrieves save data values for all keys specified, ordered alphabetically in pages of 20.  If no keys are supplied then returns all keys, ordered alphabetically in pages of 20.
     * @summary Get Items
     * @param {string} projectId
     * @param {string} playerId
     * @param {Array<string>} [keys] The keys to retrieve, in exploded form style, e.g. &#x60;keys&#x3D;KEY1&amp;keys&#x3D;KEY2&amp;keys&#x3D;KEY3&#x60;
     * @param {string} [after] The key after which to retrieve the next page of keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getItems(
      projectId: string,
      playerId: string,
      keys?: Array<string>,
      after?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetItemsResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getItems(
        projectId,
        playerId,
        keys,
        after,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Gets a paged list of keys for the given player, ordered alphabetically in pages of 100.
     * @summary Get Keys
     * @param {string} projectId
     * @param {string} playerId
     * @param {string} [after] Returns the page of results after the key specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getKeys(
      projectId: string,
      playerId: string,
      after?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetKeysResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getKeys(
        projectId,
        playerId,
        after,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Set a data item with a given key and value for the specified player. The value is limited to a maximum size of 1KB.  The entire save state for a player is limited to 200 keys. Attempting to set a new key beyond this limit will result in an error.
     * @summary Set Item
     * @param {string} projectId
     * @param {string} playerId
     * @param {SetItemBody} [setItemBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setItem(
      projectId: string,
      playerId: string,
      setItemBody?: SetItemBody,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SetItemResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setItem(
        projectId,
        playerId,
        setItemBody,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Set up to 20 data items with key, value and optional writeLock. The values are each limited to a maximum size of 1KB.  The entire save state for a player is limited to 200 keys. Attempting to set a new key beyond this limit will result in an error.  The batch set operation is considered atomic and if any of the set key operation fails, the entire operation is failed. Error responses should identify the affected key operations that failed.
     * @summary Set Item Batch
     * @param {string} projectId
     * @param {string} playerId
     * @param {SetItemBatchBody} [setItemBatchBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setItemBatch(
      projectId: string,
      playerId: string,
      setItemBatchBody?: SetItemBatchBody,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SetItemBatchResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setItemBatch(
        projectId,
        playerId,
        setItemBatchBody,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * DataApi - factory interface
 * @export
 */
export const DataApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = DataApiFp(configuration);
  return {
    /**
     * Deletes a data item by the specified key.
     * @summary Delete Item
     * @param {string} key
     * @param {string} projectId
     * @param {string} playerId
     * @param {string} [writeLock] Enforces conflict checking when deleting an existing data item.   Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteItem(
      key: string,
      projectId: string,
      playerId: string,
      writeLock?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteItem(key, projectId, playerId, writeLock, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves save data values for all keys specified, ordered alphabetically in pages of 20.  If no keys are supplied then returns all keys, ordered alphabetically in pages of 20.
     * @summary Get Items
     * @param {string} projectId
     * @param {string} playerId
     * @param {Array<string>} [keys] The keys to retrieve, in exploded form style, e.g. &#x60;keys&#x3D;KEY1&amp;keys&#x3D;KEY2&amp;keys&#x3D;KEY3&#x60;
     * @param {string} [after] The key after which to retrieve the next page of keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getItems(
      projectId: string,
      playerId: string,
      keys?: Array<string>,
      after?: string,
      options?: any
    ): AxiosPromise<GetItemsResponse> {
      return localVarFp
        .getItems(projectId, playerId, keys, after, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Gets a paged list of keys for the given player, ordered alphabetically in pages of 100.
     * @summary Get Keys
     * @param {string} projectId
     * @param {string} playerId
     * @param {string} [after] Returns the page of results after the key specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getKeys(
      projectId: string,
      playerId: string,
      after?: string,
      options?: any
    ): AxiosPromise<GetKeysResponse> {
      return localVarFp
        .getKeys(projectId, playerId, after, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Set a data item with a given key and value for the specified player. The value is limited to a maximum size of 1KB.  The entire save state for a player is limited to 200 keys. Attempting to set a new key beyond this limit will result in an error.
     * @summary Set Item
     * @param {string} projectId
     * @param {string} playerId
     * @param {SetItemBody} [setItemBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setItem(
      projectId: string,
      playerId: string,
      setItemBody?: SetItemBody,
      options?: any
    ): AxiosPromise<SetItemResponse> {
      return localVarFp
        .setItem(projectId, playerId, setItemBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Set up to 20 data items with key, value and optional writeLock. The values are each limited to a maximum size of 1KB.  The entire save state for a player is limited to 200 keys. Attempting to set a new key beyond this limit will result in an error.  The batch set operation is considered atomic and if any of the set key operation fails, the entire operation is failed. Error responses should identify the affected key operations that failed.
     * @summary Set Item Batch
     * @param {string} projectId
     * @param {string} playerId
     * @param {SetItemBatchBody} [setItemBatchBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setItemBatch(
      projectId: string,
      playerId: string,
      setItemBatchBody?: SetItemBatchBody,
      options?: any
    ): AxiosPromise<SetItemBatchResponse> {
      return localVarFp
        .setItemBatch(projectId, playerId, setItemBatchBody, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * DataApi - object-oriented interface
 * @export
 * @class DataApi
 * @extends {BaseAPI}
 */
export class DataApi extends BaseAPI {
  /**
   * Deletes a data item by the specified key.
   * @summary Delete Item
   * @param {string} key
   * @param {string} projectId
   * @param {string} playerId
   * @param {string} [writeLock] Enforces conflict checking when deleting an existing data item.   Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public deleteItem(
    key: string,
    projectId: string,
    playerId: string,
    writeLock?: string,
    options?: any
  ) {
    return DataApiFp(this.configuration)
      .deleteItem(key, projectId, playerId, writeLock, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves save data values for all keys specified, ordered alphabetically in pages of 20.  If no keys are supplied then returns all keys, ordered alphabetically in pages of 20.
   * @summary Get Items
   * @param {string} projectId
   * @param {string} playerId
   * @param {Array<string>} [keys] The keys to retrieve, in exploded form style, e.g. &#x60;keys&#x3D;KEY1&amp;keys&#x3D;KEY2&amp;keys&#x3D;KEY3&#x60;
   * @param {string} [after] The key after which to retrieve the next page of keys.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public getItems(
    projectId: string,
    playerId: string,
    keys?: Array<string>,
    after?: string,
    options?: any
  ) {
    return DataApiFp(this.configuration)
      .getItems(projectId, playerId, keys, after, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Gets a paged list of keys for the given player, ordered alphabetically in pages of 100.
   * @summary Get Keys
   * @param {string} projectId
   * @param {string} playerId
   * @param {string} [after] Returns the page of results after the key specified.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public getKeys(
    projectId: string,
    playerId: string,
    after?: string,
    options?: any
  ) {
    return DataApiFp(this.configuration)
      .getKeys(projectId, playerId, after, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Set a data item with a given key and value for the specified player. The value is limited to a maximum size of 1KB.  The entire save state for a player is limited to 200 keys. Attempting to set a new key beyond this limit will result in an error.
   * @summary Set Item
   * @param {string} projectId
   * @param {string} playerId
   * @param {SetItemBody} [setItemBody]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public setItem(
    projectId: string,
    playerId: string,
    setItemBody?: SetItemBody,
    options?: any
  ) {
    return DataApiFp(this.configuration)
      .setItem(projectId, playerId, setItemBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Set up to 20 data items with key, value and optional writeLock. The values are each limited to a maximum size of 1KB.  The entire save state for a player is limited to 200 keys. Attempting to set a new key beyond this limit will result in an error.  The batch set operation is considered atomic and if any of the set key operation fails, the entire operation is failed. Error responses should identify the affected key operations that failed.
   * @summary Set Item Batch
   * @param {string} projectId
   * @param {string} playerId
   * @param {SetItemBatchBody} [setItemBatchBody]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public setItemBatch(
    projectId: string,
    playerId: string,
    setItemBatchBody?: SetItemBatchBody,
    options?: any
  ) {
    return DataApiFp(this.configuration)
      .setItemBatch(projectId, playerId, setItemBatchBody, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
