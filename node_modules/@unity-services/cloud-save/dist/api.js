"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Cloud Save API
 * # Introduction This is the API specification for the Unity Cloud Save service that allows player state to be persisted from a game client.  To use this API, you must first enable it through Unity Dashboard.  ### Notes about the Alpha version This API is currently in its alpha phase and is only available to invited users.  During the Alpha period, the information in this document is not guaranteed to be up-to-date and may change without notice.  # General Information  ## Concepts There are two concepts for saving state in the Cloud Save service, \'Data\' and \'Files\'. Both types of state are stored against a specific player.  ### Data \'Data\' are small JSON serializable data, up to 1KB in size, stored as key/value pairs.  Limits: - Max 1KB in size - Max 200 items per player  ### Files \'Files\' are larger blobs of arbitrary data, up to 100MB.  Limits: - Max 100MB in size - Max 20 files per player  ## Rate Limits  The API has rate limiting in place. Request are limited on a per-player basis up to 900 requests per minute which would allow for a sustained 15 requests per second.  The API responds with a `429` HTTP status code if the rate limit is exceeded. It will also respond with a `Retry-After` header to be used in conjunction with a client\'s retry logic. The value is the number of seconds until a request for the given player will be accepted.
 *
 * The version of the OpenAPI document: 1.0-alpha
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataApi = exports.DataApiFactory = exports.DataApiFp = exports.DataApiAxiosParamCreator = void 0;
var axios_1 = require("axios");
// Some imports not used depending on template conditions
// @ts-ignore
var common_1 = require("./common");
// @ts-ignore
var base_1 = require("./base");
/**
 * DataApi - axios parameter creator
 * @export
 */
exports.DataApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * Deletes a data item by the specified key.
         * @summary Delete Item
         * @param {string} key
         * @param {string} projectId
         * @param {string} playerId
         * @param {string} [writeLock] Enforces conflict checking when deleting an existing data item.   Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem: function (key, projectId, playerId, writeLock, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'key' is not null or undefined
                            common_1.assertParamExists("deleteItem", "key", key);
                            // verify required parameter 'projectId' is not null or undefined
                            common_1.assertParamExists("deleteItem", "projectId", projectId);
                            // verify required parameter 'playerId' is not null or undefined
                            common_1.assertParamExists("deleteItem", "playerId", playerId);
                            localVarPath = "/v1/data/projects/{projectId}/players/{playerId}/items/{key}"
                                .replace("{" + "key" + "}", encodeURIComponent(String(key)))
                                .replace("{" + "projectId" + "}", encodeURIComponent(String(projectId)))
                                .replace("{" + "playerId" + "}", encodeURIComponent(String(playerId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: "DELETE" }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication JWT required
                            // http bearer authentication required
                            return [4 /*yield*/, common_1.setBearerAuthToObject(localVarHeaderParameter, configuration)];
                        case 1:
                            // authentication JWT required
                            // http bearer authentication required
                            _a.sent();
                            if (writeLock !== undefined) {
                                localVarQueryParameter["writeLock"] = writeLock;
                            }
                            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: common_1.toPathString(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Retrieves save data values for all keys specified, ordered alphabetically in pages of 20.  If no keys are supplied then returns all keys, ordered alphabetically in pages of 20.
         * @summary Get Items
         * @param {string} projectId
         * @param {string} playerId
         * @param {Array<string>} [keys] The keys to retrieve, in exploded form style, e.g. &#x60;keys&#x3D;KEY1&amp;keys&#x3D;KEY2&amp;keys&#x3D;KEY3&#x60;
         * @param {string} [after] The key after which to retrieve the next page of keys.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItems: function (projectId, playerId, keys, after, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            common_1.assertParamExists("getItems", "projectId", projectId);
                            // verify required parameter 'playerId' is not null or undefined
                            common_1.assertParamExists("getItems", "playerId", playerId);
                            localVarPath = "/v1/data/projects/{projectId}/players/{playerId}/items"
                                .replace("{" + "projectId" + "}", encodeURIComponent(String(projectId)))
                                .replace("{" + "playerId" + "}", encodeURIComponent(String(playerId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: "GET" }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication JWT required
                            // http bearer authentication required
                            return [4 /*yield*/, common_1.setBearerAuthToObject(localVarHeaderParameter, configuration)];
                        case 1:
                            // authentication JWT required
                            // http bearer authentication required
                            _a.sent();
                            if (keys) {
                                localVarQueryParameter["keys"] = keys;
                            }
                            if (after !== undefined) {
                                localVarQueryParameter["after"] = after;
                            }
                            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: common_1.toPathString(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Gets a paged list of keys for the given player, ordered alphabetically in pages of 100.
         * @summary Get Keys
         * @param {string} projectId
         * @param {string} playerId
         * @param {string} [after] Returns the page of results after the key specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeys: function (projectId, playerId, after, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            common_1.assertParamExists("getKeys", "projectId", projectId);
                            // verify required parameter 'playerId' is not null or undefined
                            common_1.assertParamExists("getKeys", "playerId", playerId);
                            localVarPath = "/v1/data/projects/{projectId}/players/{playerId}/keys"
                                .replace("{" + "projectId" + "}", encodeURIComponent(String(projectId)))
                                .replace("{" + "playerId" + "}", encodeURIComponent(String(playerId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: "GET" }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication JWT required
                            // http bearer authentication required
                            return [4 /*yield*/, common_1.setBearerAuthToObject(localVarHeaderParameter, configuration)];
                        case 1:
                            // authentication JWT required
                            // http bearer authentication required
                            _a.sent();
                            if (after !== undefined) {
                                localVarQueryParameter["after"] = after;
                            }
                            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            return [2 /*return*/, {
                                    url: common_1.toPathString(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Set a data item with a given key and value for the specified player. The value is limited to a maximum size of 1KB.  The entire save state for a player is limited to 200 keys. Attempting to set a new key beyond this limit will result in an error.
         * @summary Set Item
         * @param {string} projectId
         * @param {string} playerId
         * @param {SetItemBody} [setItemBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setItem: function (projectId, playerId, setItemBody, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            common_1.assertParamExists("setItem", "projectId", projectId);
                            // verify required parameter 'playerId' is not null or undefined
                            common_1.assertParamExists("setItem", "playerId", playerId);
                            localVarPath = "/v1/data/projects/{projectId}/players/{playerId}/items"
                                .replace("{" + "projectId" + "}", encodeURIComponent(String(projectId)))
                                .replace("{" + "playerId" + "}", encodeURIComponent(String(playerId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: "POST" }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication JWT required
                            // http bearer authentication required
                            return [4 /*yield*/, common_1.setBearerAuthToObject(localVarHeaderParameter, configuration)];
                        case 1:
                            // authentication JWT required
                            // http bearer authentication required
                            _a.sent();
                            localVarHeaderParameter["Content-Type"] = "application/json";
                            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            localVarRequestOptions.data = common_1.serializeDataIfNeeded(setItemBody, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: common_1.toPathString(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
        /**
         * Set up to 20 data items with key, value and optional writeLock. The values are each limited to a maximum size of 1KB.  The entire save state for a player is limited to 200 keys. Attempting to set a new key beyond this limit will result in an error.  The batch set operation is considered atomic and if any of the set key operation fails, the entire operation is failed. Error responses should identify the affected key operations that failed.
         * @summary Set Item Batch
         * @param {string} projectId
         * @param {string} playerId
         * @param {SetItemBatchBody} [setItemBatchBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setItemBatch: function (projectId, playerId, setItemBatchBody, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // verify required parameter 'projectId' is not null or undefined
                            common_1.assertParamExists("setItemBatch", "projectId", projectId);
                            // verify required parameter 'playerId' is not null or undefined
                            common_1.assertParamExists("setItemBatch", "playerId", playerId);
                            localVarPath = "/v1/data/projects/{projectId}/players/{playerId}/item-batch"
                                .replace("{" + "projectId" + "}", encodeURIComponent(String(projectId)))
                                .replace("{" + "playerId" + "}", encodeURIComponent(String(playerId)));
                            localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
                            if (configuration) {
                                baseOptions = configuration.baseOptions;
                            }
                            localVarRequestOptions = __assign(__assign({ method: "POST" }, baseOptions), options);
                            localVarHeaderParameter = {};
                            localVarQueryParameter = {};
                            // authentication JWT required
                            // http bearer authentication required
                            return [4 /*yield*/, common_1.setBearerAuthToObject(localVarHeaderParameter, configuration)];
                        case 1:
                            // authentication JWT required
                            // http bearer authentication required
                            _a.sent();
                            localVarHeaderParameter["Content-Type"] = "application/json";
                            common_1.setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
                            headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                            localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                            localVarRequestOptions.data = common_1.serializeDataIfNeeded(setItemBatchBody, localVarRequestOptions, configuration);
                            return [2 /*return*/, {
                                    url: common_1.toPathString(localVarUrlObj),
                                    options: localVarRequestOptions,
                                }];
                    }
                });
            });
        },
    };
};
/**
 * DataApi - functional programming interface
 * @export
 */
exports.DataApiFp = function (configuration) {
    var localVarAxiosParamCreator = exports.DataApiAxiosParamCreator(configuration);
    return {
        /**
         * Deletes a data item by the specified key.
         * @summary Delete Item
         * @param {string} key
         * @param {string} projectId
         * @param {string} playerId
         * @param {string} [writeLock] Enforces conflict checking when deleting an existing data item.   Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem: function (key, projectId, playerId, writeLock, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.deleteItem(key, projectId, playerId, writeLock, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Retrieves save data values for all keys specified, ordered alphabetically in pages of 20.  If no keys are supplied then returns all keys, ordered alphabetically in pages of 20.
         * @summary Get Items
         * @param {string} projectId
         * @param {string} playerId
         * @param {Array<string>} [keys] The keys to retrieve, in exploded form style, e.g. &#x60;keys&#x3D;KEY1&amp;keys&#x3D;KEY2&amp;keys&#x3D;KEY3&#x60;
         * @param {string} [after] The key after which to retrieve the next page of keys.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItems: function (projectId, playerId, keys, after, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getItems(projectId, playerId, keys, after, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Gets a paged list of keys for the given player, ordered alphabetically in pages of 100.
         * @summary Get Keys
         * @param {string} projectId
         * @param {string} playerId
         * @param {string} [after] Returns the page of results after the key specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeys: function (projectId, playerId, after, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getKeys(projectId, playerId, after, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Set a data item with a given key and value for the specified player. The value is limited to a maximum size of 1KB.  The entire save state for a player is limited to 200 keys. Attempting to set a new key beyond this limit will result in an error.
         * @summary Set Item
         * @param {string} projectId
         * @param {string} playerId
         * @param {SetItemBody} [setItemBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setItem: function (projectId, playerId, setItemBody, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.setItem(projectId, playerId, setItemBody, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Set up to 20 data items with key, value and optional writeLock. The values are each limited to a maximum size of 1KB.  The entire save state for a player is limited to 200 keys. Attempting to set a new key beyond this limit will result in an error.  The batch set operation is considered atomic and if any of the set key operation fails, the entire operation is failed. Error responses should identify the affected key operations that failed.
         * @summary Set Item Batch
         * @param {string} projectId
         * @param {string} playerId
         * @param {SetItemBatchBody} [setItemBatchBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setItemBatch: function (projectId, playerId, setItemBatchBody, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.setItemBatch(projectId, playerId, setItemBatchBody, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, common_1.createRequestFunction(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
/**
 * DataApi - factory interface
 * @export
 */
exports.DataApiFactory = function (configuration, basePath, axios) {
    var localVarFp = exports.DataApiFp(configuration);
    return {
        /**
         * Deletes a data item by the specified key.
         * @summary Delete Item
         * @param {string} key
         * @param {string} projectId
         * @param {string} playerId
         * @param {string} [writeLock] Enforces conflict checking when deleting an existing data item.   Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem: function (key, projectId, playerId, writeLock, options) {
            return localVarFp
                .deleteItem(key, projectId, playerId, writeLock, options)
                .then(function (request) { return request(axios, basePath); });
        },
        /**
         * Retrieves save data values for all keys specified, ordered alphabetically in pages of 20.  If no keys are supplied then returns all keys, ordered alphabetically in pages of 20.
         * @summary Get Items
         * @param {string} projectId
         * @param {string} playerId
         * @param {Array<string>} [keys] The keys to retrieve, in exploded form style, e.g. &#x60;keys&#x3D;KEY1&amp;keys&#x3D;KEY2&amp;keys&#x3D;KEY3&#x60;
         * @param {string} [after] The key after which to retrieve the next page of keys.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItems: function (projectId, playerId, keys, after, options) {
            return localVarFp
                .getItems(projectId, playerId, keys, after, options)
                .then(function (request) { return request(axios, basePath); });
        },
        /**
         * Gets a paged list of keys for the given player, ordered alphabetically in pages of 100.
         * @summary Get Keys
         * @param {string} projectId
         * @param {string} playerId
         * @param {string} [after] Returns the page of results after the key specified.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeys: function (projectId, playerId, after, options) {
            return localVarFp
                .getKeys(projectId, playerId, after, options)
                .then(function (request) { return request(axios, basePath); });
        },
        /**
         * Set a data item with a given key and value for the specified player. The value is limited to a maximum size of 1KB.  The entire save state for a player is limited to 200 keys. Attempting to set a new key beyond this limit will result in an error.
         * @summary Set Item
         * @param {string} projectId
         * @param {string} playerId
         * @param {SetItemBody} [setItemBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setItem: function (projectId, playerId, setItemBody, options) {
            return localVarFp
                .setItem(projectId, playerId, setItemBody, options)
                .then(function (request) { return request(axios, basePath); });
        },
        /**
         * Set up to 20 data items with key, value and optional writeLock. The values are each limited to a maximum size of 1KB.  The entire save state for a player is limited to 200 keys. Attempting to set a new key beyond this limit will result in an error.  The batch set operation is considered atomic and if any of the set key operation fails, the entire operation is failed. Error responses should identify the affected key operations that failed.
         * @summary Set Item Batch
         * @param {string} projectId
         * @param {string} playerId
         * @param {SetItemBatchBody} [setItemBatchBody]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setItemBatch: function (projectId, playerId, setItemBatchBody, options) {
            return localVarFp
                .setItemBatch(projectId, playerId, setItemBatchBody, options)
                .then(function (request) { return request(axios, basePath); });
        },
    };
};
/**
 * DataApi - object-oriented interface
 * @export
 * @class DataApi
 * @extends {BaseAPI}
 */
var DataApi = /** @class */ (function (_super) {
    __extends(DataApi, _super);
    function DataApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Deletes a data item by the specified key.
     * @summary Delete Item
     * @param {string} key
     * @param {string} projectId
     * @param {string} playerId
     * @param {string} [writeLock] Enforces conflict checking when deleting an existing data item.   Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    DataApi.prototype.deleteItem = function (key, projectId, playerId, writeLock, options) {
        var _this = this;
        return exports.DataApiFp(this.configuration)
            .deleteItem(key, projectId, playerId, writeLock, options)
            .then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Retrieves save data values for all keys specified, ordered alphabetically in pages of 20.  If no keys are supplied then returns all keys, ordered alphabetically in pages of 20.
     * @summary Get Items
     * @param {string} projectId
     * @param {string} playerId
     * @param {Array<string>} [keys] The keys to retrieve, in exploded form style, e.g. &#x60;keys&#x3D;KEY1&amp;keys&#x3D;KEY2&amp;keys&#x3D;KEY3&#x60;
     * @param {string} [after] The key after which to retrieve the next page of keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    DataApi.prototype.getItems = function (projectId, playerId, keys, after, options) {
        var _this = this;
        return exports.DataApiFp(this.configuration)
            .getItems(projectId, playerId, keys, after, options)
            .then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Gets a paged list of keys for the given player, ordered alphabetically in pages of 100.
     * @summary Get Keys
     * @param {string} projectId
     * @param {string} playerId
     * @param {string} [after] Returns the page of results after the key specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    DataApi.prototype.getKeys = function (projectId, playerId, after, options) {
        var _this = this;
        return exports.DataApiFp(this.configuration)
            .getKeys(projectId, playerId, after, options)
            .then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Set a data item with a given key and value for the specified player. The value is limited to a maximum size of 1KB.  The entire save state for a player is limited to 200 keys. Attempting to set a new key beyond this limit will result in an error.
     * @summary Set Item
     * @param {string} projectId
     * @param {string} playerId
     * @param {SetItemBody} [setItemBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    DataApi.prototype.setItem = function (projectId, playerId, setItemBody, options) {
        var _this = this;
        return exports.DataApiFp(this.configuration)
            .setItem(projectId, playerId, setItemBody, options)
            .then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Set up to 20 data items with key, value and optional writeLock. The values are each limited to a maximum size of 1KB.  The entire save state for a player is limited to 200 keys. Attempting to set a new key beyond this limit will result in an error.  The batch set operation is considered atomic and if any of the set key operation fails, the entire operation is failed. Error responses should identify the affected key operations that failed.
     * @summary Set Item Batch
     * @param {string} projectId
     * @param {string} playerId
     * @param {SetItemBatchBody} [setItemBatchBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    DataApi.prototype.setItemBatch = function (projectId, playerId, setItemBatchBody, options) {
        var _this = this;
        return exports.DataApiFp(this.configuration)
            .setItemBatch(projectId, playerId, setItemBatchBody, options)
            .then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return DataApi;
}(base_1.BaseAPI));
exports.DataApi = DataApi;
