/**
 * Cloud Save API
 * # Introduction This is the API specification for the Unity Cloud Save service that allows player or custom non-player state to be accessed and persisted from a game client. The Player State API allows data to be stored against a specific player ID. Access using client authentication is limited to the specified player for both data reads and writes. The Game State API allows data to be stored against a custom ID provided by the user. All players are able to read the data from the custom ID using client authentication, but write operations are limited to Service Account authentication. To use this API, you must first enable it through the Unity Gaming Services dashboard.  # General Information Cloud Save Data are small JSON serializable data, stored as key/value pairs. The maximum size for player or custom data is 5 MB across all key/value pairs for that player. A player can have data in a single slot that is up to 5 MB in size, or use many slots that equal to less than 5 MB in total size. Limits: - Maximum 255 characters per slot name - Maximum 2000 data slots per player or custom ID - Maximum 5 MB in size per player or custom ID across all slots  ## Rate Limits The API has rate limiting in place. The endpoints are limited to 600 requests per minute on a per-player basis. The API responds with a `429` HTTP status code if the rate limit is exceeded. It will also respond with a `Retry-After` header to be used in conjunction with a client\'s retry logic. The value is the number of seconds until a request for the given player will be accepted.
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
export interface ConfigurationParameters {
    apiKey?: string | Promise<string> | ((name: string) => string) | ((name: string) => Promise<string>);
    username?: string;
    password?: string;
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string) | ((name?: string, scopes?: string[]) => Promise<string>);
    basePath?: string;
    baseOptions?: any;
    formDataCtor?: new () => any;
    playerId?: string;
    projectId?: string;
    environmentId?: string;
    environmentName?: string;
    playerToken?: string;
    serviceToken?: string;
    analyticsUserId?: string;
    unityInstallationId?: string;
    correlationId?: string;
}
export declare class Configuration {
    /**
     * parameter for apiKey security
     * @param name security name
     * @memberof Configuration
     */
    apiKey?: string | Promise<string> | ((name: string) => string) | ((name: string) => Promise<string>);
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    username?: string;
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    password?: string;
    /**
     * parameter for oauth2 security
     * @param name security name
     * @param scopes oauth2 scope
     * @memberof Configuration
     */
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string) | ((name?: string, scopes?: string[]) => Promise<string>);
    /**
     * override base path
     *
     * @type {string}
     * @memberof Configuration
     */
    basePath?: string;
    /**
     * base options for axios calls
     *
     * @type {any}
     * @memberof Configuration
     */
    baseOptions?: any;
    /**
     * The FormData constructor that will be used to create multipart form data
     * requests. You can inject this here so that execution environments that
     * do not support the FormData class can still run the generated client.
     *
     * @type {new () => FormData}
     */
    formDataCtor?: new () => any;
    /**
     * @type {string}
     * @memberof Configuration
     */
    playerId?: string;
    /**
     * @type {string}
     * @memberof Configuration
     */
    projectId?: string;
    /**
     * @type {string}
     * @memberof Configuration
     */
    environmentId?: string;
    /**
     * @type {string}
     * @memberof Configuration
     */
    environmentName?: string;
    /**
     * @type {string}
     * @memberof Configuration
     */
    playerToken?: string;
    /**
     * @type {string}
     * @memberof Configuration
     */
    serviceToken?: string;
    /**
     * @type {string}
     * @memberof Configuration
     */
    analyticsUserId?: string;
    /**
     * @type {string}
     * @memberof Configuration
     */
    unityInstallationId?: string;
    /**
     * @type {string}
     * @memberof Configuration
     */
    correlationId?: string;
    constructor(param?: ConfigurationParameters);
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime: string): boolean;
}
