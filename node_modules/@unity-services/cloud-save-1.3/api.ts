/* tslint:disable */
/* eslint-disable */
/**
 * Cloud Save API
 * # Introduction This is the API specification for the Unity Cloud Save service that allows player or custom non-player state to be accessed and persisted from a game client. The Player State API allows data to be stored against a specific player ID. Access using client authentication is limited to the specified player for both data reads and writes. The Game State API allows data to be stored against a custom ID provided by the user. All players are able to read the data from the custom ID using client authentication, but write operations are limited to Service Account authentication. To use this API, you must first enable it through the Unity Gaming Services dashboard.  # General Information Cloud Save Data are small JSON serializable data, stored as key/value pairs. The maximum size for player or custom data is 5 MB across all key/value pairs for that player. A player can have data in a single slot that is up to 5 MB in size, or use many slots that equal to less than 5 MB in total size. Limits: - Maximum 255 characters per slot name - Maximum 2000 data slots per player or custom ID - Maximum 5 MB in size per player or custom ID across all slots  ## Rate Limits The API has rate limiting in place. The endpoints are limited to 600 requests per minute on a per-player basis. The API responds with a `429` HTTP status code if the rate limit is exceeded. It will also respond with a `Retry-After` header to be used in conjunction with a client\'s retry logic. The value is the number of seconds until a request for the given player will be accepted.
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "./configuration";
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from "axios";
import globalAxios from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
import type { RequestArgs } from "./base";
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from "./base";

/**
 * Response type for an attempted Data Item sent to the Cloud Save service.
 * @export
 * @interface AttemptedItem
 */
export interface AttemptedItem {
  /**
   * Item key
   * @type {string}
   * @memberof AttemptedItem
   */
  key: string;
  /**
   * Any JSON serializable structure with a maximum size of 5 MB.
   * @type {object}
   * @memberof AttemptedItem
   */
  value: object;
  /**
   * Enforces conflict checking when updating an existing data item. This field should be omitted when creating a new data item. When updating an existing item, omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
   * @type {string}
   * @memberof AttemptedItem
   */
  writeLock: string;
}
/**
 *
 * @export
 * @interface BaseErrorResponse
 */
export interface BaseErrorResponse {
  /**
   * A URI reference [RFC3986] that identifies the problem type. This specification encourages that, when dereferenced, it provide human-readable documentation for the problem type (e.g., using HTML [W3C.REC-html5-20141028]). When this member is not present, its value is assumed to be \"about:blank\".
   * @type {string}
   * @memberof BaseErrorResponse
   */
  type: string;
  /**
   * A short, human-readable summary of the problem type. It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization (e.g., using proactive content negotiation; see [RFC7231], Section 3.4).
   * @type {string}
   * @memberof BaseErrorResponse
   */
  title?: string;
  /**
   * The HTTP status code ([RFC7231], Section 6) generated by the origin server for this occurrence of the problem.
   * @type {number}
   * @memberof BaseErrorResponse
   */
  status?: number;
  /**
   * Service specific error code
   * @type {number}
   * @memberof BaseErrorResponse
   */
  code?: number;
  /**
   * A human-readable explanation specific to this occurrence of the problem.
   * @type {string}
   * @memberof BaseErrorResponse
   */
  detail?: string;
  /**
   * A URI reference that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
   * @type {string}
   * @memberof BaseErrorResponse
   */
  instance?: string | null;
}
/**
 * Referenced from - https://tools.ietf.org/html/rfc7807#page-3 Consumers MUST use the \'type\' string as the primary identifier for the problem type; the \'title\' string is advisory and included only for users who are not aware of the semantics of the URI and do not have the ability to discover them (e.g., offline log analysis). Consumers SHOULD NOT automatically dereference the type URI. The \"status\" member, if present, is only advisory; it conveys the HTTP status code used for the convenience of the consumer. Generators MUST use the same status code in the actual HTTP response, to assure that generic HTTP software that does not understand this format still behaves correctly.  See Section 5 for further caveats regarding its use. Consumers can use the status member to determine what the original status code used by the generator was, in cases where it has been changed (e.g., by an intermediary or cache), and when message bodies persist without HTTP information.  Generic HTTP software will still use the HTTP status code. The \"detail\" member, if present, ought to focus on helping the client correct the problem, rather than giving debugging information.
 * @export
 * @interface BasicErrorResponse
 */
export interface BasicErrorResponse {
  /**
   * A URI reference [RFC3986] that identifies the problem type. This specification encourages that, when dereferenced, it provide human-readable documentation for the problem type (e.g., using HTML [W3C.REC-html5-20141028]). When this member is not present, its value is assumed to be \"about:blank\".
   * @type {string}
   * @memberof BasicErrorResponse
   */
  type: string;
  /**
   * A short, human-readable summary of the problem type. It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization (e.g., using proactive content negotiation; see [RFC7231], Section 3.4).
   * @type {string}
   * @memberof BasicErrorResponse
   */
  title?: string;
  /**
   * The HTTP status code ([RFC7231], Section 6) generated by the origin server for this occurrence of the problem.
   * @type {number}
   * @memberof BasicErrorResponse
   */
  status?: number;
  /**
   * Service specific error code
   * @type {number}
   * @memberof BasicErrorResponse
   */
  code?: number;
  /**
   * A human-readable explanation specific to this occurrence of the problem.
   * @type {string}
   * @memberof BasicErrorResponse
   */
  detail?: string;
  /**
   * A URI reference that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
   * @type {string}
   * @memberof BasicErrorResponse
   */
  instance?: string | null;
  /**
   * Machine readable service specific errors.
   * @type {Array<object>}
   * @memberof BasicErrorResponse
   */
  details?: Array<object>;
}
/**
 *
 * @export
 * @interface BasicErrorResponseAllOf
 */
export interface BasicErrorResponseAllOf {
  /**
   * Machine readable service specific errors.
   * @type {Array<object>}
   * @memberof BasicErrorResponseAllOf
   */
  details?: Array<object>;
}
/**
 * Single error in the Batch Basic Error Response.
 * @export
 * @interface BatchBasicErrorBody
 */
export interface BatchBasicErrorBody {
  /**
   *
   * @type {Array<string>}
   * @memberof BatchBasicErrorBody
   */
  messages: Array<string>;
  /**
   *
   * @type {string}
   * @memberof BatchBasicErrorBody
   */
  key: string;
}
/**
 * Batch basic error response when one or more values provided from the client fails some condition
 * @export
 * @interface BatchBasicErrorResponse
 */
export interface BatchBasicErrorResponse {
  /**
   *
   * @type {string}
   * @memberof BatchBasicErrorResponse
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof BatchBasicErrorResponse
   */
  title: string;
  /**
   *
   * @type {number}
   * @memberof BatchBasicErrorResponse
   */
  status: number;
  /**
   *
   * @type {number}
   * @memberof BatchBasicErrorResponse
   */
  code: number;
  /**
   *
   * @type {string}
   * @memberof BatchBasicErrorResponse
   */
  detail: string;
  /**
   *
   * @type {string}
   * @memberof BatchBasicErrorResponse
   */
  instance?: string;
  /**
   *
   * @type {Array<BatchBasicErrorBody>}
   * @memberof BatchBasicErrorResponse
   */
  errors: Array<BatchBasicErrorBody>;
}
/**
 * An error response sent back upon a batch update containing a resource conflict. All Data Items within the request should be considered unprocessed. The error response data[] property contains the Data Items that conflicted.
 * @export
 * @interface BatchConflictErrorResponse
 */
export interface BatchConflictErrorResponse {
  /**
   * A URI reference [RFC3986] that identifies the problem type. This specification encourages that, when dereferenced, it provide human-readable documentation for the problem type (e.g., using HTML [W3C.REC-html5-20141028]). When this member is not present, its value is assumed to be \"about:blank\".
   * @type {string}
   * @memberof BatchConflictErrorResponse
   */
  type: string;
  /**
   * A short, human-readable summary of the problem type. It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization (e.g., using proactive content negotiation; see [RFC7231], Section 3.4).
   * @type {string}
   * @memberof BatchConflictErrorResponse
   */
  title: string;
  /**
   * The HTTP status code ([RFC7231], Section 6) generated by the origin server for this occurrence of the problem.
   * @type {number}
   * @memberof BatchConflictErrorResponse
   */
  status: number;
  /**
   * Service specific error code
   * @type {number}
   * @memberof BatchConflictErrorResponse
   */
  code: number;
  /**
   * A human-readable explanation specific to this occurrence of the problem.
   * @type {string}
   * @memberof BatchConflictErrorResponse
   */
  detail: string;
  /**
   * A URI reference that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
   * @type {string}
   * @memberof BatchConflictErrorResponse
   */
  instance?: string | null;
  /**
   * A human-readable explanation specific to this occurrence of the problem.
   * @type {Array<ConflictErrorResponseData>}
   * @memberof BatchConflictErrorResponse
   */
  data: Array<ConflictErrorResponseData>;
}
/**
 *
 * @export
 * @interface BatchConflictErrorResponseAllOf
 */
export interface BatchConflictErrorResponseAllOf {
  /**
   * A human-readable explanation specific to this occurrence of the problem.
   * @type {Array<ConflictErrorResponseData>}
   * @memberof BatchConflictErrorResponseAllOf
   */
  data?: Array<ConflictErrorResponseData>;
}
/**
 * Single error in the Batch Validation Error Response.
 * @export
 * @interface BatchValidationErrorBody
 */
export interface BatchValidationErrorBody {
  /**
   *
   * @type {string}
   * @memberof BatchValidationErrorBody
   */
  field: string;
  /**
   *
   * @type {Array<string>}
   * @memberof BatchValidationErrorBody
   */
  messages: Array<string>;
  /**
   *
   * @type {string}
   * @memberof BatchValidationErrorBody
   */
  key: string;
}
/**
 * Batch validation error response when one or more values provided from the client does not pass validation on server
 * @export
 * @interface BatchValidationErrorResponse
 */
export interface BatchValidationErrorResponse {
  /**
   *
   * @type {string}
   * @memberof BatchValidationErrorResponse
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof BatchValidationErrorResponse
   */
  title: string;
  /**
   *
   * @type {number}
   * @memberof BatchValidationErrorResponse
   */
  status: number;
  /**
   *
   * @type {number}
   * @memberof BatchValidationErrorResponse
   */
  code: number;
  /**
   *
   * @type {string}
   * @memberof BatchValidationErrorResponse
   */
  detail: string;
  /**
   *
   * @type {string}
   * @memberof BatchValidationErrorResponse
   */
  instance?: string;
  /**
   *
   * @type {Array<BatchValidationErrorBody>}
   * @memberof BatchValidationErrorResponse
   */
  errors: Array<BatchValidationErrorBody>;
}
/**
 * An error sent back upon resource conflict.
 * @export
 * @interface ConflictErrorResponse
 */
export interface ConflictErrorResponse {
  /**
   * A URI reference [RFC3986] that identifies the problem type. This specification encourages that, when dereferenced, it provide human-readable documentation for the problem type (e.g., using HTML [W3C.REC-html5-20141028]). When this member is not present, its value is assumed to be \"about:blank\".
   * @type {string}
   * @memberof ConflictErrorResponse
   */
  type: string;
  /**
   * A short, human-readable summary of the problem type. It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization (e.g., using proactive content negotiation; see [RFC7231], Section 3.4).
   * @type {string}
   * @memberof ConflictErrorResponse
   */
  title: string;
  /**
   * The HTTP status code ([RFC7231], Section 6) generated by the origin server for this occurrence of the problem.
   * @type {number}
   * @memberof ConflictErrorResponse
   */
  status: number;
  /**
   * Service specific error code
   * @type {number}
   * @memberof ConflictErrorResponse
   */
  code: number;
  /**
   * A human-readable explanation specific to this occurrence of the problem.
   * @type {string}
   * @memberof ConflictErrorResponse
   */
  detail: string;
  /**
   * A URI reference that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
   * @type {string}
   * @memberof ConflictErrorResponse
   */
  instance?: string | null;
  /**
   *
   * @type {ConflictErrorResponseData}
   * @memberof ConflictErrorResponse
   */
  data: ConflictErrorResponseData;
}
/**
 *
 * @export
 * @interface ConflictErrorResponseAllOf
 */
export interface ConflictErrorResponseAllOf {
  /**
   *
   * @type {ConflictErrorResponseData}
   * @memberof ConflictErrorResponseAllOf
   */
  data?: ConflictErrorResponseData;
}
/**
 * A human-readable explanation specific to this occurrence of the problem.
 * @export
 * @interface ConflictErrorResponseData
 */
export interface ConflictErrorResponseData {
  /**
   *
   * @type {AttemptedItem}
   * @memberof ConflictErrorResponseData
   */
  attempted?: AttemptedItem;
  /**
   *
   * @type {Item}
   * @memberof ConflictErrorResponseData
   */
  existing?: Item;
}
/**
 * An error sent back upon resource conflict.
 * @export
 * @interface DeleteConflictErrorResponse
 */
export interface DeleteConflictErrorResponse {
  /**
   * A URI reference [RFC3986] that identifies the problem type. This specification encourages that, when dereferenced, it provide human-readable documentation for the problem type (e.g., using HTML [W3C.REC-html5-20141028]). When this member is not present, its value is assumed to be \"about:blank\".
   * @type {string}
   * @memberof DeleteConflictErrorResponse
   */
  type: string;
  /**
   * A short, human-readable summary of the problem type. It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization (e.g., using proactive content negotiation; see [RFC7231], Section 3.4).
   * @type {string}
   * @memberof DeleteConflictErrorResponse
   */
  title: string;
  /**
   * The HTTP status code ([RFC7231], Section 6) generated by the origin server for this occurrence of the problem.
   * @type {number}
   * @memberof DeleteConflictErrorResponse
   */
  status: number;
  /**
   * Service specific error code
   * @type {number}
   * @memberof DeleteConflictErrorResponse
   */
  code: number;
  /**
   * A human-readable explanation specific to this occurrence of the problem.
   * @type {string}
   * @memberof DeleteConflictErrorResponse
   */
  detail: string;
  /**
   * A URI reference that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
   * @type {string}
   * @memberof DeleteConflictErrorResponse
   */
  instance?: string | null;
  /**
   *
   * @type {DeleteConflictErrorResponseAllOfData}
   * @memberof DeleteConflictErrorResponse
   */
  data: DeleteConflictErrorResponseAllOfData;
}
/**
 *
 * @export
 * @interface DeleteConflictErrorResponseAllOf
 */
export interface DeleteConflictErrorResponseAllOf {
  /**
   *
   * @type {DeleteConflictErrorResponseAllOfData}
   * @memberof DeleteConflictErrorResponseAllOf
   */
  data?: DeleteConflictErrorResponseAllOfData;
}
/**
 * A human-readable explanation specific to this occurrence of the problem.
 * @export
 * @interface DeleteConflictErrorResponseAllOfData
 */
export interface DeleteConflictErrorResponseAllOfData {
  /**
   *
   * @type {string}
   * @memberof DeleteConflictErrorResponseAllOfData
   */
  key?: string;
  /**
   *
   * @type {string}
   * @memberof DeleteConflictErrorResponseAllOfData
   */
  attemptedWriteLock?: string;
  /**
   *
   * @type {string}
   * @memberof DeleteConflictErrorResponseAllOfData
   */
  existingWriteLock?: string;
}
/**
 * @type GetItems400Response
 * @export
 */
export type GetItems400Response =
  | ({ type: "problems/basic" } & BasicErrorResponse)
  | ({ type: "problems/validation" } & ValidationErrorResponse);

/**
 *
 * @export
 * @interface GetItemsResponse
 */
export interface GetItemsResponse {
  /**
   * Data values for all keys, ordered aplhabetically in pages of 20.
   * @type {Array<Item>}
   * @memberof GetItemsResponse
   */
  results: Array<Item>;
  /**
   *
   * @type {GetItemsResponseLinks}
   * @memberof GetItemsResponse
   */
  links: GetItemsResponseLinks;
}
/**
 *
 * @export
 * @interface GetItemsResponseLinks
 */
export interface GetItemsResponseLinks {
  /**
   * Contains the URL path for requesting the next page of results. This value is null when there are no pages remaining.
   * @type {string}
   * @memberof GetItemsResponseLinks
   */
  next: string | null;
}
/**
 *
 * @export
 * @interface GetKeysResponse
 */
export interface GetKeysResponse {
  /**
   * A paged list of keys for the given player, ordered alphabetically in pages of 100.
   * @type {Array<KeyMetadata>}
   * @memberof GetKeysResponse
   */
  results: Array<KeyMetadata>;
  /**
   *
   * @type {GetItemsResponseLinks}
   * @memberof GetKeysResponse
   */
  links: GetItemsResponseLinks;
}
/**
 * Response type for a Data Item stored in the Cloud Save service.
 * @export
 * @interface Item
 */
export interface Item {
  /**
   * Item key
   * @type {string}
   * @memberof Item
   */
  key: string;
  /**
   * Any JSON serializable structure with a maximum size of 5 MB.
   * @type {object}
   * @memberof Item
   */
  value: object;
  /**
   * Enforces conflict checking when updating an existing data item. This field should be omitted when creating a new data item. When updating an existing item, omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
   * @type {string}
   * @memberof Item
   */
  writeLock: string;
  /**
   *
   * @type {ModifiedMetadata}
   * @memberof Item
   */
  modified: ModifiedMetadata;
  /**
   *
   * @type {ModifiedMetadata}
   * @memberof Item
   */
  created: ModifiedMetadata;
}
/**
 * Response type Key with metadata for an individual data item stored in the Cloud Save service.
 * @export
 * @interface KeyMetadata
 */
export interface KeyMetadata {
  /**
   * Item key
   * @type {string}
   * @memberof KeyMetadata
   */
  key: string;
  /**
   * Enforces conflict checking when updating an existing data item. This field should be omitted when creating a new data item. When updating an existing item, omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
   * @type {string}
   * @memberof KeyMetadata
   */
  writeLock: string;
  /**
   *
   * @type {ModifiedMetadata}
   * @memberof KeyMetadata
   */
  modified: ModifiedMetadata;
}
/**
 * Timestamp for when the object was modified.
 * @export
 * @interface ModifiedMetadata
 */
export interface ModifiedMetadata {
  /**
   * Date time in ISO 8601 format. Null if there is no associated value.
   * @type {string}
   * @memberof ModifiedMetadata
   */
  date: string | null;
}
/**
 * @type SetItemBatch400Response
 * @export
 */
export type SetItemBatch400Response =
  | ({ type: "problems/basic" } & BasicErrorResponse)
  | ({ type: "problems/batch-basic" } & BatchBasicErrorResponse)
  | ({ type: "problems/batch-validation" } & BatchValidationErrorResponse)
  | ({ type: "problems/validation" } & ValidationErrorResponse);

/**
 *
 * @export
 * @interface SetItemBatchBody
 */
export interface SetItemBatchBody {
  /**
   *
   * @type {Array<SetItemBody>}
   * @memberof SetItemBatchBody
   */
  data?: Array<SetItemBody>;
}
/**
 *
 * @export
 * @interface SetItemBatchResponse
 */
export interface SetItemBatchResponse {
  /**
   *
   * @type {Array<SetItemBatchResponseResultsInner>}
   * @memberof SetItemBatchResponse
   */
  results?: Array<SetItemBatchResponseResultsInner>;
}
/**
 *
 * @export
 * @interface SetItemBatchResponseResultsInner
 */
export interface SetItemBatchResponseResultsInner {
  /**
   * Item key
   * @type {string}
   * @memberof SetItemBatchResponseResultsInner
   */
  key: string;
  /**
   * Enforces conflict checking when updating an existing data item. This field should be omitted when creating a new data item. When updating an existing item, omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
   * @type {string}
   * @memberof SetItemBatchResponseResultsInner
   */
  writeLock: string;
}
/**
 * Request type for a Data Item to store in the Cloud Save service.
 * @export
 * @interface SetItemBody
 */
export interface SetItemBody {
  /**
   * Item key
   * @type {string}
   * @memberof SetItemBody
   */
  key: string;
  /**
   * Any JSON serializable structure with a maximum size of 5 MB.
   * @type {object}
   * @memberof SetItemBody
   */
  value: object;
  /**
   * Enforces conflict checking when updating an existing data item. This field should be omitted when creating a new data item. When updating an existing item, omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
   * @type {string}
   * @memberof SetItemBody
   */
  writeLock?: string;
}
/**
 * Newly generated writeLock for the item.
 * @export
 * @interface SetItemResponse
 */
export interface SetItemResponse {
  /**
   * Enforces conflict checking when updating an existing data item. This field should be omitted when creating a new data item. When updating an existing item, omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
   * @type {string}
   * @memberof SetItemResponse
   */
  writeLock: string;
}
/**
 * Single error in the Validation Error Response.
 * @export
 * @interface ValidationErrorBody
 */
export interface ValidationErrorBody {
  /**
   *
   * @type {string}
   * @memberof ValidationErrorBody
   */
  field: string;
  /**
   *
   * @type {Array<string>}
   * @memberof ValidationErrorBody
   */
  messages: Array<string>;
}
/**
 * Validation error response when a value provided from the client does not pass validation on server.
 * @export
 * @interface ValidationErrorResponse
 */
export interface ValidationErrorResponse {
  /**
   *
   * @type {string}
   * @memberof ValidationErrorResponse
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof ValidationErrorResponse
   */
  title: string;
  /**
   *
   * @type {number}
   * @memberof ValidationErrorResponse
   */
  status: number;
  /**
   *
   * @type {number}
   * @memberof ValidationErrorResponse
   */
  code: number;
  /**
   *
   * @type {string}
   * @memberof ValidationErrorResponse
   */
  detail: string;
  /**
   *
   * @type {string}
   * @memberof ValidationErrorResponse
   */
  instance?: string;
  /**
   *
   * @type {Array<ValidationErrorBody>}
   * @memberof ValidationErrorResponse
   */
  errors: Array<ValidationErrorBody>;
}

/**
 * DataApi - axios parameter creator
 * @export
 */
export const DataApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Deletes a data item by the specified key for the specified custom ID.
     * @summary Delete Custom Item
     * @param {string} key Item key.
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {string} [writeLock] Enforces conflict checking when deleting an existing data item. Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCustomItem: async (
      key: string,
      projectId: string,
      customId: string,
      writeLock?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'key' is not null or undefined
      assertParamExists("deleteCustomItem", "key", key);
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("deleteCustomItem", "projectId", projectId);
      // verify required parameter 'customId' is not null or undefined
      assertParamExists("deleteCustomItem", "customId", customId);
      const localVarPath =
        `/v1/data/projects/{projectId}/custom/{customId}/items/{key}`
          .replace(`{${"key"}}`, encodeURIComponent(String(key)))
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"customId"}}`, encodeURIComponent(String(customId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (writeLock !== undefined) {
        localVarQueryParameter["writeLock"] = writeLock;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes all data associated with a given custom ID.
     * @summary Delete Custom Items
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCustomItems: async (
      projectId: string,
      customId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("deleteCustomItems", "projectId", projectId);
      // verify required parameter 'customId' is not null or undefined
      assertParamExists("deleteCustomItems", "customId", customId);
      const localVarPath =
        `/v1/data/projects/{projectId}/custom/{customId}/items`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"customId"}}`, encodeURIComponent(String(customId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes a data item by the specified key for the given player.
     * @summary Delete Player Item
     * @param {string} key Item key.
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} [writeLock] Enforces conflict checking when deleting an existing data item. Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteItem: async (
      key: string,
      projectId: string,
      playerId: string,
      writeLock?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'key' is not null or undefined
      assertParamExists("deleteItem", "key", key);
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("deleteItem", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("deleteItem", "playerId", playerId);
      const localVarPath =
        `/v1/data/projects/{projectId}/players/{playerId}/items/{key}`
          .replace(`{${"key"}}`, encodeURIComponent(String(key)))
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication Client required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (writeLock !== undefined) {
        localVarQueryParameter["writeLock"] = writeLock;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes all data associated with a given player.
     * @summary Delete Player Items
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteItems: async (
      projectId: string,
      playerId: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("deleteItems", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("deleteItems", "playerId", playerId);
      const localVarPath =
        `/v1/data/projects/{projectId}/players/{playerId}/items`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication Client required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves save data values for all keys specified, ordered alphabetically in pages of 20. If no keys are supplied then returns all keys, ordered alphabetically in pages of 20.
     * @summary Get Custom Items
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {Array<string>} [keys] The keys to retrieve, in exploded form style, e.g. &#x60;keys&#x3D;KEY1&amp;keys&#x3D;KEY2&amp;keys&#x3D;KEY3&#x60;.
     * @param {string} [after] The key after which to retrieve the next page of keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCustomItems: async (
      projectId: string,
      customId: string,
      keys?: Array<string>,
      after?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("getCustomItems", "projectId", projectId);
      // verify required parameter 'customId' is not null or undefined
      assertParamExists("getCustomItems", "customId", customId);
      const localVarPath =
        `/v1/data/projects/{projectId}/custom/{customId}/items`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"customId"}}`, encodeURIComponent(String(customId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication Client required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (keys) {
        localVarQueryParameter["keys"] = keys;
      }

      if (after !== undefined) {
        localVarQueryParameter["after"] = after;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Gets a paged list of keys for the given custom ID, ordered alphabetically in pages of 100.
     * @summary Get Custom Keys
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {string} [after] Returns the page of results after the key specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCustomKeys: async (
      projectId: string,
      customId: string,
      after?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("getCustomKeys", "projectId", projectId);
      // verify required parameter 'customId' is not null or undefined
      assertParamExists("getCustomKeys", "customId", customId);
      const localVarPath =
        `/v1/data/projects/{projectId}/custom/{customId}/keys`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"customId"}}`, encodeURIComponent(String(customId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication Client required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (after !== undefined) {
        localVarQueryParameter["after"] = after;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves save data values for all keys specified, ordered alphabetically in pages of 20. If no keys are supplied then returns all keys, ordered alphabetically in pages of 20.
     * @summary Get Player Items
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {Array<string>} [keys] The keys to retrieve, in exploded form style, e.g. &#x60;keys&#x3D;KEY1&amp;keys&#x3D;KEY2&amp;keys&#x3D;KEY3&#x60;.
     * @param {string} [after] The key after which to retrieve the next page of keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getItems: async (
      projectId: string,
      playerId: string,
      keys?: Array<string>,
      after?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("getItems", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("getItems", "playerId", playerId);
      const localVarPath =
        `/v1/data/projects/{projectId}/players/{playerId}/items`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication Client required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (keys) {
        localVarQueryParameter["keys"] = keys;
      }

      if (after !== undefined) {
        localVarQueryParameter["after"] = after;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Gets a paged list of keys for the given player, ordered alphabetically in pages of 100.
     * @summary Get Player Keys
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} [after] Returns the page of results after the key specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getKeys: async (
      projectId: string,
      playerId: string,
      after?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("getKeys", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("getKeys", "playerId", playerId);
      const localVarPath =
        `/v1/data/projects/{projectId}/players/{playerId}/keys`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication Client required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (after !== undefined) {
        localVarQueryParameter["after"] = after;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Set a data item with a given key and value for the specified custom ID. The value is limited to a maximum size of 5 MB across all slots. The entire save state for a custom ID is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error.
     * @summary Set Custom Item
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {SetItemBody} [setItemBody] Add a data item to store for a custom ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setCustomItem: async (
      projectId: string,
      customId: string,
      setItemBody?: SetItemBody,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("setCustomItem", "projectId", projectId);
      // verify required parameter 'customId' is not null or undefined
      assertParamExists("setCustomItem", "customId", customId);
      const localVarPath =
        `/v1/data/projects/{projectId}/custom/{customId}/items`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"customId"}}`, encodeURIComponent(String(customId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        setItemBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Set up to 20 data items with key, value and optional writeLock against the custom ID. The values are limited to a maximum size of 5 MB across all slots for the custom ID. The entire save state for a custom ID is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error. The batch set operation is considered atomic and if any of the set key operation fails, the entire operation is failed. Error responses should identify the affected key operations that failed.
     * @summary Set Custom Item Batch
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {SetItemBatchBody} [setItemBatchBody] Set batch data items for a custom ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setCustomItemBatch: async (
      projectId: string,
      customId: string,
      setItemBatchBody?: SetItemBatchBody,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("setCustomItemBatch", "projectId", projectId);
      // verify required parameter 'customId' is not null or undefined
      assertParamExists("setCustomItemBatch", "customId", customId);
      const localVarPath =
        `/v1/data/projects/{projectId}/custom/{customId}/item-batch`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"customId"}}`, encodeURIComponent(String(customId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        setItemBatchBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Set a data item with a given key and value for the specified player. The value is limited to a maximum size of 5 MB across all slots. The entire save state for a player is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error.
     * @summary Set Player Item
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {SetItemBody} [setItemBody] Add a data item to store for a player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setItem: async (
      projectId: string,
      playerId: string,
      setItemBody?: SetItemBody,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("setItem", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("setItem", "playerId", playerId);
      const localVarPath =
        `/v1/data/projects/{projectId}/players/{playerId}/items`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication Client required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        setItemBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Set up to 20 data items with key, value and optional writeLock for the given player. The values are limited to a maximum size of 5 MB across all slots for the player. The entire save state for a player is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error. The batch set operation is considered atomic and if any of the set key operation fails, the entire operation is failed. Error responses should identify the affected key operations that failed.
     * @summary Set Player Item Batch
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {SetItemBatchBody} [setItemBatchBody] Set batch data items for a player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setItemBatch: async (
      projectId: string,
      playerId: string,
      setItemBatchBody?: SetItemBatchBody,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("setItemBatch", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("setItemBatch", "playerId", playerId);
      const localVarPath =
        `/v1/data/projects/{projectId}/players/{playerId}/item-batch`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication Client required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        setItemBatchBody,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DataApi - functional programming interface
 * @export
 */
export const DataApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DataApiAxiosParamCreator(configuration);
  return {
    /**
     * Deletes a data item by the specified key for the specified custom ID.
     * @summary Delete Custom Item
     * @param {string} key Item key.
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {string} [writeLock] Enforces conflict checking when deleting an existing data item. Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteCustomItem(
      key: string,
      projectId: string,
      customId: string,
      writeLock?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteCustomItem(
          key,
          projectId,
          customId,
          writeLock,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Deletes all data associated with a given custom ID.
     * @summary Delete Custom Items
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteCustomItems(
      projectId: string,
      customId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteCustomItems(
          projectId,
          customId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Deletes a data item by the specified key for the given player.
     * @summary Delete Player Item
     * @param {string} key Item key.
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} [writeLock] Enforces conflict checking when deleting an existing data item. Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteItem(
      key: string,
      projectId: string,
      playerId: string,
      writeLock?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItem(
        key,
        projectId,
        playerId,
        writeLock,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Deletes all data associated with a given player.
     * @summary Delete Player Items
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteItems(
      projectId: string,
      playerId: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItems(
        projectId,
        playerId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Retrieves save data values for all keys specified, ordered alphabetically in pages of 20. If no keys are supplied then returns all keys, ordered alphabetically in pages of 20.
     * @summary Get Custom Items
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {Array<string>} [keys] The keys to retrieve, in exploded form style, e.g. &#x60;keys&#x3D;KEY1&amp;keys&#x3D;KEY2&amp;keys&#x3D;KEY3&#x60;.
     * @param {string} [after] The key after which to retrieve the next page of keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCustomItems(
      projectId: string,
      customId: string,
      keys?: Array<string>,
      after?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetItemsResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomItems(
        projectId,
        customId,
        keys,
        after,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Gets a paged list of keys for the given custom ID, ordered alphabetically in pages of 100.
     * @summary Get Custom Keys
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {string} [after] Returns the page of results after the key specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCustomKeys(
      projectId: string,
      customId: string,
      after?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetKeysResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomKeys(
        projectId,
        customId,
        after,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Retrieves save data values for all keys specified, ordered alphabetically in pages of 20. If no keys are supplied then returns all keys, ordered alphabetically in pages of 20.
     * @summary Get Player Items
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {Array<string>} [keys] The keys to retrieve, in exploded form style, e.g. &#x60;keys&#x3D;KEY1&amp;keys&#x3D;KEY2&amp;keys&#x3D;KEY3&#x60;.
     * @param {string} [after] The key after which to retrieve the next page of keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getItems(
      projectId: string,
      playerId: string,
      keys?: Array<string>,
      after?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetItemsResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getItems(
        projectId,
        playerId,
        keys,
        after,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Gets a paged list of keys for the given player, ordered alphabetically in pages of 100.
     * @summary Get Player Keys
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} [after] Returns the page of results after the key specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getKeys(
      projectId: string,
      playerId: string,
      after?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<GetKeysResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getKeys(
        projectId,
        playerId,
        after,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Set a data item with a given key and value for the specified custom ID. The value is limited to a maximum size of 5 MB across all slots. The entire save state for a custom ID is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error.
     * @summary Set Custom Item
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {SetItemBody} [setItemBody] Add a data item to store for a custom ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setCustomItem(
      projectId: string,
      customId: string,
      setItemBody?: SetItemBody,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SetItemResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setCustomItem(
        projectId,
        customId,
        setItemBody,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Set up to 20 data items with key, value and optional writeLock against the custom ID. The values are limited to a maximum size of 5 MB across all slots for the custom ID. The entire save state for a custom ID is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error. The batch set operation is considered atomic and if any of the set key operation fails, the entire operation is failed. Error responses should identify the affected key operations that failed.
     * @summary Set Custom Item Batch
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {SetItemBatchBody} [setItemBatchBody] Set batch data items for a custom ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setCustomItemBatch(
      projectId: string,
      customId: string,
      setItemBatchBody?: SetItemBatchBody,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SetItemBatchResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.setCustomItemBatch(
          projectId,
          customId,
          setItemBatchBody,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Set a data item with a given key and value for the specified player. The value is limited to a maximum size of 5 MB across all slots. The entire save state for a player is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error.
     * @summary Set Player Item
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {SetItemBody} [setItemBody] Add a data item to store for a player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setItem(
      projectId: string,
      playerId: string,
      setItemBody?: SetItemBody,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SetItemResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setItem(
        projectId,
        playerId,
        setItemBody,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Set up to 20 data items with key, value and optional writeLock for the given player. The values are limited to a maximum size of 5 MB across all slots for the player. The entire save state for a player is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error. The batch set operation is considered atomic and if any of the set key operation fails, the entire operation is failed. Error responses should identify the affected key operations that failed.
     * @summary Set Player Item Batch
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {SetItemBatchBody} [setItemBatchBody] Set batch data items for a player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setItemBatch(
      projectId: string,
      playerId: string,
      setItemBatchBody?: SetItemBatchBody,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<SetItemBatchResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setItemBatch(
        projectId,
        playerId,
        setItemBatchBody,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * DataApi - factory interface
 * @export
 */
export const DataApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = DataApiFp(configuration);
  return {
    /**
     * Deletes a data item by the specified key for the specified custom ID.
     * @summary Delete Custom Item
     * @param {string} key Item key.
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {string} [writeLock] Enforces conflict checking when deleting an existing data item. Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCustomItem(
      key: string,
      projectId: string,
      customId: string,
      writeLock?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteCustomItem(key, projectId, customId, writeLock, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deletes all data associated with a given custom ID.
     * @summary Delete Custom Items
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCustomItems(
      projectId: string,
      customId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteCustomItems(projectId, customId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deletes a data item by the specified key for the given player.
     * @summary Delete Player Item
     * @param {string} key Item key.
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} [writeLock] Enforces conflict checking when deleting an existing data item. Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteItem(
      key: string,
      projectId: string,
      playerId: string,
      writeLock?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteItem(key, projectId, playerId, writeLock, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deletes all data associated with a given player.
     * @summary Delete Player Items
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteItems(
      projectId: string,
      playerId: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteItems(projectId, playerId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves save data values for all keys specified, ordered alphabetically in pages of 20. If no keys are supplied then returns all keys, ordered alphabetically in pages of 20.
     * @summary Get Custom Items
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {Array<string>} [keys] The keys to retrieve, in exploded form style, e.g. &#x60;keys&#x3D;KEY1&amp;keys&#x3D;KEY2&amp;keys&#x3D;KEY3&#x60;.
     * @param {string} [after] The key after which to retrieve the next page of keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCustomItems(
      projectId: string,
      customId: string,
      keys?: Array<string>,
      after?: string,
      options?: any
    ): AxiosPromise<GetItemsResponse> {
      return localVarFp
        .getCustomItems(projectId, customId, keys, after, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Gets a paged list of keys for the given custom ID, ordered alphabetically in pages of 100.
     * @summary Get Custom Keys
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {string} [after] Returns the page of results after the key specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCustomKeys(
      projectId: string,
      customId: string,
      after?: string,
      options?: any
    ): AxiosPromise<GetKeysResponse> {
      return localVarFp
        .getCustomKeys(projectId, customId, after, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves save data values for all keys specified, ordered alphabetically in pages of 20. If no keys are supplied then returns all keys, ordered alphabetically in pages of 20.
     * @summary Get Player Items
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {Array<string>} [keys] The keys to retrieve, in exploded form style, e.g. &#x60;keys&#x3D;KEY1&amp;keys&#x3D;KEY2&amp;keys&#x3D;KEY3&#x60;.
     * @param {string} [after] The key after which to retrieve the next page of keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getItems(
      projectId: string,
      playerId: string,
      keys?: Array<string>,
      after?: string,
      options?: any
    ): AxiosPromise<GetItemsResponse> {
      return localVarFp
        .getItems(projectId, playerId, keys, after, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Gets a paged list of keys for the given player, ordered alphabetically in pages of 100.
     * @summary Get Player Keys
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} [after] Returns the page of results after the key specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getKeys(
      projectId: string,
      playerId: string,
      after?: string,
      options?: any
    ): AxiosPromise<GetKeysResponse> {
      return localVarFp
        .getKeys(projectId, playerId, after, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Set a data item with a given key and value for the specified custom ID. The value is limited to a maximum size of 5 MB across all slots. The entire save state for a custom ID is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error.
     * @summary Set Custom Item
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {SetItemBody} [setItemBody] Add a data item to store for a custom ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setCustomItem(
      projectId: string,
      customId: string,
      setItemBody?: SetItemBody,
      options?: any
    ): AxiosPromise<SetItemResponse> {
      return localVarFp
        .setCustomItem(projectId, customId, setItemBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Set up to 20 data items with key, value and optional writeLock against the custom ID. The values are limited to a maximum size of 5 MB across all slots for the custom ID. The entire save state for a custom ID is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error. The batch set operation is considered atomic and if any of the set key operation fails, the entire operation is failed. Error responses should identify the affected key operations that failed.
     * @summary Set Custom Item Batch
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {SetItemBatchBody} [setItemBatchBody] Set batch data items for a custom ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setCustomItemBatch(
      projectId: string,
      customId: string,
      setItemBatchBody?: SetItemBatchBody,
      options?: any
    ): AxiosPromise<SetItemBatchResponse> {
      return localVarFp
        .setCustomItemBatch(projectId, customId, setItemBatchBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Set a data item with a given key and value for the specified player. The value is limited to a maximum size of 5 MB across all slots. The entire save state for a player is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error.
     * @summary Set Player Item
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {SetItemBody} [setItemBody] Add a data item to store for a player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setItem(
      projectId: string,
      playerId: string,
      setItemBody?: SetItemBody,
      options?: any
    ): AxiosPromise<SetItemResponse> {
      return localVarFp
        .setItem(projectId, playerId, setItemBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Set up to 20 data items with key, value and optional writeLock for the given player. The values are limited to a maximum size of 5 MB across all slots for the player. The entire save state for a player is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error. The batch set operation is considered atomic and if any of the set key operation fails, the entire operation is failed. Error responses should identify the affected key operations that failed.
     * @summary Set Player Item Batch
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {SetItemBatchBody} [setItemBatchBody] Set batch data items for a player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setItemBatch(
      projectId: string,
      playerId: string,
      setItemBatchBody?: SetItemBatchBody,
      options?: any
    ): AxiosPromise<SetItemBatchResponse> {
      return localVarFp
        .setItemBatch(projectId, playerId, setItemBatchBody, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * DataApi - object-oriented interface
 * @export
 * @class DataApi
 * @extends {BaseAPI}
 */
export class DataApi extends BaseAPI {
  /**
   * Deletes a data item by the specified key for the specified custom ID.
   * @summary Delete Custom Item
   * @param {string} key Item key.
   * @param {string} projectId ID of the project.
   * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
   * @param {string} [writeLock] Enforces conflict checking when deleting an existing data item. Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public deleteCustomItem(
    key: string,
    projectId: string,
    customId: string,
    writeLock?: string,
    options?: AxiosRequestConfig
  ) {
    return DataApiFp(this.configuration)
      .deleteCustomItem(key, projectId, customId, writeLock, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes all data associated with a given custom ID.
   * @summary Delete Custom Items
   * @param {string} projectId ID of the project.
   * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public deleteCustomItems(
    projectId: string,
    customId: string,
    options?: AxiosRequestConfig
  ) {
    return DataApiFp(this.configuration)
      .deleteCustomItems(projectId, customId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes a data item by the specified key for the given player.
   * @summary Delete Player Item
   * @param {string} key Item key.
   * @param {string} projectId ID of the project.
   * @param {string} playerId The player ID supplied by the Authorization service.
   * @param {string} [writeLock] Enforces conflict checking when deleting an existing data item. Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public deleteItem(
    key: string,
    projectId: string,
    playerId: string,
    writeLock?: string,
    options?: AxiosRequestConfig
  ) {
    return DataApiFp(this.configuration)
      .deleteItem(key, projectId, playerId, writeLock, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes all data associated with a given player.
   * @summary Delete Player Items
   * @param {string} projectId ID of the project.
   * @param {string} playerId The player ID supplied by the Authorization service.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public deleteItems(
    projectId: string,
    playerId: string,
    options?: AxiosRequestConfig
  ) {
    return DataApiFp(this.configuration)
      .deleteItems(projectId, playerId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves save data values for all keys specified, ordered alphabetically in pages of 20. If no keys are supplied then returns all keys, ordered alphabetically in pages of 20.
   * @summary Get Custom Items
   * @param {string} projectId ID of the project.
   * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
   * @param {Array<string>} [keys] The keys to retrieve, in exploded form style, e.g. &#x60;keys&#x3D;KEY1&amp;keys&#x3D;KEY2&amp;keys&#x3D;KEY3&#x60;.
   * @param {string} [after] The key after which to retrieve the next page of keys.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public getCustomItems(
    projectId: string,
    customId: string,
    keys?: Array<string>,
    after?: string,
    options?: AxiosRequestConfig
  ) {
    return DataApiFp(this.configuration)
      .getCustomItems(projectId, customId, keys, after, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Gets a paged list of keys for the given custom ID, ordered alphabetically in pages of 100.
   * @summary Get Custom Keys
   * @param {string} projectId ID of the project.
   * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
   * @param {string} [after] Returns the page of results after the key specified.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public getCustomKeys(
    projectId: string,
    customId: string,
    after?: string,
    options?: AxiosRequestConfig
  ) {
    return DataApiFp(this.configuration)
      .getCustomKeys(projectId, customId, after, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves save data values for all keys specified, ordered alphabetically in pages of 20. If no keys are supplied then returns all keys, ordered alphabetically in pages of 20.
   * @summary Get Player Items
   * @param {string} projectId ID of the project.
   * @param {string} playerId The player ID supplied by the Authorization service.
   * @param {Array<string>} [keys] The keys to retrieve, in exploded form style, e.g. &#x60;keys&#x3D;KEY1&amp;keys&#x3D;KEY2&amp;keys&#x3D;KEY3&#x60;.
   * @param {string} [after] The key after which to retrieve the next page of keys.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public getItems(
    projectId: string,
    playerId: string,
    keys?: Array<string>,
    after?: string,
    options?: AxiosRequestConfig
  ) {
    return DataApiFp(this.configuration)
      .getItems(projectId, playerId, keys, after, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Gets a paged list of keys for the given player, ordered alphabetically in pages of 100.
   * @summary Get Player Keys
   * @param {string} projectId ID of the project.
   * @param {string} playerId The player ID supplied by the Authorization service.
   * @param {string} [after] Returns the page of results after the key specified.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public getKeys(
    projectId: string,
    playerId: string,
    after?: string,
    options?: AxiosRequestConfig
  ) {
    return DataApiFp(this.configuration)
      .getKeys(projectId, playerId, after, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Set a data item with a given key and value for the specified custom ID. The value is limited to a maximum size of 5 MB across all slots. The entire save state for a custom ID is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error.
   * @summary Set Custom Item
   * @param {string} projectId ID of the project.
   * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
   * @param {SetItemBody} [setItemBody] Add a data item to store for a custom ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public setCustomItem(
    projectId: string,
    customId: string,
    setItemBody?: SetItemBody,
    options?: AxiosRequestConfig
  ) {
    return DataApiFp(this.configuration)
      .setCustomItem(projectId, customId, setItemBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Set up to 20 data items with key, value and optional writeLock against the custom ID. The values are limited to a maximum size of 5 MB across all slots for the custom ID. The entire save state for a custom ID is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error. The batch set operation is considered atomic and if any of the set key operation fails, the entire operation is failed. Error responses should identify the affected key operations that failed.
   * @summary Set Custom Item Batch
   * @param {string} projectId ID of the project.
   * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
   * @param {SetItemBatchBody} [setItemBatchBody] Set batch data items for a custom ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public setCustomItemBatch(
    projectId: string,
    customId: string,
    setItemBatchBody?: SetItemBatchBody,
    options?: AxiosRequestConfig
  ) {
    return DataApiFp(this.configuration)
      .setCustomItemBatch(projectId, customId, setItemBatchBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Set a data item with a given key and value for the specified player. The value is limited to a maximum size of 5 MB across all slots. The entire save state for a player is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error.
   * @summary Set Player Item
   * @param {string} projectId ID of the project.
   * @param {string} playerId The player ID supplied by the Authorization service.
   * @param {SetItemBody} [setItemBody] Add a data item to store for a player.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public setItem(
    projectId: string,
    playerId: string,
    setItemBody?: SetItemBody,
    options?: AxiosRequestConfig
  ) {
    return DataApiFp(this.configuration)
      .setItem(projectId, playerId, setItemBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Set up to 20 data items with key, value and optional writeLock for the given player. The values are limited to a maximum size of 5 MB across all slots for the player. The entire save state for a player is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error. The batch set operation is considered atomic and if any of the set key operation fails, the entire operation is failed. Error responses should identify the affected key operations that failed.
   * @summary Set Player Item Batch
   * @param {string} projectId ID of the project.
   * @param {string} playerId The player ID supplied by the Authorization service.
   * @param {SetItemBatchBody} [setItemBatchBody] Set batch data items for a player.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public setItemBatch(
    projectId: string,
    playerId: string,
    setItemBatchBody?: SetItemBatchBody,
    options?: AxiosRequestConfig
  ) {
    return DataApiFp(this.configuration)
      .setItemBatch(projectId, playerId, setItemBatchBody, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
