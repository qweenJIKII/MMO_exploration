/* tslint:disable */
/* eslint-disable */
/**
 * Economy API
 * # Introduction   This document outlines the API specification for the Economy API.   The Economy service allows the game client to retrieve the game configuration details, perform transactions against the game configuration on the server and maintain a game client \"inventory\" and \"account\". ### Notes about the Beta version   During the Beta period, the information in this document is not guaranteed   to be up-to-date and may change without notice. # Concepts   ## Entities   Economy currently allows interaction with the following Entities:   - Currencies: An entity that when defined contains two parameters, Initial and Max. This dictates how much of this currency a game client is assigned on first interacting with the Economy system. The Max parameter will dictate how much of that currency the Player is allowed to have.     A game client can retrieve and modify their currency balance within the boundaries set on the config.   - Inventory Items: An entity that doesn\'t have any set parameters; it\'s intended use is to indicate the ownership or acquisition of an Item in game e.g. Sword and Shield.     A game client can add or remove an instance of a configured Inventory Item from their personal inventory.   - Virtual Purchases: A transactional entity with the intended use to facilitate a shop or trade feature. Allows the Player to \"buy\" any amount of Items/Currencies for any amount of the same. Only ever uses the previously defined Currencies or Inventory Items.     A game client can redeem a Virtual Purchase and their account will be updated with the \"Rewards\" if the \"Costs\" criteria is met.   The above entities also have an optional Custom Data parameter that can be populated with JSON data from the dashboard to allow bespoke data to be read by game clients.   ## Writelock   The WriteLock is an integer that is automatically incremented serverside whenever a request that changes the stored value of a game clients account or inventory.   The purpose of the WriteLock is to help prevent requests from the same or other game clients happening out-of-sync.   This parameter is optional, but when supplied with a request, will do a comparison with the stored WriteLock on the server, and on mismatch will return an error.   ## Rate Limits   The API has rate limiting in place. Request are limited on a per-player basis up to 60 requests per minute.   The API responds with a `429` HTTP status code if the rate limit is exceeded.   It will also respond with a `Retry-After` header to be used in conjunction with a client\'s retry logic.   The value is the number of seconds until a request for the given player will be accepted.
 *
 * The version of the OpenAPI document: 2.0-beta
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration";
import { RequiredError, RequestArgs } from "./base";
import { AxiosInstance, AxiosResponse } from "axios";

/**
 *
 * @export
 */
export const DUMMY_BASE_URL = "https://example.com";

/**
 *
 * @throws {RequiredError}
 * @export
 */
export const assertParamExists = function (
  functionName: string,
  paramName: string,
  paramValue: unknown
) {
  if (paramValue === null || paramValue === undefined) {
    throw new RequiredError(
      paramName,
      `Required parameter ${paramName} was null or undefined when calling ${functionName}.`
    );
  }
};

/**
 *
 * @export
 */
export const setApiKeyToObject = async function (
  object: any,
  keyParamName: string,
  configuration?: Configuration
) {
  if (configuration && configuration.apiKey) {
    const localVarApiKeyValue =
      typeof configuration.apiKey === "function"
        ? await configuration.apiKey(keyParamName)
        : await configuration.apiKey;
    object[keyParamName] = localVarApiKeyValue;
  }
};

/**
 *
 * @export
 */
export const setBasicAuthToObject = function (
  object: any,
  configuration?: Configuration
) {
  if (configuration && (configuration.username || configuration.password)) {
    object["auth"] = {
      username: configuration.username,
      password: configuration.password,
    };
  }
};

/**
 *
 * @export
 */
export const setBearerAuthToObject = async function (
  object: any,
  configuration?: Configuration
) {
  if (configuration && configuration.accessToken) {
    const accessToken =
      typeof configuration.accessToken === "function"
        ? await configuration.accessToken()
        : await configuration.accessToken;
    object["Authorization"] = "Bearer " + accessToken;
  }
};

/**
 *
 * @export
 */
export const setOAuthToObject = async function (
  object: any,
  name: string,
  scopes: string[],
  configuration?: Configuration
) {
  if (configuration && configuration.accessToken) {
    const localVarAccessTokenValue =
      typeof configuration.accessToken === "function"
        ? await configuration.accessToken(name, scopes)
        : await configuration.accessToken;
    object["Authorization"] = "Bearer " + localVarAccessTokenValue;
  }
};

/**
 *
 * @export
 */
export const setSearchParams = function (url: URL, ...objects: any[]) {
  const searchParams = new URLSearchParams(url.search);
  for (const object of objects) {
    for (const key in object) {
      if (Array.isArray(object[key])) {
        searchParams.delete(key);
        for (const item of object[key]) {
          searchParams.append(key, item);
        }
      } else {
        searchParams.set(key, object[key]);
      }
    }
  }
  url.search = searchParams.toString();
};

/**
 *
 * @export
 */
export const serializeDataIfNeeded = function (
  value: any,
  requestOptions: any,
  configuration?: Configuration
) {
  const nonString = typeof value !== "string";
  const needsSerialization =
    nonString && configuration && configuration.isJsonMime
      ? configuration.isJsonMime(requestOptions.headers["Content-Type"])
      : nonString;
  return needsSerialization
    ? JSON.stringify(value !== undefined ? value : {})
    : value || "";
};

/**
 *
 * @export
 */
export const toPathString = function (url: URL) {
  return url.pathname + url.search + url.hash;
};

/**
 *
 * @export
 */
export const createRequestFunction = function (
  axiosArgs: RequestArgs,
  globalAxios: AxiosInstance,
  BASE_PATH: string,
  configuration?: Configuration
) {
  return <T = unknown, R = AxiosResponse<T>>(
    axios: AxiosInstance = globalAxios,
    basePath: string = BASE_PATH
  ) => {
    const axiosRequestArgs = {
      ...axiosArgs.options,
      url: (configuration?.basePath || basePath) + axiosArgs.url,
    };
    return axios.request<T, R>(axiosRequestArgs);
  };
};
