/* tslint:disable */
/* eslint-disable */
/**
 * Economy API
 * # Introduction   This document outlines the API specification for the Economy API.   The Economy service allows the game client to retrieve the game configuration details, perform transactions against the game configuration on the server and maintain a game client \"inventory\" and \"account\". ### Notes about the Beta version   During the Beta period, the information in this document is not guaranteed   to be up-to-date and may change without notice. # Concepts   ## Entities   Economy currently allows interaction with the following Entities:   - Currencies: An entity that when defined contains two parameters, Initial and Max. This dictates how much of this currency a game client is assigned on first interacting with the Economy system. The Max parameter will dictate how much of that currency the Player is allowed to have.     A game client can retrieve and modify their currency balance within the boundaries set on the config.   - Inventory Items: An entity that doesn\'t have any set parameters; it\'s intended use is to indicate the ownership or acquisition of an Item in game e.g. Sword and Shield.     A game client can add or remove an instance of a configured Inventory Item from their personal inventory.   - Virtual Purchases: A transactional entity with the intended use to facilitate a shop or trade feature. Allows the Player to \"buy\" any amount of Items/Currencies for any amount of the same. Only ever uses the previously defined Currencies or Inventory Items.     A game client can redeem a Virtual Purchase and their account will be updated with the \"Rewards\" if the \"Costs\" criteria is met.   The above entities also have an optional Custom Data parameter that can be populated with JSON data from the dashboard to allow bespoke data to be read by game clients.   ## Writelock   The WriteLock is an integer that is automatically incremented serverside whenever a request that changes the stored value of a game clients account or inventory.   The purpose of the WriteLock is to help prevent requests from the same or other game clients happening out-of-sync.   This parameter is optional, but when supplied with a request, will do a comparison with the stored WriteLock on the server, and on mismatch will return an error.   ## Rate Limits   The API has rate limiting in place. Request are limited on a per-player basis up to 60 requests per minute.   The API responds with a `429` HTTP status code if the rate limit is exceeded.   It will also respond with a `Retry-After` header to be used in conjunction with a client\'s retry logic.   The value is the number of seconds until a request for the given player will be accepted.
 *
 * The version of the OpenAPI document: 2.0-beta
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration";
import globalAxios, {
  AxiosPromise,
  AxiosInstance,
  AxiosRequestConfig,
} from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from "./base";

/**
 *
 * @export
 * @interface AddInventoryRequest
 */
export interface AddInventoryRequest {
  /**
   * Resource ID of the config Inventory Item.
   * @type {string}
   * @memberof AddInventoryRequest
   */
  inventoryItemId: string;
  /**
   * Players inventory item ID for the item being created. If not given ID will be automatically generated. An ID must be unique for a player.
   * @type {string}
   * @memberof AddInventoryRequest
   */
  playersInventoryItemId?: string;
  /**
   * Instance data to be saved against the new inventory item. Max size when serialized 5kb.
   * @type {object}
   * @memberof AddInventoryRequest
   */
  instanceData?: object | null;
}
/**
 * Referenced from - https://tools.ietf.org/html/rfc7807#page-3 Consumers MUST use the \'type\' string as the primary identifier for the problem type; the \'title\' string is advisory and included only for users who are not aware of the semantics of the URI and do not have the ability to discover them (e.g., offline log analysis). Consumers SHOULD NOT automatically dereference the type URI. The \"status\" member, if present, is only advisory; it conveys the HTTP status code used for the convenience of the consumer. Generators MUST use the same status code in the actual HTTP response, to assure that generic HTTP software that does not understand this format still behaves correctly.  See Section 5 for further caveats regarding its use. Consumers can use the status member to determine what the original status code used by the generator was, in cases where it has been changed (e.g., by an intermediary or cache), and when message bodies persist without HTTP information.  Generic HTTP software will still use the HTTP status code. The \"detail\" member, if present, ought to focus on helping the client correct the problem, rather than giving debugging information.
 * @export
 * @interface BasicErrorResponse
 */
export interface BasicErrorResponse {
  /**
   * A URI reference [RFC3986] that identifies the problem type. This specification encourages that, when dereferenced, it provide human-readable documentation for the problem type (e.g., using HTML [W3C.REC-html5-20141028]). When this member is not present, its value is assumed to be \"about:blank\".
   * @type {string}
   * @memberof BasicErrorResponse
   */
  type: string;
  /**
   * A short, human-readable summary of the problem type. It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization (e.g., using proactive content negotiation; see [RFC7231], Section 3.4).
   * @type {string}
   * @memberof BasicErrorResponse
   */
  title?: string;
  /**
   * The HTTP status code ([RFC7231], Section 6) generated by the origin server for this occurrence of the problem.
   * @type {number}
   * @memberof BasicErrorResponse
   */
  status?: number;
  /**
   * Service specific error code
   * @type {number}
   * @memberof BasicErrorResponse
   */
  code?: number;
  /**
   * A human-readable explanation specific to this occurrence of the problem.
   * @type {string}
   * @memberof BasicErrorResponse
   */
  detail?: string;
  /**
   * A URI reference that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
   * @type {string}
   * @memberof BasicErrorResponse
   */
  instance?: string;
  /**
   * Machine readable service specific errors.
   * @type {Array<object>}
   * @memberof BasicErrorResponse
   */
  details?: Array<object>;
}
/**
 *
 * @export
 * @interface CurrencyBalanceRequest
 */
export interface CurrencyBalanceRequest {
  /**
   * Resource ID for the currency.
   * @type {string}
   * @memberof CurrencyBalanceRequest
   */
  currencyId: string;
  /**
   * The player\'s balance.
   * @type {number}
   * @memberof CurrencyBalanceRequest
   */
  balance: number;
  /**
   * The write lock for the currency balance.
   * @type {string}
   * @memberof CurrencyBalanceRequest
   */
  writeLock?: string;
}
/**
 *
 * @export
 * @interface CurrencyBalanceResponse
 */
export interface CurrencyBalanceResponse {
  /**
   * Resource ID for the currency.
   * @type {string}
   * @memberof CurrencyBalanceResponse
   */
  currencyId: string;
  /**
   * The player\'s balance.
   * @type {number}
   * @memberof CurrencyBalanceResponse
   */
  balance: number;
  /**
   * The write lock for the currency balance.
   * @type {string}
   * @memberof CurrencyBalanceResponse
   */
  writeLock: string;
  /**
   *
   * @type {ModifiedMetadata}
   * @memberof CurrencyBalanceResponse
   */
  created: ModifiedMetadata;
  /**
   *
   * @type {ModifiedMetadata}
   * @memberof CurrencyBalanceResponse
   */
  modified: ModifiedMetadata;
}
/**
 *
 * @export
 * @interface CurrencyExchangeItem
 */
export interface CurrencyExchangeItem {
  /**
   * ID of the currency.
   * @type {string}
   * @memberof CurrencyExchangeItem
   */
  id: string;
  /**
   * Amount of currency added or deducted.
   * @type {number}
   * @memberof CurrencyExchangeItem
   */
  amount: number;
}
/**
 *
 * @export
 * @interface CurrencyModifyBalanceRequest
 */
export interface CurrencyModifyBalanceRequest {
  /**
   * Resource ID for the currency.
   * @type {string}
   * @memberof CurrencyModifyBalanceRequest
   */
  currencyId: string;
  /**
   * The value to increment or decrement by. Zero is allowed but will result in no change to the currency balance.
   * @type {number}
   * @memberof CurrencyModifyBalanceRequest
   */
  amount: number;
  /**
   * The write lock for the currency balance.
   * @type {string}
   * @memberof CurrencyModifyBalanceRequest
   */
  writeLock?: string;
}
/**
 * An error response sent back upon currency balance conflict
 * @export
 * @interface ErrorResponseConflictCurrencyBalance
 */
export interface ErrorResponseConflictCurrencyBalance {
  /**
   *
   * @type {string}
   * @memberof ErrorResponseConflictCurrencyBalance
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof ErrorResponseConflictCurrencyBalance
   */
  title: string;
  /**
   * e.g. 409
   * @type {number}
   * @memberof ErrorResponseConflictCurrencyBalance
   */
  status: number;
  /**
   * e.g. 10204
   * @type {number}
   * @memberof ErrorResponseConflictCurrencyBalance
   */
  code: number;
  /**
   *
   * @type {string}
   * @memberof ErrorResponseConflictCurrencyBalance
   */
  detail: string;
  /**
   *
   * @type {string}
   * @memberof ErrorResponseConflictCurrencyBalance
   */
  instance?: string;
  /**
   *
   * @type {ErrorResponseConflictCurrencyBalanceData}
   * @memberof ErrorResponseConflictCurrencyBalance
   */
  data: ErrorResponseConflictCurrencyBalanceData;
}
/**
 *
 * @export
 * @interface ErrorResponseConflictCurrencyBalanceData
 */
export interface ErrorResponseConflictCurrencyBalanceData {
  /**
   *
   * @type {CurrencyBalanceRequest}
   * @memberof ErrorResponseConflictCurrencyBalanceData
   */
  attempted: CurrencyBalanceRequest;
  /**
   *
   * @type {CurrencyBalanceResponse}
   * @memberof ErrorResponseConflictCurrencyBalanceData
   */
  existing: CurrencyBalanceResponse | null;
}
/**
 * An error response sent back upon player inventory item conflict
 * @export
 * @interface ErrorResponseConflictInventory
 */
export interface ErrorResponseConflictInventory {
  /**
   *
   * @type {string}
   * @memberof ErrorResponseConflictInventory
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof ErrorResponseConflictInventory
   */
  title: string;
  /**
   * e.g 409
   * @type {number}
   * @memberof ErrorResponseConflictInventory
   */
  status: number;
  /**
   * e.g. 10204
   * @type {number}
   * @memberof ErrorResponseConflictInventory
   */
  code: number;
  /**
   *
   * @type {string}
   * @memberof ErrorResponseConflictInventory
   */
  detail: string;
  /**
   *
   * @type {string}
   * @memberof ErrorResponseConflictInventory
   */
  instance?: string;
  /**
   *
   * @type {ErrorResponseConflictInventoryUpdateData}
   * @memberof ErrorResponseConflictInventory
   */
  data: ErrorResponseConflictInventoryUpdateData;
}
/**
 * An error response sent back upon player inventory item conflict
 * @export
 * @interface ErrorResponseConflictInventoryDelete
 */
export interface ErrorResponseConflictInventoryDelete {
  /**
   *
   * @type {string}
   * @memberof ErrorResponseConflictInventoryDelete
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof ErrorResponseConflictInventoryDelete
   */
  title: string;
  /**
   * e.g 409
   * @type {number}
   * @memberof ErrorResponseConflictInventoryDelete
   */
  status: number;
  /**
   * e.g. 10204
   * @type {number}
   * @memberof ErrorResponseConflictInventoryDelete
   */
  code: number;
  /**
   *
   * @type {string}
   * @memberof ErrorResponseConflictInventoryDelete
   */
  detail: string;
  /**
   *
   * @type {string}
   * @memberof ErrorResponseConflictInventoryDelete
   */
  instance?: string;
  /**
   *
   * @type {ErrorResponseConflictInventoryDeleteData}
   * @memberof ErrorResponseConflictInventoryDelete
   */
  data: ErrorResponseConflictInventoryDeleteData;
}
/**
 *
 * @export
 * @interface ErrorResponseConflictInventoryDeleteData
 */
export interface ErrorResponseConflictInventoryDeleteData {
  /**
   *
   * @type {InventoryDeleteRequest}
   * @memberof ErrorResponseConflictInventoryDeleteData
   */
  attempted: InventoryDeleteRequest;
  /**
   *
   * @type {InventoryResponse}
   * @memberof ErrorResponseConflictInventoryDeleteData
   */
  existing: InventoryResponse;
}
/**
 * An error response sent back upon player inventory item conflict
 * @export
 * @interface ErrorResponseConflictInventoryUpdate
 */
export interface ErrorResponseConflictInventoryUpdate {
  /**
   *
   * @type {string}
   * @memberof ErrorResponseConflictInventoryUpdate
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof ErrorResponseConflictInventoryUpdate
   */
  title: string;
  /**
   * e.g 409
   * @type {number}
   * @memberof ErrorResponseConflictInventoryUpdate
   */
  status: number;
  /**
   * e.g. 10204
   * @type {number}
   * @memberof ErrorResponseConflictInventoryUpdate
   */
  code: number;
  /**
   *
   * @type {string}
   * @memberof ErrorResponseConflictInventoryUpdate
   */
  detail: string;
  /**
   *
   * @type {string}
   * @memberof ErrorResponseConflictInventoryUpdate
   */
  instance?: string;
  /**
   *
   * @type {ErrorResponseConflictInventoryUpdateData}
   * @memberof ErrorResponseConflictInventoryUpdate
   */
  data: ErrorResponseConflictInventoryUpdateData;
}
/**
 *
 * @export
 * @interface ErrorResponseConflictInventoryUpdateData
 */
export interface ErrorResponseConflictInventoryUpdateData {
  /**
   *
   * @type {AddInventoryRequest}
   * @memberof ErrorResponseConflictInventoryUpdateData
   */
  attempted: AddInventoryRequest;
  /**
   *
   * @type {InventoryResponse}
   * @memberof ErrorResponseConflictInventoryUpdateData
   */
  existing: InventoryResponse | null;
}
/**
 * An error response sent back upon a redeem apple app store purchase.
 * @export
 * @interface ErrorResponsePurchaseAppleappstoreFailed
 */
export interface ErrorResponsePurchaseAppleappstoreFailed {
  /**
   *
   * @type {string}
   * @memberof ErrorResponsePurchaseAppleappstoreFailed
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof ErrorResponsePurchaseAppleappstoreFailed
   */
  title: string;
  /**
   * e.g 409
   * @type {number}
   * @memberof ErrorResponsePurchaseAppleappstoreFailed
   */
  status: number;
  /**
   * e.g. 10204
   * @type {number}
   * @memberof ErrorResponsePurchaseAppleappstoreFailed
   */
  code: number;
  /**
   *
   * @type {string}
   * @memberof ErrorResponsePurchaseAppleappstoreFailed
   */
  detail: string;
  /**
   *
   * @type {string}
   * @memberof ErrorResponsePurchaseAppleappstoreFailed
   */
  instance?: string;
  /**
   *
   * @type {PlayerPurchaseAppleappstoreResponse}
   * @memberof ErrorResponsePurchaseAppleappstoreFailed
   */
  data: PlayerPurchaseAppleappstoreResponse;
}
/**
 * An error response sent back upon a redeem google play purchase.
 * @export
 * @interface ErrorResponsePurchaseGoogleplaystoreFailed
 */
export interface ErrorResponsePurchaseGoogleplaystoreFailed {
  /**
   *
   * @type {string}
   * @memberof ErrorResponsePurchaseGoogleplaystoreFailed
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof ErrorResponsePurchaseGoogleplaystoreFailed
   */
  title: string;
  /**
   * e.g 409
   * @type {number}
   * @memberof ErrorResponsePurchaseGoogleplaystoreFailed
   */
  status: number;
  /**
   * e.g. 10204
   * @type {number}
   * @memberof ErrorResponsePurchaseGoogleplaystoreFailed
   */
  code: number;
  /**
   *
   * @type {string}
   * @memberof ErrorResponsePurchaseGoogleplaystoreFailed
   */
  detail: string;
  /**
   *
   * @type {string}
   * @memberof ErrorResponsePurchaseGoogleplaystoreFailed
   */
  instance?: string;
  /**
   *
   * @type {PlayerPurchaseGoogleplaystoreResponse}
   * @memberof ErrorResponsePurchaseGoogleplaystoreFailed
   */
  data: PlayerPurchaseGoogleplaystoreResponse;
}
/**
 *
 * @export
 * @interface InventoryDeleteRequest
 */
export interface InventoryDeleteRequest {
  /**
   * The write lock for the inventory instance.
   * @type {string}
   * @memberof InventoryDeleteRequest
   */
  writeLock?: string;
}
/**
 *
 * @export
 * @interface InventoryExchangeItem
 */
export interface InventoryExchangeItem {
  /**
   * ID of the inventory item.
   * @type {string}
   * @memberof InventoryExchangeItem
   */
  id: string;
  /**
   * Number of player inventory items.
   * @type {number}
   * @memberof InventoryExchangeItem
   */
  amount: number;
  /**
   * Players inventory item IDs of the players items to be added or removed.
   * @type {Set<string>}
   * @memberof InventoryExchangeItem
   */
  playersInventoryItemIds: Set<string>;
}
/**
 *
 * @export
 * @interface InventoryRequestUpdate
 */
export interface InventoryRequestUpdate {
  /**
   * Instance data to be saved against the new inventory item. Max size when serialized 5kb.
   * @type {object}
   * @memberof InventoryRequestUpdate
   */
  instanceData: object | null;
  /**
   * The write lock for the inventory instance.
   * @type {string}
   * @memberof InventoryRequestUpdate
   */
  writeLock?: string;
}
/**
 *
 * @export
 * @interface InventoryResponse
 */
export interface InventoryResponse {
  /**
   * ID of the player\'s inventory item.
   * @type {string}
   * @memberof InventoryResponse
   */
  playersInventoryItemId: string;
  /**
   * Resource ID of the config Inventory Item associated with this instance.
   * @type {string}
   * @memberof InventoryResponse
   */
  inventoryItemId: string;
  /**
   * Instance data. Max size when serialized 5kb.
   * @type {object}
   * @memberof InventoryResponse
   */
  instanceData?: object | null;
  /**
   * The write lock for the inventory instance.
   * @type {string}
   * @memberof InventoryResponse
   */
  writeLock: string;
  /**
   *
   * @type {ModifiedMetadata}
   * @memberof InventoryResponse
   */
  created: ModifiedMetadata;
  /**
   *
   * @type {ModifiedMetadata}
   * @memberof InventoryResponse
   */
  modified: ModifiedMetadata;
}
/**
 *
 * @export
 * @interface ModifiedMetadata
 */
export interface ModifiedMetadata {
  /**
   * Date time in ISO 8601 format. Null if there is no associated value.
   * @type {string}
   * @memberof ModifiedMetadata
   */
  date: string | null;
}
/**
 *
 * @export
 * @interface PlayerCurrencyBalanceResponse
 */
export interface PlayerCurrencyBalanceResponse {
  /**
   * List of Currency Balances.
   * @type {Array<CurrencyBalanceResponse>}
   * @memberof PlayerCurrencyBalanceResponse
   */
  results: Array<CurrencyBalanceResponse>;
  /**
   *
   * @type {PlayerCurrencyBalanceResponseLinks}
   * @memberof PlayerCurrencyBalanceResponse
   */
  links: PlayerCurrencyBalanceResponseLinks;
}
/**
 *
 * @export
 * @interface PlayerCurrencyBalanceResponseLinks
 */
export interface PlayerCurrencyBalanceResponseLinks {
  /**
   * Contains the URL path for requesting the next page of results. This value is null when there are no pages remaining.
   * @type {string}
   * @memberof PlayerCurrencyBalanceResponseLinks
   */
  next: string | null;
}
/**
 *
 * @export
 * @interface PlayerInventoryResponse
 */
export interface PlayerInventoryResponse {
  /**
   * List of Players Inventory Items.
   * @type {Array<InventoryResponse>}
   * @memberof PlayerInventoryResponse
   */
  results: Array<InventoryResponse>;
  /**
   *
   * @type {PlayerCurrencyBalanceResponseLinks}
   * @memberof PlayerInventoryResponse
   */
  links: PlayerCurrencyBalanceResponseLinks;
}
/**
 *
 * @export
 * @interface PlayerPurchaseAppleappstoreRequest
 */
export interface PlayerPurchaseAppleappstoreRequest {
  /**
   * ID of the purchase.
   * @type {string}
   * @memberof PlayerPurchaseAppleappstoreRequest
   */
  id: string;
  /**
   * Receipt data returned from the App Store as a result of a successful purchase. This should be base64 encoded.
   * @type {string}
   * @memberof PlayerPurchaseAppleappstoreRequest
   */
  receipt: string;
  /**
   * The cost of the purchase as an integer in the minor currency format, e.g. $1.99 USD would be 199
   * @type {number}
   * @memberof PlayerPurchaseAppleappstoreRequest
   */
  localCost: number;
  /**
   * The ISO-4217 currency code with which the player purchased the IAP.
   * @type {string}
   * @memberof PlayerPurchaseAppleappstoreRequest
   */
  localCurrency: string;
}
/**
 *
 * @export
 * @interface PlayerPurchaseAppleappstoreResponse
 */
export interface PlayerPurchaseAppleappstoreResponse {
  /**
   *
   * @type {PlayerPurchaseAppleappstoreResponseVerification}
   * @memberof PlayerPurchaseAppleappstoreResponse
   */
  verification: PlayerPurchaseAppleappstoreResponseVerification;
  /**
   *
   * @type {PlayerPurchaseVirtualResponseRewards}
   * @memberof PlayerPurchaseAppleappstoreResponse
   */
  rewards: PlayerPurchaseVirtualResponseRewards;
}
/**
 *
 * @export
 * @interface PlayerPurchaseAppleappstoreResponseVerification
 */
export interface PlayerPurchaseAppleappstoreResponseVerification {
  /**
   * Status of the receipt verification. VALID: The purchase was valid. VALID_NOT_REDEEMED: The purchase was valid but seen before, but had not yet been redeemed. INVALID_ALREADY_REDEEMED: The purchase has already been redeemed. INVALID_VERIFICATION_FAILED: The receipt verification Service returned that the receipt data was not valid. INVALID_ANOTHER_PLAYER: The receipt has previously been used by a different player and validated. INVALID_CONFIGURATION: The service configuration is invalid, further information in the details section of the response. INVALID_PRODUCT_ID_MISMATCH: The purchase configuration store product identifier does not match the one in the receipt.
   * @type {string}
   * @memberof PlayerPurchaseAppleappstoreResponseVerification
   */
  status: PlayerPurchaseAppleappstoreResponseVerificationStatusEnum;
  /**
   *
   * @type {PlayerPurchaseAppleappstoreResponseVerificationStore}
   * @memberof PlayerPurchaseAppleappstoreResponseVerification
   */
  store: PlayerPurchaseAppleappstoreResponseVerificationStore;
}

export const PlayerPurchaseAppleappstoreResponseVerificationStatusEnum = {
  Valid: "VALID",
  ValidNotRedeemed: "VALID_NOT_REDEEMED",
  InvalidAlreadyRedeemed: "INVALID_ALREADY_REDEEMED",
  InvalidVerificationFailed: "INVALID_VERIFICATION_FAILED",
  InvalidAnotherPlayer: "INVALID_ANOTHER_PLAYER",
  InvalidConfiguration: "INVALID_CONFIGURATION",
  InvalidProductIdMismatch: "INVALID_PRODUCT_ID_MISMATCH",
} as const;

export type PlayerPurchaseAppleappstoreResponseVerificationStatusEnum =
  typeof PlayerPurchaseAppleappstoreResponseVerificationStatusEnum[keyof typeof PlayerPurchaseAppleappstoreResponseVerificationStatusEnum];

/**
 * Details from the receipt validation service.
 * @export
 * @interface PlayerPurchaseAppleappstoreResponseVerificationStore
 */
export interface PlayerPurchaseAppleappstoreResponseVerificationStore {
  /**
   * The status code sent back from the Apple App Store verification service.
   * @type {string}
   * @memberof PlayerPurchaseAppleappstoreResponseVerificationStore
   */
  code: string | null;
  /**
   * A textual description of the returned status code.
   * @type {string}
   * @memberof PlayerPurchaseAppleappstoreResponseVerificationStore
   */
  message: string | null;
  /**
   * The full response from the AppStore verification service as a JSON encoded string.
   * @type {string}
   * @memberof PlayerPurchaseAppleappstoreResponseVerificationStore
   */
  receipt: string | null;
}
/**
 *
 * @export
 * @interface PlayerPurchaseGoogleplaystoreRequest
 */
export interface PlayerPurchaseGoogleplaystoreRequest {
  /**
   * ID of the purchase.
   * @type {string}
   * @memberof PlayerPurchaseGoogleplaystoreRequest
   */
  id: string;
  /**
   * A JSON encoded string returned from a successful in app billing purchase.
   * @type {string}
   * @memberof PlayerPurchaseGoogleplaystoreRequest
   */
  purchaseData: string;
  /**
   * A signature of the PurchaseData returned from a successful in app billing purchase.
   * @type {string}
   * @memberof PlayerPurchaseGoogleplaystoreRequest
   */
  purchaseDataSignature: string;
  /**
   * The cost of the purchase as an integer in the minor currency format, e.g. $1.99 USD would be 199
   * @type {number}
   * @memberof PlayerPurchaseGoogleplaystoreRequest
   */
  localCost: number;
  /**
   * The ISO-4217 currency code with which the player purchased the IAP.
   * @type {string}
   * @memberof PlayerPurchaseGoogleplaystoreRequest
   */
  localCurrency: string;
}
/**
 *
 * @export
 * @interface PlayerPurchaseGoogleplaystoreResponse
 */
export interface PlayerPurchaseGoogleplaystoreResponse {
  /**
   *
   * @type {PlayerPurchaseGoogleplaystoreResponseVerification}
   * @memberof PlayerPurchaseGoogleplaystoreResponse
   */
  verification: PlayerPurchaseGoogleplaystoreResponseVerification;
  /**
   *
   * @type {PlayerPurchaseVirtualResponseRewards}
   * @memberof PlayerPurchaseGoogleplaystoreResponse
   */
  rewards: PlayerPurchaseVirtualResponseRewards;
}
/**
 *
 * @export
 * @interface PlayerPurchaseGoogleplaystoreResponseVerification
 */
export interface PlayerPurchaseGoogleplaystoreResponseVerification {
  /**
   * Status of the receipt verification. VALID: The purchase was valid. VALID_NOT_REDEEMED: The purchase was valid but seen before, but had not yet been redeemed. INVALID_ALREADY_REDEEMED: The purchase has already been redeemed. INVALID_VERIFICATION_FAILED: The receipt verification Service returned that the receipt data was not valid. INVALID_ANOTHER_PLAYER: The receipt has previously been used by a different player and validated. INVALID_CONFIGURATION: The service configuration is invalid, further information in the details section of the response. INVALID_PRODUCT_ID_MISMATCH: The purchase configuration store product identifier does not match the one in the receipt.
   * @type {string}
   * @memberof PlayerPurchaseGoogleplaystoreResponseVerification
   */
  status: PlayerPurchaseGoogleplaystoreResponseVerificationStatusEnum;
  /**
   *
   * @type {PlayerPurchaseGoogleplaystoreResponseVerificationStore}
   * @memberof PlayerPurchaseGoogleplaystoreResponseVerification
   */
  store: PlayerPurchaseGoogleplaystoreResponseVerificationStore;
}

export const PlayerPurchaseGoogleplaystoreResponseVerificationStatusEnum = {
  Valid: "VALID",
  ValidNotRedeemed: "VALID_NOT_REDEEMED",
  InvalidAlreadyRedeemed: "INVALID_ALREADY_REDEEMED",
  InvalidVerificationFailed: "INVALID_VERIFICATION_FAILED",
  InvalidAnotherPlayer: "INVALID_ANOTHER_PLAYER",
  InvalidConfiguration: "INVALID_CONFIGURATION",
  InvalidProductIdMismatch: "INVALID_PRODUCT_ID_MISMATCH",
} as const;

export type PlayerPurchaseGoogleplaystoreResponseVerificationStatusEnum =
  typeof PlayerPurchaseGoogleplaystoreResponseVerificationStatusEnum[keyof typeof PlayerPurchaseGoogleplaystoreResponseVerificationStatusEnum];

/**
 * Details from the receipt validation service.
 * @export
 * @interface PlayerPurchaseGoogleplaystoreResponseVerificationStore
 */
export interface PlayerPurchaseGoogleplaystoreResponseVerificationStore {
  /**
   * Receipt that was sent in the request
   * @type {string}
   * @memberof PlayerPurchaseGoogleplaystoreResponseVerificationStore
   */
  receipt?: string;
}
/**
 *
 * @export
 * @interface PlayerPurchaseVirtualRequest
 */
export interface PlayerPurchaseVirtualRequest {
  /**
   * ID of the purchase.
   * @type {string}
   * @memberof PlayerPurchaseVirtualRequest
   */
  id: string;
  /**
   * IDs of the player\'s inventory items that should be used for any item costs associated with the purchase.
   * @type {Set<string>}
   * @memberof PlayerPurchaseVirtualRequest
   */
  playersInventoryItemIds?: Set<string>;
}
/**
 *
 * @export
 * @interface PlayerPurchaseVirtualResponse
 */
export interface PlayerPurchaseVirtualResponse {
  /**
   *
   * @type {PlayerPurchaseVirtualResponseCosts}
   * @memberof PlayerPurchaseVirtualResponse
   */
  costs: PlayerPurchaseVirtualResponseCosts;
  /**
   *
   * @type {PlayerPurchaseVirtualResponseRewards}
   * @memberof PlayerPurchaseVirtualResponse
   */
  rewards: PlayerPurchaseVirtualResponseRewards;
}
/**
 * Costs of the purchase.
 * @export
 * @interface PlayerPurchaseVirtualResponseCosts
 */
export interface PlayerPurchaseVirtualResponseCosts {
  /**
   * Currency that was deducted in the purchase.
   * @type {Array<CurrencyExchangeItem>}
   * @memberof PlayerPurchaseVirtualResponseCosts
   */
  currency: Array<CurrencyExchangeItem>;
  /**
   * Inventory that was deducted in the purchase.
   * @type {Array<InventoryExchangeItem>}
   * @memberof PlayerPurchaseVirtualResponseCosts
   */
  inventory: Array<InventoryExchangeItem>;
}
/**
 * Rewards of the purchase.
 * @export
 * @interface PlayerPurchaseVirtualResponseRewards
 */
export interface PlayerPurchaseVirtualResponseRewards {
  /**
   * Currency that was credited in the purchase.
   * @type {Array<CurrencyExchangeItem>}
   * @memberof PlayerPurchaseVirtualResponseRewards
   */
  currency: Array<CurrencyExchangeItem>;
  /**
   * Inventory that was credited in the purchase.
   * @type {Array<InventoryExchangeItem>}
   * @memberof PlayerPurchaseVirtualResponseRewards
   */
  inventory: Array<InventoryExchangeItem>;
}
/**
 * Single error in the Validation Error Response.
 * @export
 * @interface ValidationErrorBody
 */
export interface ValidationErrorBody {
  /**
   *
   * @type {string}
   * @memberof ValidationErrorBody
   */
  field: string;
  /**
   *
   * @type {Array<string>}
   * @memberof ValidationErrorBody
   */
  messages: Array<string>;
}
/**
 * Validation error response when a value provided from the client does not pass validation on server
 * @export
 * @interface ValidationErrorResponse
 */
export interface ValidationErrorResponse {
  /**
   *
   * @type {string}
   * @memberof ValidationErrorResponse
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof ValidationErrorResponse
   */
  title: string;
  /**
   *
   * @type {number}
   * @memberof ValidationErrorResponse
   */
  status: number;
  /**
   *
   * @type {number}
   * @memberof ValidationErrorResponse
   */
  code: number;
  /**
   *
   * @type {string}
   * @memberof ValidationErrorResponse
   */
  detail: string;
  /**
   *
   * @type {string}
   * @memberof ValidationErrorResponse
   */
  instance?: string;
  /**
   *
   * @type {Array<ValidationErrorBody>}
   * @memberof ValidationErrorResponse
   */
  errors: Array<ValidationErrorBody>;
}

/**
 * CurrenciesApi - axios parameter creator
 * @export
 */
export const CurrenciesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Decrements a player\'s currency balance by a given value.
     * @summary Decrement Currency Balance
     * @param {string} projectId ID of the project
     * @param {string} playerId ID of the player
     * @param {string} currencyId
     * @param {string} [configAssignmentHash] Hash of the Remote Config assignment
     * @param {CurrencyModifyBalanceRequest} [currencyModifyBalanceRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    decrementPlayerCurrencyBalance: async (
      projectId: string,
      playerId: string,
      currencyId: string,
      configAssignmentHash?: string,
      currencyModifyBalanceRequest?: CurrencyModifyBalanceRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        "decrementPlayerCurrencyBalance",
        "projectId",
        projectId
      );
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("decrementPlayerCurrencyBalance", "playerId", playerId);
      // verify required parameter 'currencyId' is not null or undefined
      assertParamExists(
        "decrementPlayerCurrencyBalance",
        "currencyId",
        currencyId
      );
      const localVarPath =
        `/v2/projects/{projectId}/players/{playerId}/currencies/{currencyId}/decrement`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)))
          .replace(`{${"currencyId"}}`, encodeURIComponent(String(currencyId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication JWT required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (configAssignmentHash !== undefined) {
        localVarQueryParameter["configAssignmentHash"] = configAssignmentHash;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        currencyModifyBalanceRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of currency balances for a player. Results ordered by Currency ID ascending.
     * @summary Player Currency Balances
     * @param {string} projectId ID of the project
     * @param {string} playerId ID of the player
     * @param {string} [configAssignmentHash] Hash of the Remote Config assignment
     * @param {string} [after] The ID after which to retrieve the next page of balances.
     * @param {number} [limit] Number of items to be returned. Defaults to 20.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPlayerCurrencies: async (
      projectId: string,
      playerId: string,
      configAssignmentHash?: string,
      after?: string,
      limit?: number,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("getPlayerCurrencies", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("getPlayerCurrencies", "playerId", playerId);
      const localVarPath =
        `/v2/projects/{projectId}/players/{playerId}/currencies`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication JWT required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (configAssignmentHash !== undefined) {
        localVarQueryParameter["configAssignmentHash"] = configAssignmentHash;
      }

      if (after !== undefined) {
        localVarQueryParameter["after"] = after;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Increment a player\'s currency balance by a given value.
     * @summary Increment Currency Balance
     * @param {string} projectId ID of the project
     * @param {string} playerId ID of the player
     * @param {string} currencyId
     * @param {string} [configAssignmentHash] Hash of the Remote Config assignment
     * @param {CurrencyModifyBalanceRequest} [currencyModifyBalanceRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    incrementPlayerCurrencyBalance: async (
      projectId: string,
      playerId: string,
      currencyId: string,
      configAssignmentHash?: string,
      currencyModifyBalanceRequest?: CurrencyModifyBalanceRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists(
        "incrementPlayerCurrencyBalance",
        "projectId",
        projectId
      );
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("incrementPlayerCurrencyBalance", "playerId", playerId);
      // verify required parameter 'currencyId' is not null or undefined
      assertParamExists(
        "incrementPlayerCurrencyBalance",
        "currencyId",
        currencyId
      );
      const localVarPath =
        `/v2/projects/{projectId}/players/{playerId}/currencies/{currencyId}/increment`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)))
          .replace(`{${"currencyId"}}`, encodeURIComponent(String(currencyId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication JWT required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (configAssignmentHash !== undefined) {
        localVarQueryParameter["configAssignmentHash"] = configAssignmentHash;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        currencyModifyBalanceRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Set a player\'s currency balance.
     * @summary Set Currency Balance
     * @param {string} projectId ID of the project
     * @param {string} playerId ID of the player
     * @param {string} currencyId
     * @param {string} [configAssignmentHash] Hash of the Remote Config assignment
     * @param {CurrencyBalanceRequest} [currencyBalanceRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setPlayerCurrencyBalance: async (
      projectId: string,
      playerId: string,
      currencyId: string,
      configAssignmentHash?: string,
      currencyBalanceRequest?: CurrencyBalanceRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("setPlayerCurrencyBalance", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("setPlayerCurrencyBalance", "playerId", playerId);
      // verify required parameter 'currencyId' is not null or undefined
      assertParamExists("setPlayerCurrencyBalance", "currencyId", currencyId);
      const localVarPath =
        `/v2/projects/{projectId}/players/{playerId}/currencies/{currencyId}`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)))
          .replace(`{${"currencyId"}}`, encodeURIComponent(String(currencyId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication JWT required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (configAssignmentHash !== undefined) {
        localVarQueryParameter["configAssignmentHash"] = configAssignmentHash;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        currencyBalanceRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CurrenciesApi - functional programming interface
 * @export
 */
export const CurrenciesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    CurrenciesApiAxiosParamCreator(configuration);
  return {
    /**
     * Decrements a player\'s currency balance by a given value.
     * @summary Decrement Currency Balance
     * @param {string} projectId ID of the project
     * @param {string} playerId ID of the player
     * @param {string} currencyId
     * @param {string} [configAssignmentHash] Hash of the Remote Config assignment
     * @param {CurrencyModifyBalanceRequest} [currencyModifyBalanceRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async decrementPlayerCurrencyBalance(
      projectId: string,
      playerId: string,
      currencyId: string,
      configAssignmentHash?: string,
      currencyModifyBalanceRequest?: CurrencyModifyBalanceRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CurrencyBalanceResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.decrementPlayerCurrencyBalance(
          projectId,
          playerId,
          currencyId,
          configAssignmentHash,
          currencyModifyBalanceRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a list of currency balances for a player. Results ordered by Currency ID ascending.
     * @summary Player Currency Balances
     * @param {string} projectId ID of the project
     * @param {string} playerId ID of the player
     * @param {string} [configAssignmentHash] Hash of the Remote Config assignment
     * @param {string} [after] The ID after which to retrieve the next page of balances.
     * @param {number} [limit] Number of items to be returned. Defaults to 20.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPlayerCurrencies(
      projectId: string,
      playerId: string,
      configAssignmentHash?: string,
      after?: string,
      limit?: number,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PlayerCurrencyBalanceResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPlayerCurrencies(
          projectId,
          playerId,
          configAssignmentHash,
          after,
          limit,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Increment a player\'s currency balance by a given value.
     * @summary Increment Currency Balance
     * @param {string} projectId ID of the project
     * @param {string} playerId ID of the player
     * @param {string} currencyId
     * @param {string} [configAssignmentHash] Hash of the Remote Config assignment
     * @param {CurrencyModifyBalanceRequest} [currencyModifyBalanceRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async incrementPlayerCurrencyBalance(
      projectId: string,
      playerId: string,
      currencyId: string,
      configAssignmentHash?: string,
      currencyModifyBalanceRequest?: CurrencyModifyBalanceRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CurrencyBalanceResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.incrementPlayerCurrencyBalance(
          projectId,
          playerId,
          currencyId,
          configAssignmentHash,
          currencyModifyBalanceRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Set a player\'s currency balance.
     * @summary Set Currency Balance
     * @param {string} projectId ID of the project
     * @param {string} playerId ID of the player
     * @param {string} currencyId
     * @param {string} [configAssignmentHash] Hash of the Remote Config assignment
     * @param {CurrencyBalanceRequest} [currencyBalanceRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setPlayerCurrencyBalance(
      projectId: string,
      playerId: string,
      currencyId: string,
      configAssignmentHash?: string,
      currencyBalanceRequest?: CurrencyBalanceRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<CurrencyBalanceResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.setPlayerCurrencyBalance(
          projectId,
          playerId,
          currencyId,
          configAssignmentHash,
          currencyBalanceRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * CurrenciesApi - factory interface
 * @export
 */
export const CurrenciesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = CurrenciesApiFp(configuration);
  return {
    /**
     * Decrements a player\'s currency balance by a given value.
     * @summary Decrement Currency Balance
     * @param {string} projectId ID of the project
     * @param {string} playerId ID of the player
     * @param {string} currencyId
     * @param {string} [configAssignmentHash] Hash of the Remote Config assignment
     * @param {CurrencyModifyBalanceRequest} [currencyModifyBalanceRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    decrementPlayerCurrencyBalance(
      projectId: string,
      playerId: string,
      currencyId: string,
      configAssignmentHash?: string,
      currencyModifyBalanceRequest?: CurrencyModifyBalanceRequest,
      options?: any
    ): AxiosPromise<CurrencyBalanceResponse> {
      return localVarFp
        .decrementPlayerCurrencyBalance(
          projectId,
          playerId,
          currencyId,
          configAssignmentHash,
          currencyModifyBalanceRequest,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a list of currency balances for a player. Results ordered by Currency ID ascending.
     * @summary Player Currency Balances
     * @param {string} projectId ID of the project
     * @param {string} playerId ID of the player
     * @param {string} [configAssignmentHash] Hash of the Remote Config assignment
     * @param {string} [after] The ID after which to retrieve the next page of balances.
     * @param {number} [limit] Number of items to be returned. Defaults to 20.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPlayerCurrencies(
      projectId: string,
      playerId: string,
      configAssignmentHash?: string,
      after?: string,
      limit?: number,
      options?: any
    ): AxiosPromise<PlayerCurrencyBalanceResponse> {
      return localVarFp
        .getPlayerCurrencies(
          projectId,
          playerId,
          configAssignmentHash,
          after,
          limit,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Increment a player\'s currency balance by a given value.
     * @summary Increment Currency Balance
     * @param {string} projectId ID of the project
     * @param {string} playerId ID of the player
     * @param {string} currencyId
     * @param {string} [configAssignmentHash] Hash of the Remote Config assignment
     * @param {CurrencyModifyBalanceRequest} [currencyModifyBalanceRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    incrementPlayerCurrencyBalance(
      projectId: string,
      playerId: string,
      currencyId: string,
      configAssignmentHash?: string,
      currencyModifyBalanceRequest?: CurrencyModifyBalanceRequest,
      options?: any
    ): AxiosPromise<CurrencyBalanceResponse> {
      return localVarFp
        .incrementPlayerCurrencyBalance(
          projectId,
          playerId,
          currencyId,
          configAssignmentHash,
          currencyModifyBalanceRequest,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Set a player\'s currency balance.
     * @summary Set Currency Balance
     * @param {string} projectId ID of the project
     * @param {string} playerId ID of the player
     * @param {string} currencyId
     * @param {string} [configAssignmentHash] Hash of the Remote Config assignment
     * @param {CurrencyBalanceRequest} [currencyBalanceRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setPlayerCurrencyBalance(
      projectId: string,
      playerId: string,
      currencyId: string,
      configAssignmentHash?: string,
      currencyBalanceRequest?: CurrencyBalanceRequest,
      options?: any
    ): AxiosPromise<CurrencyBalanceResponse> {
      return localVarFp
        .setPlayerCurrencyBalance(
          projectId,
          playerId,
          currencyId,
          configAssignmentHash,
          currencyBalanceRequest,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * CurrenciesApi - object-oriented interface
 * @export
 * @class CurrenciesApi
 * @extends {BaseAPI}
 */
export class CurrenciesApi extends BaseAPI {
  /**
   * Decrements a player\'s currency balance by a given value.
   * @summary Decrement Currency Balance
   * @param {string} projectId ID of the project
   * @param {string} playerId ID of the player
   * @param {string} currencyId
   * @param {string} [configAssignmentHash] Hash of the Remote Config assignment
   * @param {CurrencyModifyBalanceRequest} [currencyModifyBalanceRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CurrenciesApi
   */
  public decrementPlayerCurrencyBalance(
    projectId: string,
    playerId: string,
    currencyId: string,
    configAssignmentHash?: string,
    currencyModifyBalanceRequest?: CurrencyModifyBalanceRequest,
    options?: AxiosRequestConfig
  ) {
    return CurrenciesApiFp(this.configuration)
      .decrementPlayerCurrencyBalance(
        projectId,
        playerId,
        currencyId,
        configAssignmentHash,
        currencyModifyBalanceRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of currency balances for a player. Results ordered by Currency ID ascending.
   * @summary Player Currency Balances
   * @param {string} projectId ID of the project
   * @param {string} playerId ID of the player
   * @param {string} [configAssignmentHash] Hash of the Remote Config assignment
   * @param {string} [after] The ID after which to retrieve the next page of balances.
   * @param {number} [limit] Number of items to be returned. Defaults to 20.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CurrenciesApi
   */
  public getPlayerCurrencies(
    projectId: string,
    playerId: string,
    configAssignmentHash?: string,
    after?: string,
    limit?: number,
    options?: AxiosRequestConfig
  ) {
    return CurrenciesApiFp(this.configuration)
      .getPlayerCurrencies(
        projectId,
        playerId,
        configAssignmentHash,
        after,
        limit,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Increment a player\'s currency balance by a given value.
   * @summary Increment Currency Balance
   * @param {string} projectId ID of the project
   * @param {string} playerId ID of the player
   * @param {string} currencyId
   * @param {string} [configAssignmentHash] Hash of the Remote Config assignment
   * @param {CurrencyModifyBalanceRequest} [currencyModifyBalanceRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CurrenciesApi
   */
  public incrementPlayerCurrencyBalance(
    projectId: string,
    playerId: string,
    currencyId: string,
    configAssignmentHash?: string,
    currencyModifyBalanceRequest?: CurrencyModifyBalanceRequest,
    options?: AxiosRequestConfig
  ) {
    return CurrenciesApiFp(this.configuration)
      .incrementPlayerCurrencyBalance(
        projectId,
        playerId,
        currencyId,
        configAssignmentHash,
        currencyModifyBalanceRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Set a player\'s currency balance.
   * @summary Set Currency Balance
   * @param {string} projectId ID of the project
   * @param {string} playerId ID of the player
   * @param {string} currencyId
   * @param {string} [configAssignmentHash] Hash of the Remote Config assignment
   * @param {CurrencyBalanceRequest} [currencyBalanceRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CurrenciesApi
   */
  public setPlayerCurrencyBalance(
    projectId: string,
    playerId: string,
    currencyId: string,
    configAssignmentHash?: string,
    currencyBalanceRequest?: CurrencyBalanceRequest,
    options?: AxiosRequestConfig
  ) {
    return CurrenciesApiFp(this.configuration)
      .setPlayerCurrencyBalance(
        projectId,
        playerId,
        currencyId,
        configAssignmentHash,
        currencyBalanceRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * InventoryApi - axios parameter creator
 * @export
 */
export const InventoryApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Add an item to a player\'s inventory.
     * @summary Add Inventory Item
     * @param {string} projectId ID of the project
     * @param {string} playerId ID of the player
     * @param {string} [configAssignmentHash] Hash of the Remote Config assignment
     * @param {AddInventoryRequest} [addInventoryRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addInventoryItem: async (
      projectId: string,
      playerId: string,
      configAssignmentHash?: string,
      addInventoryRequest?: AddInventoryRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("addInventoryItem", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("addInventoryItem", "playerId", playerId);
      const localVarPath =
        `/v2/projects/{projectId}/players/{playerId}/inventory`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication JWT required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (configAssignmentHash !== undefined) {
        localVarQueryParameter["configAssignmentHash"] = configAssignmentHash;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        addInventoryRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a player inventory item.
     * @summary Delete Inventory Item
     * @param {string} projectId
     * @param {string} playerId
     * @param {string} playersInventoryItemId
     * @param {string} [configAssignmentHash] Hash of the Remote Config assignment
     * @param {InventoryDeleteRequest} [inventoryDeleteRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteInventoryItem: async (
      projectId: string,
      playerId: string,
      playersInventoryItemId: string,
      configAssignmentHash?: string,
      inventoryDeleteRequest?: InventoryDeleteRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("deleteInventoryItem", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("deleteInventoryItem", "playerId", playerId);
      // verify required parameter 'playersInventoryItemId' is not null or undefined
      assertParamExists(
        "deleteInventoryItem",
        "playersInventoryItemId",
        playersInventoryItemId
      );
      const localVarPath =
        `/v2/projects/{projectId}/players/{playerId}/inventory/{playersInventoryItemId}`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)))
          .replace(
            `{${"playersInventoryItemId"}}`,
            encodeURIComponent(String(playersInventoryItemId))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication JWT required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (configAssignmentHash !== undefined) {
        localVarQueryParameter["configAssignmentHash"] = configAssignmentHash;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inventoryDeleteRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of inventory for a player. Results ordered by Player Inventory Item ID ascending. Players inventory item ID and Inventory Item ID filters are optional, if not given all will be returned. If both are given an item must match both to be returned.
     * @summary List Player Inventory
     * @param {string} projectId ID of the project
     * @param {string} playerId ID of the player
     * @param {string} [configAssignmentHash] Hash of the Remote Config assignment
     * @param {string} [after] The Players inventory item ID after which to retrieve the next page of balances.
     * @param {number} [limit] Number of items to be returned. Defaults to 20.
     * @param {Array<string>} [playersInventoryItemIds] List of Players inventory item IDs in array notation, e.g. &#x60;playersInventoryItemIds[]&#x3D;ID1&amp;playersInventoryItemIds[]&#x3D;ID2&#x60;
     * @param {Array<string>} [inventoryItemIds] List of Inventory IDs in array notation, e.g. &#x60;inventoryItemIds[]&#x3D;ID1&amp;inventoryItemIds[]&#x3D;ID2&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPlayerInventory: async (
      projectId: string,
      playerId: string,
      configAssignmentHash?: string,
      after?: string,
      limit?: number,
      playersInventoryItemIds?: Array<string>,
      inventoryItemIds?: Array<string>,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("getPlayerInventory", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("getPlayerInventory", "playerId", playerId);
      const localVarPath =
        `/v2/projects/{projectId}/players/{playerId}/inventory`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication JWT required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (configAssignmentHash !== undefined) {
        localVarQueryParameter["configAssignmentHash"] = configAssignmentHash;
      }

      if (after !== undefined) {
        localVarQueryParameter["after"] = after;
      }

      if (limit !== undefined) {
        localVarQueryParameter["limit"] = limit;
      }

      if (playersInventoryItemIds) {
        localVarQueryParameter["playersInventoryItemIds"] =
          playersInventoryItemIds;
      }

      if (inventoryItemIds) {
        localVarQueryParameter["inventoryItemIds"] = inventoryItemIds;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update a players inventory item.
     * @summary Player Inventory Item
     * @param {string} projectId
     * @param {string} playerId
     * @param {string} playersInventoryItemId
     * @param {string} [configAssignmentHash] Hash of the Remote Config assignment
     * @param {InventoryRequestUpdate} [inventoryRequestUpdate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateInventoryItem: async (
      projectId: string,
      playerId: string,
      playersInventoryItemId: string,
      configAssignmentHash?: string,
      inventoryRequestUpdate?: InventoryRequestUpdate,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("updateInventoryItem", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("updateInventoryItem", "playerId", playerId);
      // verify required parameter 'playersInventoryItemId' is not null or undefined
      assertParamExists(
        "updateInventoryItem",
        "playersInventoryItemId",
        playersInventoryItemId
      );
      const localVarPath =
        `/v2/projects/{projectId}/players/{playerId}/inventory/{playersInventoryItemId}`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)))
          .replace(
            `{${"playersInventoryItemId"}}`,
            encodeURIComponent(String(playersInventoryItemId))
          );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication JWT required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (configAssignmentHash !== undefined) {
        localVarQueryParameter["configAssignmentHash"] = configAssignmentHash;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        inventoryRequestUpdate,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * InventoryApi - functional programming interface
 * @export
 */
export const InventoryApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    InventoryApiAxiosParamCreator(configuration);
  return {
    /**
     * Add an item to a player\'s inventory.
     * @summary Add Inventory Item
     * @param {string} projectId ID of the project
     * @param {string} playerId ID of the player
     * @param {string} [configAssignmentHash] Hash of the Remote Config assignment
     * @param {AddInventoryRequest} [addInventoryRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addInventoryItem(
      projectId: string,
      playerId: string,
      configAssignmentHash?: string,
      addInventoryRequest?: AddInventoryRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InventoryResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.addInventoryItem(
          projectId,
          playerId,
          configAssignmentHash,
          addInventoryRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Delete a player inventory item.
     * @summary Delete Inventory Item
     * @param {string} projectId
     * @param {string} playerId
     * @param {string} playersInventoryItemId
     * @param {string} [configAssignmentHash] Hash of the Remote Config assignment
     * @param {InventoryDeleteRequest} [inventoryDeleteRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteInventoryItem(
      projectId: string,
      playerId: string,
      playersInventoryItemId: string,
      configAssignmentHash?: string,
      inventoryDeleteRequest?: InventoryDeleteRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteInventoryItem(
          projectId,
          playerId,
          playersInventoryItemId,
          configAssignmentHash,
          inventoryDeleteRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a list of inventory for a player. Results ordered by Player Inventory Item ID ascending. Players inventory item ID and Inventory Item ID filters are optional, if not given all will be returned. If both are given an item must match both to be returned.
     * @summary List Player Inventory
     * @param {string} projectId ID of the project
     * @param {string} playerId ID of the player
     * @param {string} [configAssignmentHash] Hash of the Remote Config assignment
     * @param {string} [after] The Players inventory item ID after which to retrieve the next page of balances.
     * @param {number} [limit] Number of items to be returned. Defaults to 20.
     * @param {Array<string>} [playersInventoryItemIds] List of Players inventory item IDs in array notation, e.g. &#x60;playersInventoryItemIds[]&#x3D;ID1&amp;playersInventoryItemIds[]&#x3D;ID2&#x60;
     * @param {Array<string>} [inventoryItemIds] List of Inventory IDs in array notation, e.g. &#x60;inventoryItemIds[]&#x3D;ID1&amp;inventoryItemIds[]&#x3D;ID2&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPlayerInventory(
      projectId: string,
      playerId: string,
      configAssignmentHash?: string,
      after?: string,
      limit?: number,
      playersInventoryItemIds?: Array<string>,
      inventoryItemIds?: Array<string>,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PlayerInventoryResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPlayerInventory(
          projectId,
          playerId,
          configAssignmentHash,
          after,
          limit,
          playersInventoryItemIds,
          inventoryItemIds,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Update a players inventory item.
     * @summary Player Inventory Item
     * @param {string} projectId
     * @param {string} playerId
     * @param {string} playersInventoryItemId
     * @param {string} [configAssignmentHash] Hash of the Remote Config assignment
     * @param {InventoryRequestUpdate} [inventoryRequestUpdate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateInventoryItem(
      projectId: string,
      playerId: string,
      playersInventoryItemId: string,
      configAssignmentHash?: string,
      inventoryRequestUpdate?: InventoryRequestUpdate,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InventoryResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.updateInventoryItem(
          projectId,
          playerId,
          playersInventoryItemId,
          configAssignmentHash,
          inventoryRequestUpdate,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * InventoryApi - factory interface
 * @export
 */
export const InventoryApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = InventoryApiFp(configuration);
  return {
    /**
     * Add an item to a player\'s inventory.
     * @summary Add Inventory Item
     * @param {string} projectId ID of the project
     * @param {string} playerId ID of the player
     * @param {string} [configAssignmentHash] Hash of the Remote Config assignment
     * @param {AddInventoryRequest} [addInventoryRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addInventoryItem(
      projectId: string,
      playerId: string,
      configAssignmentHash?: string,
      addInventoryRequest?: AddInventoryRequest,
      options?: any
    ): AxiosPromise<InventoryResponse> {
      return localVarFp
        .addInventoryItem(
          projectId,
          playerId,
          configAssignmentHash,
          addInventoryRequest,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete a player inventory item.
     * @summary Delete Inventory Item
     * @param {string} projectId
     * @param {string} playerId
     * @param {string} playersInventoryItemId
     * @param {string} [configAssignmentHash] Hash of the Remote Config assignment
     * @param {InventoryDeleteRequest} [inventoryDeleteRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteInventoryItem(
      projectId: string,
      playerId: string,
      playersInventoryItemId: string,
      configAssignmentHash?: string,
      inventoryDeleteRequest?: InventoryDeleteRequest,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteInventoryItem(
          projectId,
          playerId,
          playersInventoryItemId,
          configAssignmentHash,
          inventoryDeleteRequest,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a list of inventory for a player. Results ordered by Player Inventory Item ID ascending. Players inventory item ID and Inventory Item ID filters are optional, if not given all will be returned. If both are given an item must match both to be returned.
     * @summary List Player Inventory
     * @param {string} projectId ID of the project
     * @param {string} playerId ID of the player
     * @param {string} [configAssignmentHash] Hash of the Remote Config assignment
     * @param {string} [after] The Players inventory item ID after which to retrieve the next page of balances.
     * @param {number} [limit] Number of items to be returned. Defaults to 20.
     * @param {Array<string>} [playersInventoryItemIds] List of Players inventory item IDs in array notation, e.g. &#x60;playersInventoryItemIds[]&#x3D;ID1&amp;playersInventoryItemIds[]&#x3D;ID2&#x60;
     * @param {Array<string>} [inventoryItemIds] List of Inventory IDs in array notation, e.g. &#x60;inventoryItemIds[]&#x3D;ID1&amp;inventoryItemIds[]&#x3D;ID2&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPlayerInventory(
      projectId: string,
      playerId: string,
      configAssignmentHash?: string,
      after?: string,
      limit?: number,
      playersInventoryItemIds?: Array<string>,
      inventoryItemIds?: Array<string>,
      options?: any
    ): AxiosPromise<PlayerInventoryResponse> {
      return localVarFp
        .getPlayerInventory(
          projectId,
          playerId,
          configAssignmentHash,
          after,
          limit,
          playersInventoryItemIds,
          inventoryItemIds,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Update a players inventory item.
     * @summary Player Inventory Item
     * @param {string} projectId
     * @param {string} playerId
     * @param {string} playersInventoryItemId
     * @param {string} [configAssignmentHash] Hash of the Remote Config assignment
     * @param {InventoryRequestUpdate} [inventoryRequestUpdate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateInventoryItem(
      projectId: string,
      playerId: string,
      playersInventoryItemId: string,
      configAssignmentHash?: string,
      inventoryRequestUpdate?: InventoryRequestUpdate,
      options?: any
    ): AxiosPromise<InventoryResponse> {
      return localVarFp
        .updateInventoryItem(
          projectId,
          playerId,
          playersInventoryItemId,
          configAssignmentHash,
          inventoryRequestUpdate,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * InventoryApi - object-oriented interface
 * @export
 * @class InventoryApi
 * @extends {BaseAPI}
 */
export class InventoryApi extends BaseAPI {
  /**
   * Add an item to a player\'s inventory.
   * @summary Add Inventory Item
   * @param {string} projectId ID of the project
   * @param {string} playerId ID of the player
   * @param {string} [configAssignmentHash] Hash of the Remote Config assignment
   * @param {AddInventoryRequest} [addInventoryRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InventoryApi
   */
  public addInventoryItem(
    projectId: string,
    playerId: string,
    configAssignmentHash?: string,
    addInventoryRequest?: AddInventoryRequest,
    options?: AxiosRequestConfig
  ) {
    return InventoryApiFp(this.configuration)
      .addInventoryItem(
        projectId,
        playerId,
        configAssignmentHash,
        addInventoryRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete a player inventory item.
   * @summary Delete Inventory Item
   * @param {string} projectId
   * @param {string} playerId
   * @param {string} playersInventoryItemId
   * @param {string} [configAssignmentHash] Hash of the Remote Config assignment
   * @param {InventoryDeleteRequest} [inventoryDeleteRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InventoryApi
   */
  public deleteInventoryItem(
    projectId: string,
    playerId: string,
    playersInventoryItemId: string,
    configAssignmentHash?: string,
    inventoryDeleteRequest?: InventoryDeleteRequest,
    options?: AxiosRequestConfig
  ) {
    return InventoryApiFp(this.configuration)
      .deleteInventoryItem(
        projectId,
        playerId,
        playersInventoryItemId,
        configAssignmentHash,
        inventoryDeleteRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of inventory for a player. Results ordered by Player Inventory Item ID ascending. Players inventory item ID and Inventory Item ID filters are optional, if not given all will be returned. If both are given an item must match both to be returned.
   * @summary List Player Inventory
   * @param {string} projectId ID of the project
   * @param {string} playerId ID of the player
   * @param {string} [configAssignmentHash] Hash of the Remote Config assignment
   * @param {string} [after] The Players inventory item ID after which to retrieve the next page of balances.
   * @param {number} [limit] Number of items to be returned. Defaults to 20.
   * @param {Array<string>} [playersInventoryItemIds] List of Players inventory item IDs in array notation, e.g. &#x60;playersInventoryItemIds[]&#x3D;ID1&amp;playersInventoryItemIds[]&#x3D;ID2&#x60;
   * @param {Array<string>} [inventoryItemIds] List of Inventory IDs in array notation, e.g. &#x60;inventoryItemIds[]&#x3D;ID1&amp;inventoryItemIds[]&#x3D;ID2&#x60;
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InventoryApi
   */
  public getPlayerInventory(
    projectId: string,
    playerId: string,
    configAssignmentHash?: string,
    after?: string,
    limit?: number,
    playersInventoryItemIds?: Array<string>,
    inventoryItemIds?: Array<string>,
    options?: AxiosRequestConfig
  ) {
    return InventoryApiFp(this.configuration)
      .getPlayerInventory(
        projectId,
        playerId,
        configAssignmentHash,
        after,
        limit,
        playersInventoryItemIds,
        inventoryItemIds,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update a players inventory item.
   * @summary Player Inventory Item
   * @param {string} projectId
   * @param {string} playerId
   * @param {string} playersInventoryItemId
   * @param {string} [configAssignmentHash] Hash of the Remote Config assignment
   * @param {InventoryRequestUpdate} [inventoryRequestUpdate]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InventoryApi
   */
  public updateInventoryItem(
    projectId: string,
    playerId: string,
    playersInventoryItemId: string,
    configAssignmentHash?: string,
    inventoryRequestUpdate?: InventoryRequestUpdate,
    options?: AxiosRequestConfig
  ) {
    return InventoryApiFp(this.configuration)
      .updateInventoryItem(
        projectId,
        playerId,
        playersInventoryItemId,
        configAssignmentHash,
        inventoryRequestUpdate,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PurchasesApi - axios parameter creator
 * @export
 */
export const PurchasesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Enact a virtual purchase for a player.
     * @summary Make purchase
     * @param {string} projectId
     * @param {string} playerId
     * @param {string} [configAssignmentHash] Hash of the Remote Config assignment
     * @param {PlayerPurchaseVirtualRequest} [playerPurchaseVirtualRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    makeVirtualPurchase: async (
      projectId: string,
      playerId: string,
      configAssignmentHash?: string,
      playerPurchaseVirtualRequest?: PlayerPurchaseVirtualRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("makeVirtualPurchase", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("makeVirtualPurchase", "playerId", playerId);
      const localVarPath =
        `/v2/projects/{projectId}/players/{playerId}/purchases/virtual`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication JWT required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (configAssignmentHash !== undefined) {
        localVarQueryParameter["configAssignmentHash"] = configAssignmentHash;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        playerPurchaseVirtualRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Redeem an Apple App Store purchase for a player.
     * @summary Redeem Apple App Store Purchase
     * @param {string} projectId ID of the project
     * @param {string} playerId ID of the player
     * @param {string} [configAssignmentHash] Hash of the Remote Config assignment
     * @param {PlayerPurchaseAppleappstoreRequest} [playerPurchaseAppleappstoreRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    redeemAppleAppStorePurchase: async (
      projectId: string,
      playerId: string,
      configAssignmentHash?: string,
      playerPurchaseAppleappstoreRequest?: PlayerPurchaseAppleappstoreRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("redeemAppleAppStorePurchase", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("redeemAppleAppStorePurchase", "playerId", playerId);
      const localVarPath =
        `/v2/projects/{projectId}/players/{playerId}/purchases/appleappstore`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication JWT required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (configAssignmentHash !== undefined) {
        localVarQueryParameter["configAssignmentHash"] = configAssignmentHash;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        playerPurchaseAppleappstoreRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Redeem a Google Play store purchase for a player.
     * @summary Redeem Google Play Purchase
     * @param {string} projectId ID of the project
     * @param {string} playerId ID of the player
     * @param {string} [configAssignmentHash] Hash of the Remote Config assignment
     * @param {PlayerPurchaseGoogleplaystoreRequest} [playerPurchaseGoogleplaystoreRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    redeemGooglePlayPurchase: async (
      projectId: string,
      playerId: string,
      configAssignmentHash?: string,
      playerPurchaseGoogleplaystoreRequest?: PlayerPurchaseGoogleplaystoreRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("redeemGooglePlayPurchase", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("redeemGooglePlayPurchase", "playerId", playerId);
      const localVarPath =
        `/v2/projects/{projectId}/players/{playerId}/purchases/googleplaystore`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication JWT required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (configAssignmentHash !== undefined) {
        localVarQueryParameter["configAssignmentHash"] = configAssignmentHash;
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        playerPurchaseGoogleplaystoreRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PurchasesApi - functional programming interface
 * @export
 */
export const PurchasesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    PurchasesApiAxiosParamCreator(configuration);
  return {
    /**
     * Enact a virtual purchase for a player.
     * @summary Make purchase
     * @param {string} projectId
     * @param {string} playerId
     * @param {string} [configAssignmentHash] Hash of the Remote Config assignment
     * @param {PlayerPurchaseVirtualRequest} [playerPurchaseVirtualRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async makeVirtualPurchase(
      projectId: string,
      playerId: string,
      configAssignmentHash?: string,
      playerPurchaseVirtualRequest?: PlayerPurchaseVirtualRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PlayerPurchaseVirtualResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.makeVirtualPurchase(
          projectId,
          playerId,
          configAssignmentHash,
          playerPurchaseVirtualRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Redeem an Apple App Store purchase for a player.
     * @summary Redeem Apple App Store Purchase
     * @param {string} projectId ID of the project
     * @param {string} playerId ID of the player
     * @param {string} [configAssignmentHash] Hash of the Remote Config assignment
     * @param {PlayerPurchaseAppleappstoreRequest} [playerPurchaseAppleappstoreRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async redeemAppleAppStorePurchase(
      projectId: string,
      playerId: string,
      configAssignmentHash?: string,
      playerPurchaseAppleappstoreRequest?: PlayerPurchaseAppleappstoreRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PlayerPurchaseAppleappstoreResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.redeemAppleAppStorePurchase(
          projectId,
          playerId,
          configAssignmentHash,
          playerPurchaseAppleappstoreRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Redeem a Google Play store purchase for a player.
     * @summary Redeem Google Play Purchase
     * @param {string} projectId ID of the project
     * @param {string} playerId ID of the player
     * @param {string} [configAssignmentHash] Hash of the Remote Config assignment
     * @param {PlayerPurchaseGoogleplaystoreRequest} [playerPurchaseGoogleplaystoreRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async redeemGooglePlayPurchase(
      projectId: string,
      playerId: string,
      configAssignmentHash?: string,
      playerPurchaseGoogleplaystoreRequest?: PlayerPurchaseGoogleplaystoreRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<PlayerPurchaseGoogleplaystoreResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.redeemGooglePlayPurchase(
          projectId,
          playerId,
          configAssignmentHash,
          playerPurchaseGoogleplaystoreRequest,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * PurchasesApi - factory interface
 * @export
 */
export const PurchasesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PurchasesApiFp(configuration);
  return {
    /**
     * Enact a virtual purchase for a player.
     * @summary Make purchase
     * @param {string} projectId
     * @param {string} playerId
     * @param {string} [configAssignmentHash] Hash of the Remote Config assignment
     * @param {PlayerPurchaseVirtualRequest} [playerPurchaseVirtualRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    makeVirtualPurchase(
      projectId: string,
      playerId: string,
      configAssignmentHash?: string,
      playerPurchaseVirtualRequest?: PlayerPurchaseVirtualRequest,
      options?: any
    ): AxiosPromise<PlayerPurchaseVirtualResponse> {
      return localVarFp
        .makeVirtualPurchase(
          projectId,
          playerId,
          configAssignmentHash,
          playerPurchaseVirtualRequest,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Redeem an Apple App Store purchase for a player.
     * @summary Redeem Apple App Store Purchase
     * @param {string} projectId ID of the project
     * @param {string} playerId ID of the player
     * @param {string} [configAssignmentHash] Hash of the Remote Config assignment
     * @param {PlayerPurchaseAppleappstoreRequest} [playerPurchaseAppleappstoreRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    redeemAppleAppStorePurchase(
      projectId: string,
      playerId: string,
      configAssignmentHash?: string,
      playerPurchaseAppleappstoreRequest?: PlayerPurchaseAppleappstoreRequest,
      options?: any
    ): AxiosPromise<PlayerPurchaseAppleappstoreResponse> {
      return localVarFp
        .redeemAppleAppStorePurchase(
          projectId,
          playerId,
          configAssignmentHash,
          playerPurchaseAppleappstoreRequest,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Redeem a Google Play store purchase for a player.
     * @summary Redeem Google Play Purchase
     * @param {string} projectId ID of the project
     * @param {string} playerId ID of the player
     * @param {string} [configAssignmentHash] Hash of the Remote Config assignment
     * @param {PlayerPurchaseGoogleplaystoreRequest} [playerPurchaseGoogleplaystoreRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    redeemGooglePlayPurchase(
      projectId: string,
      playerId: string,
      configAssignmentHash?: string,
      playerPurchaseGoogleplaystoreRequest?: PlayerPurchaseGoogleplaystoreRequest,
      options?: any
    ): AxiosPromise<PlayerPurchaseGoogleplaystoreResponse> {
      return localVarFp
        .redeemGooglePlayPurchase(
          projectId,
          playerId,
          configAssignmentHash,
          playerPurchaseGoogleplaystoreRequest,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * PurchasesApi - object-oriented interface
 * @export
 * @class PurchasesApi
 * @extends {BaseAPI}
 */
export class PurchasesApi extends BaseAPI {
  /**
   * Enact a virtual purchase for a player.
   * @summary Make purchase
   * @param {string} projectId
   * @param {string} playerId
   * @param {string} [configAssignmentHash] Hash of the Remote Config assignment
   * @param {PlayerPurchaseVirtualRequest} [playerPurchaseVirtualRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PurchasesApi
   */
  public makeVirtualPurchase(
    projectId: string,
    playerId: string,
    configAssignmentHash?: string,
    playerPurchaseVirtualRequest?: PlayerPurchaseVirtualRequest,
    options?: AxiosRequestConfig
  ) {
    return PurchasesApiFp(this.configuration)
      .makeVirtualPurchase(
        projectId,
        playerId,
        configAssignmentHash,
        playerPurchaseVirtualRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Redeem an Apple App Store purchase for a player.
   * @summary Redeem Apple App Store Purchase
   * @param {string} projectId ID of the project
   * @param {string} playerId ID of the player
   * @param {string} [configAssignmentHash] Hash of the Remote Config assignment
   * @param {PlayerPurchaseAppleappstoreRequest} [playerPurchaseAppleappstoreRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PurchasesApi
   */
  public redeemAppleAppStorePurchase(
    projectId: string,
    playerId: string,
    configAssignmentHash?: string,
    playerPurchaseAppleappstoreRequest?: PlayerPurchaseAppleappstoreRequest,
    options?: AxiosRequestConfig
  ) {
    return PurchasesApiFp(this.configuration)
      .redeemAppleAppStorePurchase(
        projectId,
        playerId,
        configAssignmentHash,
        playerPurchaseAppleappstoreRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Redeem a Google Play store purchase for a player.
   * @summary Redeem Google Play Purchase
   * @param {string} projectId ID of the project
   * @param {string} playerId ID of the player
   * @param {string} [configAssignmentHash] Hash of the Remote Config assignment
   * @param {PlayerPurchaseGoogleplaystoreRequest} [playerPurchaseGoogleplaystoreRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PurchasesApi
   */
  public redeemGooglePlayPurchase(
    projectId: string,
    playerId: string,
    configAssignmentHash?: string,
    playerPurchaseGoogleplaystoreRequest?: PlayerPurchaseGoogleplaystoreRequest,
    options?: AxiosRequestConfig
  ) {
    return PurchasesApiFp(this.configuration)
      .redeemGooglePlayPurchase(
        projectId,
        playerId,
        configAssignmentHash,
        playerPurchaseGoogleplaystoreRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}
