/**
 * Cloud Save API
 * # Introduction This is the API specification for the Unity Cloud Save service that allows player or custom non-player state to be accessed and persisted from a game client. The Player State API allows data to be stored against a specific player ID. Access using client authentication is limited to the specified player for both data reads and writes. The Game State API allows data to be stored against a custom ID provided by the user. All players are able to read the data from the custom ID using client authentication, but write operations are limited to Service Account authentication. To use this API, you must first enable it through the Unity Gaming Services dashboard.  # General Information **Cloud Save Data** is for storing small blobs of JSON serializable data, stored as key/value pairs. It can store data against a player ID (referred to as Player State) or a custom ID (referred to as Game State). The custom ID is a string that can be used to store data against a non-player entity, but the client API is restricted to read-only access. In addition to the default access levels for player and game state, data can be stored in public player state, protected player state, or private game state. The access details are as follows: - Default Player State: Player-writable and player-readable, by the player the data corresponds to - Public Player State: Player-writable by the player the data corresponds to, and readable by any player (e.g. public player profile data) - Protected Player State: Server-writable only, and player-readable by the player the data corresponds to - Default Game State: Server-writable only, player-readable by any player - Private Game State: Server-writable and server-readable only  The maximum size for player or custom data is 5 MB across all key/value pairs for that player and access class. A player can have data in a single slot that is up to 5 MB in size, or use many slots that equal to less than 5 MB in total size. Limits: - Maximum 255 characters per slot name - Maximum 2000 data slots per player or custom ID per access class - Maximum 5 MB in size per player or custom ID per access class across all slots  **Cloud Save Files** is for storing data files (binary, JSON, text, CSV, etc.) against keys. The maximum size for player data is 1 GB across all keys for that player. A player can have data in a single file that is up to 1 GB in size, or use many files that equal to less than 1 GB in total size. Limits: - Maximum 255 characters per file name - Maximum 200 files per player - Maximum 1 GB in size per player across all files  ## Rate Limits The API has rate limiting in place. The endpoints are limited to 600 requests per minute on a per-player basis. The API responds with a `429` HTTP status code if the rate limit is exceeded. It will also respond with a `Retry-After` header to be used in conjunction with a client\'s retry logic. The value is the number of seconds until a request for the given player will be accepted.
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
export interface ConfigurationParameters {
    apiKey?: string | Promise<string> | ((name: string) => string) | ((name: string) => Promise<string>);
    username?: string;
    password?: string;
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string) | ((name?: string, scopes?: string[]) => Promise<string>);
    basePath?: string;
    baseOptions?: any;
    formDataCtor?: new () => any;
    playerId?: string;
    projectId?: string;
    environmentId?: string;
    environmentName?: string;
    playerToken?: string;
    serviceToken?: string;
    analyticsUserId?: string;
    unityInstallationId?: string;
    correlationId?: string;
}
export declare class Configuration {
    /**
     * parameter for apiKey security
     * @param name security name
     * @memberof Configuration
     */
    apiKey?: string | Promise<string> | ((name: string) => string) | ((name: string) => Promise<string>);
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    username?: string;
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    password?: string;
    /**
     * parameter for oauth2 security
     * @param name security name
     * @param scopes oauth2 scope
     * @memberof Configuration
     */
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string) | ((name?: string, scopes?: string[]) => Promise<string>);
    /**
     * override base path
     *
     * @type {string}
     * @memberof Configuration
     */
    basePath?: string;
    /**
     * base options for axios calls
     *
     * @type {any}
     * @memberof Configuration
     */
    baseOptions?: any;
    /**
     * The FormData constructor that will be used to create multipart form data
     * requests. You can inject this here so that execution environments that
     * do not support the FormData class can still run the generated client.
     *
     * @type {new () => FormData}
     */
    formDataCtor?: new () => any;
    /**
     * @type {string}
     * @memberof Configuration
     */
    playerId?: string;
    /**
     * @type {string}
     * @memberof Configuration
     */
    projectId?: string;
    /**
     * @type {string}
     * @memberof Configuration
     */
    environmentId?: string;
    /**
     * @type {string}
     * @memberof Configuration
     */
    environmentName?: string;
    /**
     * @type {string}
     * @memberof Configuration
     */
    playerToken?: string;
    /**
     * @type {string}
     * @memberof Configuration
     */
    serviceToken?: string;
    /**
     * @type {string}
     * @memberof Configuration
     */
    analyticsUserId?: string;
    /**
     * @type {string}
     * @memberof Configuration
     */
    unityInstallationId?: string;
    /**
     * @type {string}
     * @memberof Configuration
     */
    correlationId?: string;
    constructor(param?: ConfigurationParameters);
    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    isJsonMime(mime: string): boolean;
}
