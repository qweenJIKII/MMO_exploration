/* tslint:disable */
/* eslint-disable */
/**
 * Cloud Save API
 * # Introduction This is the API specification for the Unity Cloud Save service that allows player or custom non-player state to be accessed and persisted from a game client. The Player State API allows data to be stored against a specific player ID. Access using client authentication is limited to the specified player for both data reads and writes. The Game State API allows data to be stored against a custom ID provided by the user. All players are able to read the data from the custom ID using client authentication, but write operations are limited to Service Account authentication. To use this API, you must first enable it through the Unity Gaming Services dashboard.  # General Information **Cloud Save Data** is for storing small blobs of JSON serializable data, stored as key/value pairs. It can store data against a player ID (referred to as Player State) or a custom ID (referred to as Game State). The custom ID is a string that can be used to store data against a non-player entity, but the client API is restricted to read-only access. In addition to the default access levels for player and game state, data can be stored in public player state, protected player state, or private game state. The access details are as follows: - Default Player State: Player-writable and player-readable, by the player the data corresponds to - Public Player State: Player-writable by the player the data corresponds to, and readable by any player (e.g. public player profile data) - Protected Player State: Server-writable only, and player-readable by the player the data corresponds to - Default Game State: Server-writable only, player-readable by any player - Private Game State: Server-writable and server-readable only  The maximum size for player or custom data is 5 MB across all key/value pairs for that player and access class. A player can have data in a single slot that is up to 5 MB in size, or use many slots that equal to less than 5 MB in total size. Limits: - Maximum 255 characters per slot name - Maximum 2000 data slots per player or custom ID per access class - Maximum 5 MB in size per player or custom ID per access class across all slots  **Cloud Save Files** is for storing data files (binary, JSON, text, CSV, etc.) against keys. The maximum size for player data is 1 GB across all keys for that player. A player can have data in a single file that is up to 1 GB in size, or use many files that equal to less than 1 GB in total size. Limits: - Maximum 255 characters per file name - Maximum 200 files per player - Maximum 1 GB in size per player across all files  ## Rate Limits The API has rate limiting in place. The endpoints are limited to 600 requests per minute on a per-player basis. The API responds with a `429` HTTP status code if the rate limit is exceeded. It will also respond with a `Retry-After` header to be used in conjunction with a client\'s retry logic. The value is the number of seconds until a request for the given player will be accepted.
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Configuration } from "./configuration";
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from "axios";
import globalAxios from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
import type { RequestArgs } from "./base";
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from "./base";

/**
 * Response type for an attempted Data Item sent to the Cloud Save service.
 * @export
 * @interface AttemptedItem
 */
export interface AttemptedItem {
  /**
   * Item key
   * @type {string}
   * @memberof AttemptedItem
   */
  key: string;
  /**
   * Any JSON serializable structure with a maximum size of 5 MB.
   * @type {object}
   * @memberof AttemptedItem
   */
  value: object;
  /**
   * Enforces conflict checking when updating an existing data item. This field should be omitted when creating a new data item. When updating an existing item, omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
   * @type {string}
   * @memberof AttemptedItem
   */
  writeLock: string;
}
/**
 *
 * @export
 * @interface BaseErrorResponse
 */
export interface BaseErrorResponse {
  /**
   * A URI reference [RFC3986] that identifies the problem type. This specification encourages that, when dereferenced, it provide human-readable documentation for the problem type (e.g., using HTML [W3C.REC-html5-20141028]). When this member is not present, its value is assumed to be \"about:blank\".
   * @type {string}
   * @memberof BaseErrorResponse
   */
  type: string;
  /**
   * A short, human-readable summary of the problem type. It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization (e.g., using proactive content negotiation; see [RFC7231], Section 3.4).
   * @type {string}
   * @memberof BaseErrorResponse
   */
  title?: string;
  /**
   * The HTTP status code ([RFC7231], Section 6) generated by the origin server for this occurrence of the problem.
   * @type {number}
   * @memberof BaseErrorResponse
   */
  status?: number;
  /**
   * Service specific error code
   * @type {number}
   * @memberof BaseErrorResponse
   */
  code?: number;
  /**
   * A human-readable explanation specific to this occurrence of the problem.
   * @type {string}
   * @memberof BaseErrorResponse
   */
  detail?: string;
  /**
   * A URI reference that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
   * @type {string}
   * @memberof BaseErrorResponse
   */
  instance?: string | null;
}
/**
 * Referenced from - https://tools.ietf.org/html/rfc7807#page-3 Consumers MUST use the \"type\" string as the primary identifier for the problem type; the \'title\' string is advisory and included only for users who are not aware of the semantics of the URI and do not have the ability to discover them (e.g., offline log analysis). Consumers SHOULD NOT automatically dereference the type URI. The \"status\" member, if present, is only advisory; it conveys the HTTP status code used for the convenience of the consumer. Generators MUST use the same status code in the actual HTTP response, to assure that generic HTTP software that does not understand this format still behaves correctly.  See Section 5 for further caveats regarding its use. Consumers can use the status member to determine what the original status code used by the generator was, in cases where it has been changed (e.g., by an intermediary or cache), and when message bodies persist without HTTP information.  Generic HTTP software will still use the HTTP status code. The \"detail\" member, if present, ought to focus on helping the client correct the problem, rather than giving debugging information.
 * @export
 * @interface BasicErrorResponse
 */
export interface BasicErrorResponse {
  /**
   * A URI reference [RFC3986] that identifies the problem type. This specification encourages that, when dereferenced, it provide human-readable documentation for the problem type (e.g., using HTML [W3C.REC-html5-20141028]). When this member is not present, its value is assumed to be \"about:blank\".
   * @type {string}
   * @memberof BasicErrorResponse
   */
  type: string;
  /**
   * A short, human-readable summary of the problem type. It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization (e.g., using proactive content negotiation; see [RFC7231], Section 3.4).
   * @type {string}
   * @memberof BasicErrorResponse
   */
  title?: string;
  /**
   * The HTTP status code ([RFC7231], Section 6) generated by the origin server for this occurrence of the problem.
   * @type {number}
   * @memberof BasicErrorResponse
   */
  status?: number;
  /**
   * Service specific error code
   * @type {number}
   * @memberof BasicErrorResponse
   */
  code?: number;
  /**
   * A human-readable explanation specific to this occurrence of the problem.
   * @type {string}
   * @memberof BasicErrorResponse
   */
  detail?: string;
  /**
   * A URI reference that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
   * @type {string}
   * @memberof BasicErrorResponse
   */
  instance?: string | null;
  /**
   * Machine readable service specific errors.
   * @type {Array<object>}
   * @memberof BasicErrorResponse
   */
  details?: Array<object>;
}
/**
 * Single error in the Batch Basic Error Response.
 * @export
 * @interface BatchBasicErrorBody
 */
export interface BatchBasicErrorBody {
  /**
   *
   * @type {Array<string>}
   * @memberof BatchBasicErrorBody
   */
  messages: Array<string>;
  /**
   *
   * @type {string}
   * @memberof BatchBasicErrorBody
   */
  key: string;
}
/**
 * Batch basic error response when one or more values provided from the client fails some condition
 * @export
 * @interface BatchBasicErrorResponse
 */
export interface BatchBasicErrorResponse {
  /**
   *
   * @type {string}
   * @memberof BatchBasicErrorResponse
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof BatchBasicErrorResponse
   */
  title: string;
  /**
   *
   * @type {number}
   * @memberof BatchBasicErrorResponse
   */
  status: number;
  /**
   *
   * @type {number}
   * @memberof BatchBasicErrorResponse
   */
  code: number;
  /**
   *
   * @type {string}
   * @memberof BatchBasicErrorResponse
   */
  detail: string;
  /**
   *
   * @type {string}
   * @memberof BatchBasicErrorResponse
   */
  instance?: string;
  /**
   *
   * @type {Array<BatchBasicErrorBody>}
   * @memberof BatchBasicErrorResponse
   */
  errors: Array<BatchBasicErrorBody>;
}
/**
 * An error response sent back upon a batch update containing a resource conflict. All Data Items within the request should be considered unprocessed. The error response data[] property contains the Data Items that conflicted.
 * @export
 * @interface BatchConflictErrorResponse
 */
export interface BatchConflictErrorResponse {
  /**
   * A URI reference [RFC3986] that identifies the problem type. This specification encourages that, when dereferenced, it provide human-readable documentation for the problem type (e.g., using HTML [W3C.REC-html5-20141028]). When this member is not present, its value is assumed to be \"about:blank\".
   * @type {string}
   * @memberof BatchConflictErrorResponse
   */
  type: string;
  /**
   * A short, human-readable summary of the problem type. It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization (e.g., using proactive content negotiation; see [RFC7231], Section 3.4).
   * @type {string}
   * @memberof BatchConflictErrorResponse
   */
  title: string;
  /**
   * The HTTP status code ([RFC7231], Section 6) generated by the origin server for this occurrence of the problem.
   * @type {number}
   * @memberof BatchConflictErrorResponse
   */
  status: number;
  /**
   * Service specific error code
   * @type {number}
   * @memberof BatchConflictErrorResponse
   */
  code: number;
  /**
   * A human-readable explanation specific to this occurrence of the problem.
   * @type {string}
   * @memberof BatchConflictErrorResponse
   */
  detail: string;
  /**
   * A URI reference that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
   * @type {string}
   * @memberof BatchConflictErrorResponse
   */
  instance?: string | null;
  /**
   * A human-readable explanation specific to this occurrence of the problem.
   * @type {Array<ConflictErrorResponseData>}
   * @memberof BatchConflictErrorResponse
   */
  data: Array<ConflictErrorResponseData>;
}
/**
 * Single error in the Batch Validation Error Response.
 * @export
 * @interface BatchValidationErrorBody
 */
export interface BatchValidationErrorBody {
  /**
   *
   * @type {string}
   * @memberof BatchValidationErrorBody
   */
  field: string;
  /**
   *
   * @type {Array<string>}
   * @memberof BatchValidationErrorBody
   */
  messages: Array<string>;
  /**
   *
   * @type {string}
   * @memberof BatchValidationErrorBody
   */
  key: string;
}
/**
 * Batch validation error response when one or more values provided from the client does not pass validation on server
 * @export
 * @interface BatchValidationErrorResponse
 */
export interface BatchValidationErrorResponse {
  /**
   *
   * @type {string}
   * @memberof BatchValidationErrorResponse
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof BatchValidationErrorResponse
   */
  title: string;
  /**
   *
   * @type {number}
   * @memberof BatchValidationErrorResponse
   */
  status: number;
  /**
   *
   * @type {number}
   * @memberof BatchValidationErrorResponse
   */
  code: number;
  /**
   *
   * @type {string}
   * @memberof BatchValidationErrorResponse
   */
  detail: string;
  /**
   *
   * @type {string}
   * @memberof BatchValidationErrorResponse
   */
  instance?: string;
  /**
   *
   * @type {Array<BatchValidationErrorBody>}
   * @memberof BatchValidationErrorResponse
   */
  errors: Array<BatchValidationErrorBody>;
}
/**
 * An error sent back upon resource conflict.
 * @export
 * @interface ConflictErrorResponse
 */
export interface ConflictErrorResponse {
  /**
   * A URI reference [RFC3986] that identifies the problem type. This specification encourages that, when dereferenced, it provide human-readable documentation for the problem type (e.g., using HTML [W3C.REC-html5-20141028]). When this member is not present, its value is assumed to be \"about:blank\".
   * @type {string}
   * @memberof ConflictErrorResponse
   */
  type: string;
  /**
   * A short, human-readable summary of the problem type. It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization (e.g., using proactive content negotiation; see [RFC7231], Section 3.4).
   * @type {string}
   * @memberof ConflictErrorResponse
   */
  title: string;
  /**
   * The HTTP status code ([RFC7231], Section 6) generated by the origin server for this occurrence of the problem.
   * @type {number}
   * @memberof ConflictErrorResponse
   */
  status: number;
  /**
   * Service specific error code
   * @type {number}
   * @memberof ConflictErrorResponse
   */
  code: number;
  /**
   * A human-readable explanation specific to this occurrence of the problem.
   * @type {string}
   * @memberof ConflictErrorResponse
   */
  detail: string;
  /**
   * A URI reference that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
   * @type {string}
   * @memberof ConflictErrorResponse
   */
  instance?: string | null;
  /**
   *
   * @type {ConflictErrorResponseData}
   * @memberof ConflictErrorResponse
   */
  data: ConflictErrorResponseData;
}
/**
 * A human-readable explanation specific to this occurrence of the problem.
 * @export
 * @interface ConflictErrorResponseData
 */
export interface ConflictErrorResponseData {
  /**
   *
   * @type {AttemptedItem}
   * @memberof ConflictErrorResponseData
   */
  attempted?: AttemptedItem;
  /**
   *
   * @type {Item}
   * @memberof ConflictErrorResponseData
   */
  existing?: Item;
}
/**
 * An error sent back upon resource conflict.
 * @export
 * @interface DeleteConflictErrorResponse
 */
export interface DeleteConflictErrorResponse {
  /**
   * A URI reference [RFC3986] that identifies the problem type. This specification encourages that, when dereferenced, it provide human-readable documentation for the problem type (e.g., using HTML [W3C.REC-html5-20141028]). When this member is not present, its value is assumed to be \"about:blank\".
   * @type {string}
   * @memberof DeleteConflictErrorResponse
   */
  type: string;
  /**
   * A short, human-readable summary of the problem type. It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization (e.g., using proactive content negotiation; see [RFC7231], Section 3.4).
   * @type {string}
   * @memberof DeleteConflictErrorResponse
   */
  title: string;
  /**
   * The HTTP status code ([RFC7231], Section 6) generated by the origin server for this occurrence of the problem.
   * @type {number}
   * @memberof DeleteConflictErrorResponse
   */
  status: number;
  /**
   * Service specific error code
   * @type {number}
   * @memberof DeleteConflictErrorResponse
   */
  code: number;
  /**
   * A human-readable explanation specific to this occurrence of the problem.
   * @type {string}
   * @memberof DeleteConflictErrorResponse
   */
  detail: string;
  /**
   * A URI reference that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
   * @type {string}
   * @memberof DeleteConflictErrorResponse
   */
  instance?: string | null;
  /**
   *
   * @type {DeleteConflictErrorResponseAllOfData}
   * @memberof DeleteConflictErrorResponse
   */
  data: DeleteConflictErrorResponseAllOfData;
}
/**
 * A human-readable explanation specific to this occurrence of the problem.
 * @export
 * @interface DeleteConflictErrorResponseAllOfData
 */
export interface DeleteConflictErrorResponseAllOfData {
  /**
   *
   * @type {string}
   * @memberof DeleteConflictErrorResponseAllOfData
   */
  key?: string;
  /**
   *
   * @type {string}
   * @memberof DeleteConflictErrorResponseAllOfData
   */
  attemptedWriteLock?: string;
  /**
   *
   * @type {string}
   * @memberof DeleteConflictErrorResponseAllOfData
   */
  existingWriteLock?: string;
}
/**
 * A field filter for querying an index
 * @export
 * @interface FieldFilter
 */
export interface FieldFilter {
  /**
   * Item key
   * @type {string}
   * @memberof FieldFilter
   */
  key: string;
  /**
   * The indexed Cloud Save value
   * @type {object}
   * @memberof FieldFilter
   */
  value: object;
  /**
   * The comparison operator to use for the filter. The specified value is compared to the indexed value (lexicographically for string data, numerically for numerical data) using one of the following operators: * `EQ` - Equal * `NE` - Not Equal * `LT` - Less Than * `LE` - Less Than or Equal * `GT` - Greater Than * `GE` - Greater Than or Equal
   * @type {string}
   * @memberof FieldFilter
   */
  op: FieldFilterOpEnum;
  /**
   * Whether the field is sorted in ascending order
   * @type {boolean}
   * @memberof FieldFilter
   */
  asc: boolean;
}

export const FieldFilterOpEnum = {
  Eq: "EQ",
  Ne: "NE",
  Lt: "LT",
  Le: "LE",
  Gt: "GT",
  Ge: "GE",
} as const;

export type FieldFilterOpEnum =
  (typeof FieldFilterOpEnum)[keyof typeof FieldFilterOpEnum];

/**
 * Details included when generating an upload URL for a file
 * @export
 * @interface FileDetails
 */
export interface FileDetails {
  /**
   * The MIME type of the file that will be uploaded
   * @type {string}
   * @memberof FileDetails
   */
  contentType: string;
  /**
   * The content length in bytes of the file that will be uploaded
   * @type {number}
   * @memberof FileDetails
   */
  contentLength: number;
  /**
   * The base64 encoded MD5 checksum of the file contents that will be uploaded
   * @type {string}
   * @memberof FileDetails
   */
  contentMd5: string;
  /**
   * Enforces conflict checking when updating an existing data item. This field should be omitted when creating a new data item. When updating an existing item, omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
   * @type {string}
   * @memberof FileDetails
   */
  writeLock?: string;
}
/**
 * Response type for a file stored in the Cloud Save service.
 * @export
 * @interface FileItem
 */
export interface FileItem {
  /**
   * Item key
   * @type {string}
   * @memberof FileItem
   */
  key: string;
  /**
   * Enforces conflict checking when updating an existing data item. This field should be omitted when creating a new data item. When updating an existing item, omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
   * @type {string}
   * @memberof FileItem
   */
  writeLock: string;
  /**
   *
   * @type {ModifiedMetadata}
   * @memberof FileItem
   */
  modified: ModifiedMetadata;
  /**
   *
   * @type {ModifiedMetadata}
   * @memberof FileItem
   */
  created: ModifiedMetadata;
  /**
   * The MIME type of the stored file
   * @type {string}
   * @memberof FileItem
   */
  contentType: string;
  /**
   * The size of the stored file in bytes
   * @type {number}
   * @memberof FileItem
   */
  size: number;
}
/**
 *
 * @export
 * @interface FileList
 */
export interface FileList {
  /**
   * The array of returned file items
   * @type {Array<FileItem>}
   * @memberof FileList
   */
  results?: Array<FileItem>;
  /**
   *
   * @type {FileListLinks}
   * @memberof FileList
   */
  links?: FileListLinks;
}
/**
 * Links object containing the link for the next page of results
 * @export
 * @interface FileListLinks
 */
export interface FileListLinks {
  /**
   *
   * @type {string}
   * @memberof FileListLinks
   */
  next?: string | null;
}
/**
 * @type GetItems400Response
 * @export
 */
export type GetItems400Response =
  | ({ type: "problems/basic" } & BasicErrorResponse)
  | ({ type: "problems/validation" } & ValidationErrorResponse);

/**
 *
 * @export
 * @interface GetItemsResponse
 */
export interface GetItemsResponse {
  /**
   * Data values for all keys, ordered aplhabetically in pages of 20.
   * @type {Array<Item>}
   * @memberof GetItemsResponse
   */
  results: Array<Item>;
  /**
   *
   * @type {GetItemsResponseLinks}
   * @memberof GetItemsResponse
   */
  links: GetItemsResponseLinks;
}
/**
 *
 * @export
 * @interface GetItemsResponseLinks
 */
export interface GetItemsResponseLinks {
  /**
   * Contains the URL path for requesting the next page of results. This value is null when there are no pages remaining.
   * @type {string}
   * @memberof GetItemsResponseLinks
   */
  next: string | null;
}
/**
 *
 * @export
 * @interface GetKeysResponse
 */
export interface GetKeysResponse {
  /**
   * A paged list of keys for the given player, ordered alphabetically in pages of 100.
   * @type {Array<KeyMetadata>}
   * @memberof GetKeysResponse
   */
  results: Array<KeyMetadata>;
  /**
   *
   * @type {GetItemsResponseLinks}
   * @memberof GetKeysResponse
   */
  links: GetItemsResponseLinks;
}
/**
 * Response type for a Data Item stored in the Cloud Save service.
 * @export
 * @interface Item
 */
export interface Item {
  /**
   * Item key
   * @type {string}
   * @memberof Item
   */
  key: string;
  /**
   * Any JSON serializable structure with a maximum size of 5 MB.
   * @type {object}
   * @memberof Item
   */
  value: object;
  /**
   * Enforces conflict checking when updating an existing data item. This field should be omitted when creating a new data item. When updating an existing item, omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
   * @type {string}
   * @memberof Item
   */
  writeLock: string;
  /**
   *
   * @type {ModifiedMetadata}
   * @memberof Item
   */
  modified: ModifiedMetadata;
  /**
   *
   * @type {ModifiedMetadata}
   * @memberof Item
   */
  created: ModifiedMetadata;
}
/**
 * Response type Key with metadata for an individual data item stored in the Cloud Save service.
 * @export
 * @interface KeyMetadata
 */
export interface KeyMetadata {
  /**
   * Item key
   * @type {string}
   * @memberof KeyMetadata
   */
  key: string;
  /**
   * Enforces conflict checking when updating an existing data item. This field should be omitted when creating a new data item. When updating an existing item, omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
   * @type {string}
   * @memberof KeyMetadata
   */
  writeLock: string;
  /**
   *
   * @type {ModifiedMetadata}
   * @memberof KeyMetadata
   */
  modified: ModifiedMetadata;
}
/**
 * Timestamp for when the object was modified.
 * @export
 * @interface ModifiedMetadata
 */
export interface ModifiedMetadata {
  /**
   * Date time in ISO 8601 format. Null if there is no associated value.
   * @type {string}
   * @memberof ModifiedMetadata
   */
  date: string | null;
}
/**
 * The request body for querying an index
 * @export
 * @interface QueryIndexBody
 */
export interface QueryIndexBody {
  /**
   *
   * @type {Array<FieldFilter>}
   * @memberof QueryIndexBody
   */
  fields: Array<FieldFilter>;
  /**
   * The keys to return in the response. This can include keys not on the index. If not specified or empty, the data on the results will be empty for any returned entities.
   * @type {Array<string>}
   * @memberof QueryIndexBody
   */
  returnKeys?: Array<string>;
  /**
   * The number of results to skip. Defaults to 0.
   * @type {number}
   * @memberof QueryIndexBody
   */
  offset?: number;
  /**
   * The maximum number of results to return. Defaults to 10. Specifying 0 will return the default number of results.
   * @type {number}
   * @memberof QueryIndexBody
   */
  limit?: number;
}
/**
 * The response to an index query request containing a list of the resulting entity IDs and their associated data.
 * @export
 * @interface QueryIndexResponse
 */
export interface QueryIndexResponse {
  /**
   *
   * @type {Array<QueryIndexResponseResultsInner>}
   * @memberof QueryIndexResponse
   */
  results?: Array<QueryIndexResponseResultsInner>;
}
/**
 *
 * @export
 * @interface QueryIndexResponseResultsInner
 */
export interface QueryIndexResponseResultsInner {
  /**
   *
   * @type {QueryIndexResponseResultsInnerId}
   * @memberof QueryIndexResponseResultsInner
   */
  id?: QueryIndexResponseResultsInnerId;
  /**
   * The list of data key-value pairs for the entity
   * @type {Array<Item>}
   * @memberof QueryIndexResponseResultsInner
   */
  data?: Array<Item>;
}
/**
 * @type QueryIndexResponseResultsInnerId
 * The entity ID
 * @export
 */
export type QueryIndexResponseResultsInnerId = string;

/**
 * @type SetItemBatch400Response
 * @export
 */
export type SetItemBatch400Response =
  | ({ type: "problems/basic" } & BasicErrorResponse)
  | ({ type: "problems/batch-basic" } & BatchBasicErrorResponse)
  | ({ type: "problems/batch-validation" } & BatchValidationErrorResponse)
  | ({ type: "problems/validation" } & ValidationErrorResponse);

/**
 *
 * @export
 * @interface SetItemBatchBody
 */
export interface SetItemBatchBody {
  /**
   *
   * @type {Array<SetItemBody>}
   * @memberof SetItemBatchBody
   */
  data?: Array<SetItemBody>;
}
/**
 *
 * @export
 * @interface SetItemBatchResponse
 */
export interface SetItemBatchResponse {
  /**
   *
   * @type {Array<SetItemBatchResponseResultsInner>}
   * @memberof SetItemBatchResponse
   */
  results?: Array<SetItemBatchResponseResultsInner>;
}
/**
 *
 * @export
 * @interface SetItemBatchResponseResultsInner
 */
export interface SetItemBatchResponseResultsInner {
  /**
   * Item key
   * @type {string}
   * @memberof SetItemBatchResponseResultsInner
   */
  key: string;
  /**
   * Enforces conflict checking when updating an existing data item. This field should be omitted when creating a new data item. When updating an existing item, omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
   * @type {string}
   * @memberof SetItemBatchResponseResultsInner
   */
  writeLock: string;
}
/**
 * Request type for a Data Item to store in the Cloud Save service.
 * @export
 * @interface SetItemBody
 */
export interface SetItemBody {
  /**
   * Item key
   * @type {string}
   * @memberof SetItemBody
   */
  key: string;
  /**
   * Any JSON serializable structure with a maximum size of 5 MB.
   * @type {object}
   * @memberof SetItemBody
   */
  value: object;
  /**
   * Enforces conflict checking when updating an existing data item. This field should be omitted when creating a new data item. When updating an existing item, omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
   * @type {string}
   * @memberof SetItemBody
   */
  writeLock?: string;
}
/**
 * Newly generated writeLock for the item.
 * @export
 * @interface SetItemResponse
 */
export interface SetItemResponse {
  /**
   * Enforces conflict checking when updating an existing data item. This field should be omitted when creating a new data item. When updating an existing item, omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
   * @type {string}
   * @memberof SetItemResponse
   */
  writeLock: string;
}
/**
 *
 * @export
 * @interface SignedUrlResponse
 */
export interface SignedUrlResponse {
  /**
   * The signed URL used to access the resource.
   * @type {string}
   * @memberof SignedUrlResponse
   */
  signedUrl: string;
  /**
   * The HTTP method that must be used on the signedUrl.
   * @type {string}
   * @memberof SignedUrlResponse
   */
  httpMethod: string;
  /**
   * The set of HTTP headers that must be sent with the request for it to succeed.
   * @type {object}
   * @memberof SignedUrlResponse
   */
  requiredHeaders: object;
}
/**
 * Single error in the Validation Error Response.
 * @export
 * @interface ValidationErrorBody
 */
export interface ValidationErrorBody {
  /**
   *
   * @type {string}
   * @memberof ValidationErrorBody
   */
  field: string;
  /**
   *
   * @type {Array<string>}
   * @memberof ValidationErrorBody
   */
  messages: Array<string>;
}
/**
 * Validation error response when a value provided from the client does not pass validation on server.
 * @export
 * @interface ValidationErrorResponse
 */
export interface ValidationErrorResponse {
  /**
   *
   * @type {string}
   * @memberof ValidationErrorResponse
   */
  type: string;
  /**
   *
   * @type {string}
   * @memberof ValidationErrorResponse
   */
  title: string;
  /**
   *
   * @type {number}
   * @memberof ValidationErrorResponse
   */
  status: number;
  /**
   *
   * @type {number}
   * @memberof ValidationErrorResponse
   */
  code: number;
  /**
   *
   * @type {string}
   * @memberof ValidationErrorResponse
   */
  detail: string;
  /**
   *
   * @type {string}
   * @memberof ValidationErrorResponse
   */
  instance?: string;
  /**
   *
   * @type {Array<ValidationErrorBody>}
   * @memberof ValidationErrorResponse
   */
  errors: Array<ValidationErrorBody>;
}

/**
 * DataApi - axios parameter creator
 * @export
 */
export const DataApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Deletes a data item by the specified key for the specified custom ID. Only accessible via an authenticated server authority.
     * @summary Delete Custom Item
     * @param {string} key Item key.
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {string} [writeLock] Enforces conflict checking when deleting an existing data item. Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCustomItem: async (
      key: string,
      projectId: string,
      customId: string,
      writeLock?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'key' is not null or undefined
      assertParamExists("deleteCustomItem", "key", key);
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("deleteCustomItem", "projectId", projectId);
      // verify required parameter 'customId' is not null or undefined
      assertParamExists("deleteCustomItem", "customId", customId);
      const localVarPath =
        `/v1/data/projects/{projectId}/custom/{customId}/items/{key}`
          .replace(`{${"key"}}`, encodeURIComponent(String(key)))
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"customId"}}`, encodeURIComponent(String(customId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (writeLock !== undefined) {
        localVarQueryParameter["writeLock"] = writeLock;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes all default access level data associated with a given custom ID. Only accessible via an authenticated server authority.
     * @summary Delete Custom Items
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCustomItems: async (
      projectId: string,
      customId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("deleteCustomItems", "projectId", projectId);
      // verify required parameter 'customId' is not null or undefined
      assertParamExists("deleteCustomItems", "customId", customId);
      const localVarPath =
        `/v1/data/projects/{projectId}/custom/{customId}/items`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"customId"}}`, encodeURIComponent(String(customId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes a data item by the specified key for the given player.
     * @summary Delete Player Item
     * @param {string} key Item key.
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} [writeLock] Enforces conflict checking when deleting an existing data item. Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteItem: async (
      key: string,
      projectId: string,
      playerId: string,
      writeLock?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'key' is not null or undefined
      assertParamExists("deleteItem", "key", key);
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("deleteItem", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("deleteItem", "playerId", playerId);
      const localVarPath =
        `/v1/data/projects/{projectId}/players/{playerId}/items/{key}`
          .replace(`{${"key"}}`, encodeURIComponent(String(key)))
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication Client required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (writeLock !== undefined) {
        localVarQueryParameter["writeLock"] = writeLock;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes all default access level data associated with a given player.
     * @summary Delete Player Items
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteItems: async (
      projectId: string,
      playerId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("deleteItems", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("deleteItems", "playerId", playerId);
      const localVarPath =
        `/v1/data/projects/{projectId}/players/{playerId}/items`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication Client required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes a private data item by the specified key for the specified custom ID. Only accessible via an authenticated server authority.
     * @summary Delete Private Custom Item
     * @param {string} key Item key.
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {string} [writeLock] Enforces conflict checking when deleting an existing data item. Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePrivateCustomItem: async (
      key: string,
      projectId: string,
      customId: string,
      writeLock?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'key' is not null or undefined
      assertParamExists("deletePrivateCustomItem", "key", key);
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("deletePrivateCustomItem", "projectId", projectId);
      // verify required parameter 'customId' is not null or undefined
      assertParamExists("deletePrivateCustomItem", "customId", customId);
      const localVarPath =
        `/v1/data/projects/{projectId}/custom/{customId}/private/items/{key}`
          .replace(`{${"key"}}`, encodeURIComponent(String(key)))
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"customId"}}`, encodeURIComponent(String(customId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (writeLock !== undefined) {
        localVarQueryParameter["writeLock"] = writeLock;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes all private data associated with a given custom ID. Only accessible via an authenticated server authority.
     * @summary Delete Private Custom Items
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePrivateCustomItems: async (
      projectId: string,
      customId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("deletePrivateCustomItems", "projectId", projectId);
      // verify required parameter 'customId' is not null or undefined
      assertParamExists("deletePrivateCustomItems", "customId", customId);
      const localVarPath =
        `/v1/data/projects/{projectId}/custom/{customId}/private/items`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"customId"}}`, encodeURIComponent(String(customId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes a protected data item by the specified key for the given player. Only accessible via an authenticated server authority.
     * @summary Delete Protected Player Item
     * @param {string} key Item key.
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} [writeLock] Enforces conflict checking when deleting an existing data item. Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProtectedItem: async (
      key: string,
      projectId: string,
      playerId: string,
      writeLock?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'key' is not null or undefined
      assertParamExists("deleteProtectedItem", "key", key);
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("deleteProtectedItem", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("deleteProtectedItem", "playerId", playerId);
      const localVarPath =
        `/v1/data/projects/{projectId}/players/{playerId}/protected/items/{key}`
          .replace(`{${"key"}}`, encodeURIComponent(String(key)))
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (writeLock !== undefined) {
        localVarQueryParameter["writeLock"] = writeLock;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes all protected data associated with a given player. Only accessible via an authenticated server authority.
     * @summary Delete Protected Player Items
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProtectedItems: async (
      projectId: string,
      playerId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("deleteProtectedItems", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("deleteProtectedItems", "playerId", playerId);
      const localVarPath =
        `/v1/data/projects/{projectId}/players/{playerId}/protected/items`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes a public data item by the specified key for the given player.
     * @summary Delete Public Player Item
     * @param {string} key Item key.
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} [writeLock] Enforces conflict checking when deleting an existing data item. Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePublicItem: async (
      key: string,
      projectId: string,
      playerId: string,
      writeLock?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'key' is not null or undefined
      assertParamExists("deletePublicItem", "key", key);
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("deletePublicItem", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("deletePublicItem", "playerId", playerId);
      const localVarPath =
        `/v1/data/projects/{projectId}/players/{playerId}/public/items/{key}`
          .replace(`{${"key"}}`, encodeURIComponent(String(key)))
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication Client required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (writeLock !== undefined) {
        localVarQueryParameter["writeLock"] = writeLock;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes all public data associated with a given player.
     * @summary Delete Public Player Items
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePublicItems: async (
      projectId: string,
      playerId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("deletePublicItems", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("deletePublicItems", "playerId", playerId);
      const localVarPath =
        `/v1/data/projects/{projectId}/players/{playerId}/public/items`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication Client required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves saved data values for all keys specified, ordered alphabetically in pages of 20. If no keys are supplied then returns all keys, ordered alphabetically in pages of 20.
     * @summary Get Custom Items
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {Array<string>} [keys] The keys to retrieve, in exploded form style, e.g. &#x60;keys&#x3D;KEY1&amp;keys&#x3D;KEY2&amp;keys&#x3D;KEY3&#x60;.
     * @param {string} [after] The key after which to retrieve the next page of keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCustomItems: async (
      projectId: string,
      customId: string,
      keys?: Array<string>,
      after?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("getCustomItems", "projectId", projectId);
      // verify required parameter 'customId' is not null or undefined
      assertParamExists("getCustomItems", "customId", customId);
      const localVarPath =
        `/v1/data/projects/{projectId}/custom/{customId}/items`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"customId"}}`, encodeURIComponent(String(customId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication Client required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (keys) {
        localVarQueryParameter["keys"] = keys;
      }

      if (after !== undefined) {
        localVarQueryParameter["after"] = after;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Gets a paged list of keys for the given custom ID, ordered alphabetically in pages of 100.
     * @summary Get Custom Keys
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {string} [after] Returns the page of results after the key specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCustomKeys: async (
      projectId: string,
      customId: string,
      after?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("getCustomKeys", "projectId", projectId);
      // verify required parameter 'customId' is not null or undefined
      assertParamExists("getCustomKeys", "customId", customId);
      const localVarPath =
        `/v1/data/projects/{projectId}/custom/{customId}/keys`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"customId"}}`, encodeURIComponent(String(customId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication Client required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (after !== undefined) {
        localVarQueryParameter["after"] = after;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves saved data values for all keys specified, ordered alphabetically in pages of 20. If no keys are supplied then returns all keys, ordered alphabetically in pages of 20.
     * @summary Get Player Items
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {Array<string>} [keys] The keys to retrieve, in exploded form style, e.g. &#x60;keys&#x3D;KEY1&amp;keys&#x3D;KEY2&amp;keys&#x3D;KEY3&#x60;.
     * @param {string} [after] The key after which to retrieve the next page of keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getItems: async (
      projectId: string,
      playerId: string,
      keys?: Array<string>,
      after?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("getItems", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("getItems", "playerId", playerId);
      const localVarPath =
        `/v1/data/projects/{projectId}/players/{playerId}/items`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication Client required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (keys) {
        localVarQueryParameter["keys"] = keys;
      }

      if (after !== undefined) {
        localVarQueryParameter["after"] = after;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Gets a paged list of keys for the given player, ordered alphabetically in pages of 100.
     * @summary Get Player Keys
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} [after] Returns the page of results after the key specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getKeys: async (
      projectId: string,
      playerId: string,
      after?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("getKeys", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("getKeys", "playerId", playerId);
      const localVarPath =
        `/v1/data/projects/{projectId}/players/{playerId}/keys`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication Client required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (after !== undefined) {
        localVarQueryParameter["after"] = after;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves private save data values for all keys specified, ordered alphabetically in pages of 20. If no keys are supplied then returns all keys, ordered alphabetically in pages of 20. Only accessible via an authenticated server authority.
     * @summary Get Private Custom Items
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {Array<string>} [keys] The keys to retrieve, in exploded form style, e.g. &#x60;keys&#x3D;KEY1&amp;keys&#x3D;KEY2&amp;keys&#x3D;KEY3&#x60;.
     * @param {string} [after] The key after which to retrieve the next page of keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPrivateCustomItems: async (
      projectId: string,
      customId: string,
      keys?: Array<string>,
      after?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("getPrivateCustomItems", "projectId", projectId);
      // verify required parameter 'customId' is not null or undefined
      assertParamExists("getPrivateCustomItems", "customId", customId);
      const localVarPath =
        `/v1/data/projects/{projectId}/custom/{customId}/private/items`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"customId"}}`, encodeURIComponent(String(customId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (keys) {
        localVarQueryParameter["keys"] = keys;
      }

      if (after !== undefined) {
        localVarQueryParameter["after"] = after;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Gets a paged list of private keys for the given custom ID, ordered alphabetically in pages of 100. Only accessible via an authenticated server authority.
     * @summary Get Private Custom Keys
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {string} [after] Returns the page of results after the key specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPrivateCustomKeys: async (
      projectId: string,
      customId: string,
      after?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("getPrivateCustomKeys", "projectId", projectId);
      // verify required parameter 'customId' is not null or undefined
      assertParamExists("getPrivateCustomKeys", "customId", customId);
      const localVarPath =
        `/v1/data/projects/{projectId}/custom/{customId}/private/keys`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"customId"}}`, encodeURIComponent(String(customId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (after !== undefined) {
        localVarQueryParameter["after"] = after;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves protected save data values for all keys specified, ordered alphabetically in pages of 20. If no keys are supplied then returns all keys, ordered alphabetically in pages of 20.
     * @summary Get Protected Player Items
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {Array<string>} [keys] The keys to retrieve, in exploded form style, e.g. &#x60;keys&#x3D;KEY1&amp;keys&#x3D;KEY2&amp;keys&#x3D;KEY3&#x60;.
     * @param {string} [after] The key after which to retrieve the next page of keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProtectedItems: async (
      projectId: string,
      playerId: string,
      keys?: Array<string>,
      after?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("getProtectedItems", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("getProtectedItems", "playerId", playerId);
      const localVarPath =
        `/v1/data/projects/{projectId}/players/{playerId}/protected/items`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication Client required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (keys) {
        localVarQueryParameter["keys"] = keys;
      }

      if (after !== undefined) {
        localVarQueryParameter["after"] = after;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Gets a paged list of protected keys for the given player, ordered alphabetically in pages of 100.
     * @summary Get Protected Player Keys
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} [after] Returns the page of results after the key specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProtectedKeys: async (
      projectId: string,
      playerId: string,
      after?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("getProtectedKeys", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("getProtectedKeys", "playerId", playerId);
      const localVarPath =
        `/v1/data/projects/{projectId}/players/{playerId}/protected/keys`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication Client required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (after !== undefined) {
        localVarQueryParameter["after"] = after;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves saved data values for all keys specified, ordered alphabetically in pages of 20. If no keys are supplied then returns all keys, ordered alphabetically in pages of 20. Accessible by any player for any other player\'s data.
     * @summary Get Public Player Items
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {Array<string>} [keys] The keys to retrieve, in exploded form style, e.g. &#x60;keys&#x3D;KEY1&amp;keys&#x3D;KEY2&amp;keys&#x3D;KEY3&#x60;.
     * @param {string} [after] The key after which to retrieve the next page of keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPublicItems: async (
      projectId: string,
      playerId: string,
      keys?: Array<string>,
      after?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("getPublicItems", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("getPublicItems", "playerId", playerId);
      const localVarPath =
        `/v1/data/projects/{projectId}/players/{playerId}/public/items`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication Client required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (keys) {
        localVarQueryParameter["keys"] = keys;
      }

      if (after !== undefined) {
        localVarQueryParameter["after"] = after;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Gets a paged list of public keys for the given player, ordered alphabetically in pages of 100. Accessible by any player for any other player\'s data.
     * @summary Get Public Player Keys
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} [after] Returns the page of results after the key specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPublicKeys: async (
      projectId: string,
      playerId: string,
      after?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("getPublicKeys", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("getPublicKeys", "playerId", playerId);
      const localVarPath =
        `/v1/data/projects/{projectId}/players/{playerId}/public/keys`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication Client required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (after !== undefined) {
        localVarQueryParameter["after"] = after;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Query custom data with the default access class. If no index is available to fulfil the query then the query will fail
     * @summary Query Default Custom Data
     * @param {string} projectId ID of the project.
     * @param {QueryIndexBody} [queryIndexBody] Query object with an array of conditions to query the data with.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryDefaultCustomData: async (
      projectId: string,
      queryIndexBody?: QueryIndexBody,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("queryDefaultCustomData", "projectId", projectId);
      const localVarPath = `/v1/data/projects/{projectId}/custom/query`.replace(
        `{${"projectId"}}`,
        encodeURIComponent(String(projectId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication Client required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        queryIndexBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Query player data with the default access class. If no index is available to fulfil the query then the query will fail.
     * @summary Query Default Player Data
     * @param {string} projectId ID of the project.
     * @param {QueryIndexBody} [queryIndexBody] Query object with an array of conditions to query the data with.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryDefaultPlayerData: async (
      projectId: string,
      queryIndexBody?: QueryIndexBody,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("queryDefaultPlayerData", "projectId", projectId);
      const localVarPath =
        `/v1/data/projects/{projectId}/players/query`.replace(
          `{${"projectId"}}`,
          encodeURIComponent(String(projectId)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        queryIndexBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Query custom data with the private access class. If no index is available to fulfil the query then the query will fail.
     * @summary Query Private Custom Data
     * @param {string} projectId ID of the project.
     * @param {QueryIndexBody} [queryIndexBody] Query object with an array of conditions to query the data with.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryPrivateCustomData: async (
      projectId: string,
      queryIndexBody?: QueryIndexBody,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("queryPrivateCustomData", "projectId", projectId);
      const localVarPath =
        `/v1/data/projects/{projectId}/custom/private/query`.replace(
          `{${"projectId"}}`,
          encodeURIComponent(String(projectId)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        queryIndexBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Query player data with the protected access class. If no index is available to fulfil the query then the query will fail.
     * @summary Query Protected Player Data
     * @param {string} projectId ID of the project.
     * @param {QueryIndexBody} [queryIndexBody] Query object with an array of conditions to query the data with.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryProtectedPlayerData: async (
      projectId: string,
      queryIndexBody?: QueryIndexBody,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("queryProtectedPlayerData", "projectId", projectId);
      const localVarPath =
        `/v1/data/projects/{projectId}/players/protected/query`.replace(
          `{${"projectId"}}`,
          encodeURIComponent(String(projectId)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        queryIndexBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Query player data with the public access class. If no index is available to fulfil the query then the query will fail.
     * @summary Query Public Player Data
     * @param {string} projectId ID of the project.
     * @param {QueryIndexBody} [queryIndexBody] Query object with an array of conditions to query the data with.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryPublicPlayerData: async (
      projectId: string,
      queryIndexBody?: QueryIndexBody,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("queryPublicPlayerData", "projectId", projectId);
      const localVarPath =
        `/v1/data/projects/{projectId}/players/public/query`.replace(
          `{${"projectId"}}`,
          encodeURIComponent(String(projectId)),
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication Client required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        queryIndexBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Set a data item with a given key and value for the specified custom ID. The value is limited to a maximum size of 5 MB across all default access level slots. The entire default access level saved state for a custom ID is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error. Only accessible via an authenticated server authority.
     * @summary Set Custom Item
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {SetItemBody} [setItemBody] Add a data item to store for a custom ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setCustomItem: async (
      projectId: string,
      customId: string,
      setItemBody?: SetItemBody,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("setCustomItem", "projectId", projectId);
      // verify required parameter 'customId' is not null or undefined
      assertParamExists("setCustomItem", "customId", customId);
      const localVarPath =
        `/v1/data/projects/{projectId}/custom/{customId}/items`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"customId"}}`, encodeURIComponent(String(customId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        setItemBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Set up to 20 data items with key, value and optional writeLock against the custom ID. The values are limited to a maximum size of 5 MB across all default access level slots for the custom ID. The entire default access level saved state for a custom ID is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error. The batch set operation is considered atomic and if any of the set key operation fails, the entire operation is failed. Error responses should identify the affected key operations that failed. Only accessible via an authenticated server authority.
     * @summary Set Custom Item Batch
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {SetItemBatchBody} [setItemBatchBody] Set batch data items for a custom ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setCustomItemBatch: async (
      projectId: string,
      customId: string,
      setItemBatchBody?: SetItemBatchBody,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("setCustomItemBatch", "projectId", projectId);
      // verify required parameter 'customId' is not null or undefined
      assertParamExists("setCustomItemBatch", "customId", customId);
      const localVarPath =
        `/v1/data/projects/{projectId}/custom/{customId}/item-batch`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"customId"}}`, encodeURIComponent(String(customId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        setItemBatchBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Set a data item with a given key and value for the specified player. The value is limited to a maximum size of 5 MB across all default access level slots. The entire default access level saved state for a player is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error.
     * @summary Set Player Item
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {SetItemBody} [setItemBody] Add a data item to store for a player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setItem: async (
      projectId: string,
      playerId: string,
      setItemBody?: SetItemBody,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("setItem", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("setItem", "playerId", playerId);
      const localVarPath =
        `/v1/data/projects/{projectId}/players/{playerId}/items`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication Client required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        setItemBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Set up to 20 data items with key, value and optional writeLock for the given player. The values are limited to a maximum size of 5 MB across all default access level slots for the player. The entire default access level saved state for a player is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error. The batch set operation is considered atomic and if any of the set key operation fails, the entire operation is failed. Error responses should identify the affected key operations that failed.
     * @summary Set Player Item Batch
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {SetItemBatchBody} [setItemBatchBody] Set batch data items for a player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setItemBatch: async (
      projectId: string,
      playerId: string,
      setItemBatchBody?: SetItemBatchBody,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("setItemBatch", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("setItemBatch", "playerId", playerId);
      const localVarPath =
        `/v1/data/projects/{projectId}/players/{playerId}/item-batch`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication Client required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        setItemBatchBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Set a private data item with a given key and value for the specified custom ID. The value is limited to a maximum size of 5 MB across all private access level slots. The entire private saved state for a custom ID is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error. Only accessible via an authenticated server authority.
     * @summary Set Private Custom Item
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {SetItemBody} [setItemBody] Add a data item to store for a custom ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setPrivateCustomItem: async (
      projectId: string,
      customId: string,
      setItemBody?: SetItemBody,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("setPrivateCustomItem", "projectId", projectId);
      // verify required parameter 'customId' is not null or undefined
      assertParamExists("setPrivateCustomItem", "customId", customId);
      const localVarPath =
        `/v1/data/projects/{projectId}/custom/{customId}/private/items`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"customId"}}`, encodeURIComponent(String(customId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        setItemBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Set up to 20 private data items with key, value and optional writeLock against the custom ID. The values are limited to a maximum size of 5 MB across all private access level slots for the custom ID. The entire private saved state for a custom ID is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error. The batch set operation is considered atomic and if any of the set key operation fails, the entire operation is failed. Error responses should identify the affected key operations that failed. Only accessible via an authenticated server authority.
     * @summary Set Private Custom Item Batch
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {SetItemBatchBody} [setItemBatchBody] Set batch data items for a custom ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setPrivateCustomItemBatch: async (
      projectId: string,
      customId: string,
      setItemBatchBody?: SetItemBatchBody,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("setPrivateCustomItemBatch", "projectId", projectId);
      // verify required parameter 'customId' is not null or undefined
      assertParamExists("setPrivateCustomItemBatch", "customId", customId);
      const localVarPath =
        `/v1/data/projects/{projectId}/custom/{customId}/private/item-batch`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"customId"}}`, encodeURIComponent(String(customId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        setItemBatchBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Set a protected data item with a given key and value for the specified player. The value is limited to a maximum size of 5 MB across all protected access level slots. The entire protected saved state for a player is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error. Only accessible via an authenticated server authority.
     * @summary Set Protected Player Item
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {SetItemBody} [setItemBody] Add a data item to store for a player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setProtectedItem: async (
      projectId: string,
      playerId: string,
      setItemBody?: SetItemBody,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("setProtectedItem", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("setProtectedItem", "playerId", playerId);
      const localVarPath =
        `/v1/data/projects/{projectId}/players/{playerId}/protected/items`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        setItemBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Set up to 20 protected data items with key, value and optional writeLock for the given player. The values are limited to a maximum size of 5 MB across all slots for the player. The entire protected saved state for a player is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error. The batch set operation is considered atomic and if any of the set key operation fails, the entire operation is failed. Error responses should identify the affected key operations that failed. Only accessible via an authenticated server authority.
     * @summary Set Protected Player Item Batch
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {SetItemBatchBody} [setItemBatchBody] Set batch data items for a player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setProtectedItemBatch: async (
      projectId: string,
      playerId: string,
      setItemBatchBody?: SetItemBatchBody,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("setProtectedItemBatch", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("setProtectedItemBatch", "playerId", playerId);
      const localVarPath =
        `/v1/data/projects/{projectId}/players/{playerId}/protected/item-batch`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        setItemBatchBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Set a public data item with a given key and value for the specified player. The value is limited to a maximum size of 5 MB across all public access level slots. The entire public saved state for a player is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error. The value set will be publicly readable by any player.
     * @summary Set Public Player Item
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {SetItemBody} [setItemBody] Add a data item to store for a player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setPublicItem: async (
      projectId: string,
      playerId: string,
      setItemBody?: SetItemBody,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("setPublicItem", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("setPublicItem", "playerId", playerId);
      const localVarPath =
        `/v1/data/projects/{projectId}/players/{playerId}/public/items`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication Client required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        setItemBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Set up to 20 public data items with key, value and optional writeLock for the given player. The values are limited to a maximum size of 5 MB across all slots for the player. The entire public saved state for a player is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error. The batch set operation is considered atomic and if any of the set key operation fails, the entire operation is failed. Error responses should identify the affected key operations that failed.
     * @summary Set Public Player Item Batch
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {SetItemBatchBody} [setItemBatchBody] Set batch data items for a player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setPublicItemBatch: async (
      projectId: string,
      playerId: string,
      setItemBatchBody?: SetItemBatchBody,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("setPublicItemBatch", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("setPublicItemBatch", "playerId", playerId);
      const localVarPath =
        `/v1/data/projects/{projectId}/players/{playerId}/public/item-batch`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication Client required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        setItemBatchBody,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DataApi - functional programming interface
 * @export
 */
export const DataApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = DataApiAxiosParamCreator(configuration);
  return {
    /**
     * Deletes a data item by the specified key for the specified custom ID. Only accessible via an authenticated server authority.
     * @summary Delete Custom Item
     * @param {string} key Item key.
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {string} [writeLock] Enforces conflict checking when deleting an existing data item. Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteCustomItem(
      key: string,
      projectId: string,
      customId: string,
      writeLock?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteCustomItem(
          key,
          projectId,
          customId,
          writeLock,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Deletes all default access level data associated with a given custom ID. Only accessible via an authenticated server authority.
     * @summary Delete Custom Items
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteCustomItems(
      projectId: string,
      customId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteCustomItems(
          projectId,
          customId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Deletes a data item by the specified key for the given player.
     * @summary Delete Player Item
     * @param {string} key Item key.
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} [writeLock] Enforces conflict checking when deleting an existing data item. Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteItem(
      key: string,
      projectId: string,
      playerId: string,
      writeLock?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItem(
        key,
        projectId,
        playerId,
        writeLock,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Deletes all default access level data associated with a given player.
     * @summary Delete Player Items
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteItems(
      projectId: string,
      playerId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItems(
        projectId,
        playerId,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Deletes a private data item by the specified key for the specified custom ID. Only accessible via an authenticated server authority.
     * @summary Delete Private Custom Item
     * @param {string} key Item key.
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {string} [writeLock] Enforces conflict checking when deleting an existing data item. Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletePrivateCustomItem(
      key: string,
      projectId: string,
      customId: string,
      writeLock?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deletePrivateCustomItem(
          key,
          projectId,
          customId,
          writeLock,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Deletes all private data associated with a given custom ID. Only accessible via an authenticated server authority.
     * @summary Delete Private Custom Items
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletePrivateCustomItems(
      projectId: string,
      customId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deletePrivateCustomItems(
          projectId,
          customId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Deletes a protected data item by the specified key for the given player. Only accessible via an authenticated server authority.
     * @summary Delete Protected Player Item
     * @param {string} key Item key.
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} [writeLock] Enforces conflict checking when deleting an existing data item. Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteProtectedItem(
      key: string,
      projectId: string,
      playerId: string,
      writeLock?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteProtectedItem(
          key,
          projectId,
          playerId,
          writeLock,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Deletes all protected data associated with a given player. Only accessible via an authenticated server authority.
     * @summary Delete Protected Player Items
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteProtectedItems(
      projectId: string,
      playerId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deleteProtectedItems(
          projectId,
          playerId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Deletes a public data item by the specified key for the given player.
     * @summary Delete Public Player Item
     * @param {string} key Item key.
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} [writeLock] Enforces conflict checking when deleting an existing data item. Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletePublicItem(
      key: string,
      projectId: string,
      playerId: string,
      writeLock?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deletePublicItem(
          key,
          projectId,
          playerId,
          writeLock,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Deletes all public data associated with a given player.
     * @summary Delete Public Player Items
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletePublicItems(
      projectId: string,
      playerId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.deletePublicItems(
          projectId,
          playerId,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Retrieves saved data values for all keys specified, ordered alphabetically in pages of 20. If no keys are supplied then returns all keys, ordered alphabetically in pages of 20.
     * @summary Get Custom Items
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {Array<string>} [keys] The keys to retrieve, in exploded form style, e.g. &#x60;keys&#x3D;KEY1&amp;keys&#x3D;KEY2&amp;keys&#x3D;KEY3&#x60;.
     * @param {string} [after] The key after which to retrieve the next page of keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCustomItems(
      projectId: string,
      customId: string,
      keys?: Array<string>,
      after?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GetItemsResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomItems(
        projectId,
        customId,
        keys,
        after,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Gets a paged list of keys for the given custom ID, ordered alphabetically in pages of 100.
     * @summary Get Custom Keys
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {string} [after] Returns the page of results after the key specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCustomKeys(
      projectId: string,
      customId: string,
      after?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GetKeysResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomKeys(
        projectId,
        customId,
        after,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Retrieves saved data values for all keys specified, ordered alphabetically in pages of 20. If no keys are supplied then returns all keys, ordered alphabetically in pages of 20.
     * @summary Get Player Items
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {Array<string>} [keys] The keys to retrieve, in exploded form style, e.g. &#x60;keys&#x3D;KEY1&amp;keys&#x3D;KEY2&amp;keys&#x3D;KEY3&#x60;.
     * @param {string} [after] The key after which to retrieve the next page of keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getItems(
      projectId: string,
      playerId: string,
      keys?: Array<string>,
      after?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GetItemsResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getItems(
        projectId,
        playerId,
        keys,
        after,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Gets a paged list of keys for the given player, ordered alphabetically in pages of 100.
     * @summary Get Player Keys
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} [after] Returns the page of results after the key specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getKeys(
      projectId: string,
      playerId: string,
      after?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GetKeysResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getKeys(
        projectId,
        playerId,
        after,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Retrieves private save data values for all keys specified, ordered alphabetically in pages of 20. If no keys are supplied then returns all keys, ordered alphabetically in pages of 20. Only accessible via an authenticated server authority.
     * @summary Get Private Custom Items
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {Array<string>} [keys] The keys to retrieve, in exploded form style, e.g. &#x60;keys&#x3D;KEY1&amp;keys&#x3D;KEY2&amp;keys&#x3D;KEY3&#x60;.
     * @param {string} [after] The key after which to retrieve the next page of keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPrivateCustomItems(
      projectId: string,
      customId: string,
      keys?: Array<string>,
      after?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GetItemsResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPrivateCustomItems(
          projectId,
          customId,
          keys,
          after,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Gets a paged list of private keys for the given custom ID, ordered alphabetically in pages of 100. Only accessible via an authenticated server authority.
     * @summary Get Private Custom Keys
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {string} [after] Returns the page of results after the key specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPrivateCustomKeys(
      projectId: string,
      customId: string,
      after?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GetKeysResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getPrivateCustomKeys(
          projectId,
          customId,
          after,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Retrieves protected save data values for all keys specified, ordered alphabetically in pages of 20. If no keys are supplied then returns all keys, ordered alphabetically in pages of 20.
     * @summary Get Protected Player Items
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {Array<string>} [keys] The keys to retrieve, in exploded form style, e.g. &#x60;keys&#x3D;KEY1&amp;keys&#x3D;KEY2&amp;keys&#x3D;KEY3&#x60;.
     * @param {string} [after] The key after which to retrieve the next page of keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getProtectedItems(
      projectId: string,
      playerId: string,
      keys?: Array<string>,
      after?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GetItemsResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getProtectedItems(
          projectId,
          playerId,
          keys,
          after,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Gets a paged list of protected keys for the given player, ordered alphabetically in pages of 100.
     * @summary Get Protected Player Keys
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} [after] Returns the page of results after the key specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getProtectedKeys(
      projectId: string,
      playerId: string,
      after?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GetKeysResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getProtectedKeys(
          projectId,
          playerId,
          after,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Retrieves saved data values for all keys specified, ordered alphabetically in pages of 20. If no keys are supplied then returns all keys, ordered alphabetically in pages of 20. Accessible by any player for any other player\'s data.
     * @summary Get Public Player Items
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {Array<string>} [keys] The keys to retrieve, in exploded form style, e.g. &#x60;keys&#x3D;KEY1&amp;keys&#x3D;KEY2&amp;keys&#x3D;KEY3&#x60;.
     * @param {string} [after] The key after which to retrieve the next page of keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPublicItems(
      projectId: string,
      playerId: string,
      keys?: Array<string>,
      after?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GetItemsResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicItems(
        projectId,
        playerId,
        keys,
        after,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Gets a paged list of public keys for the given player, ordered alphabetically in pages of 100. Accessible by any player for any other player\'s data.
     * @summary Get Public Player Keys
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} [after] Returns the page of results after the key specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPublicKeys(
      projectId: string,
      playerId: string,
      after?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<GetKeysResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicKeys(
        projectId,
        playerId,
        after,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Query custom data with the default access class. If no index is available to fulfil the query then the query will fail
     * @summary Query Default Custom Data
     * @param {string} projectId ID of the project.
     * @param {QueryIndexBody} [queryIndexBody] Query object with an array of conditions to query the data with.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async queryDefaultCustomData(
      projectId: string,
      queryIndexBody?: QueryIndexBody,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<QueryIndexResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.queryDefaultCustomData(
          projectId,
          queryIndexBody,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Query player data with the default access class. If no index is available to fulfil the query then the query will fail.
     * @summary Query Default Player Data
     * @param {string} projectId ID of the project.
     * @param {QueryIndexBody} [queryIndexBody] Query object with an array of conditions to query the data with.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async queryDefaultPlayerData(
      projectId: string,
      queryIndexBody?: QueryIndexBody,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<QueryIndexResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.queryDefaultPlayerData(
          projectId,
          queryIndexBody,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Query custom data with the private access class. If no index is available to fulfil the query then the query will fail.
     * @summary Query Private Custom Data
     * @param {string} projectId ID of the project.
     * @param {QueryIndexBody} [queryIndexBody] Query object with an array of conditions to query the data with.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async queryPrivateCustomData(
      projectId: string,
      queryIndexBody?: QueryIndexBody,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<QueryIndexResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.queryPrivateCustomData(
          projectId,
          queryIndexBody,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Query player data with the protected access class. If no index is available to fulfil the query then the query will fail.
     * @summary Query Protected Player Data
     * @param {string} projectId ID of the project.
     * @param {QueryIndexBody} [queryIndexBody] Query object with an array of conditions to query the data with.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async queryProtectedPlayerData(
      projectId: string,
      queryIndexBody?: QueryIndexBody,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<QueryIndexResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.queryProtectedPlayerData(
          projectId,
          queryIndexBody,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Query player data with the public access class. If no index is available to fulfil the query then the query will fail.
     * @summary Query Public Player Data
     * @param {string} projectId ID of the project.
     * @param {QueryIndexBody} [queryIndexBody] Query object with an array of conditions to query the data with.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async queryPublicPlayerData(
      projectId: string,
      queryIndexBody?: QueryIndexBody,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<QueryIndexResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.queryPublicPlayerData(
          projectId,
          queryIndexBody,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Set a data item with a given key and value for the specified custom ID. The value is limited to a maximum size of 5 MB across all default access level slots. The entire default access level saved state for a custom ID is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error. Only accessible via an authenticated server authority.
     * @summary Set Custom Item
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {SetItemBody} [setItemBody] Add a data item to store for a custom ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setCustomItem(
      projectId: string,
      customId: string,
      setItemBody?: SetItemBody,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SetItemResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setCustomItem(
        projectId,
        customId,
        setItemBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Set up to 20 data items with key, value and optional writeLock against the custom ID. The values are limited to a maximum size of 5 MB across all default access level slots for the custom ID. The entire default access level saved state for a custom ID is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error. The batch set operation is considered atomic and if any of the set key operation fails, the entire operation is failed. Error responses should identify the affected key operations that failed. Only accessible via an authenticated server authority.
     * @summary Set Custom Item Batch
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {SetItemBatchBody} [setItemBatchBody] Set batch data items for a custom ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setCustomItemBatch(
      projectId: string,
      customId: string,
      setItemBatchBody?: SetItemBatchBody,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SetItemBatchResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.setCustomItemBatch(
          projectId,
          customId,
          setItemBatchBody,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Set a data item with a given key and value for the specified player. The value is limited to a maximum size of 5 MB across all default access level slots. The entire default access level saved state for a player is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error.
     * @summary Set Player Item
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {SetItemBody} [setItemBody] Add a data item to store for a player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setItem(
      projectId: string,
      playerId: string,
      setItemBody?: SetItemBody,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SetItemResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setItem(
        projectId,
        playerId,
        setItemBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Set up to 20 data items with key, value and optional writeLock for the given player. The values are limited to a maximum size of 5 MB across all default access level slots for the player. The entire default access level saved state for a player is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error. The batch set operation is considered atomic and if any of the set key operation fails, the entire operation is failed. Error responses should identify the affected key operations that failed.
     * @summary Set Player Item Batch
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {SetItemBatchBody} [setItemBatchBody] Set batch data items for a player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setItemBatch(
      projectId: string,
      playerId: string,
      setItemBatchBody?: SetItemBatchBody,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SetItemBatchResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setItemBatch(
        projectId,
        playerId,
        setItemBatchBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Set a private data item with a given key and value for the specified custom ID. The value is limited to a maximum size of 5 MB across all private access level slots. The entire private saved state for a custom ID is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error. Only accessible via an authenticated server authority.
     * @summary Set Private Custom Item
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {SetItemBody} [setItemBody] Add a data item to store for a custom ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setPrivateCustomItem(
      projectId: string,
      customId: string,
      setItemBody?: SetItemBody,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SetItemResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.setPrivateCustomItem(
          projectId,
          customId,
          setItemBody,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Set up to 20 private data items with key, value and optional writeLock against the custom ID. The values are limited to a maximum size of 5 MB across all private access level slots for the custom ID. The entire private saved state for a custom ID is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error. The batch set operation is considered atomic and if any of the set key operation fails, the entire operation is failed. Error responses should identify the affected key operations that failed. Only accessible via an authenticated server authority.
     * @summary Set Private Custom Item Batch
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {SetItemBatchBody} [setItemBatchBody] Set batch data items for a custom ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setPrivateCustomItemBatch(
      projectId: string,
      customId: string,
      setItemBatchBody?: SetItemBatchBody,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SetItemBatchResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.setPrivateCustomItemBatch(
          projectId,
          customId,
          setItemBatchBody,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Set a protected data item with a given key and value for the specified player. The value is limited to a maximum size of 5 MB across all protected access level slots. The entire protected saved state for a player is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error. Only accessible via an authenticated server authority.
     * @summary Set Protected Player Item
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {SetItemBody} [setItemBody] Add a data item to store for a player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setProtectedItem(
      projectId: string,
      playerId: string,
      setItemBody?: SetItemBody,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SetItemResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.setProtectedItem(
          projectId,
          playerId,
          setItemBody,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Set up to 20 protected data items with key, value and optional writeLock for the given player. The values are limited to a maximum size of 5 MB across all slots for the player. The entire protected saved state for a player is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error. The batch set operation is considered atomic and if any of the set key operation fails, the entire operation is failed. Error responses should identify the affected key operations that failed. Only accessible via an authenticated server authority.
     * @summary Set Protected Player Item Batch
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {SetItemBatchBody} [setItemBatchBody] Set batch data items for a player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setProtectedItemBatch(
      projectId: string,
      playerId: string,
      setItemBatchBody?: SetItemBatchBody,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SetItemBatchResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.setProtectedItemBatch(
          projectId,
          playerId,
          setItemBatchBody,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Set a public data item with a given key and value for the specified player. The value is limited to a maximum size of 5 MB across all public access level slots. The entire public saved state for a player is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error. The value set will be publicly readable by any player.
     * @summary Set Public Player Item
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {SetItemBody} [setItemBody] Add a data item to store for a player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setPublicItem(
      projectId: string,
      playerId: string,
      setItemBody?: SetItemBody,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SetItemResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.setPublicItem(
        projectId,
        playerId,
        setItemBody,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Set up to 20 public data items with key, value and optional writeLock for the given player. The values are limited to a maximum size of 5 MB across all slots for the player. The entire public saved state for a player is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error. The batch set operation is considered atomic and if any of the set key operation fails, the entire operation is failed. Error responses should identify the affected key operations that failed.
     * @summary Set Public Player Item Batch
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {SetItemBatchBody} [setItemBatchBody] Set batch data items for a player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setPublicItemBatch(
      projectId: string,
      playerId: string,
      setItemBatchBody?: SetItemBatchBody,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SetItemBatchResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.setPublicItemBatch(
          projectId,
          playerId,
          setItemBatchBody,
          options,
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * DataApi - factory interface
 * @export
 */
export const DataApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = DataApiFp(configuration);
  return {
    /**
     * Deletes a data item by the specified key for the specified custom ID. Only accessible via an authenticated server authority.
     * @summary Delete Custom Item
     * @param {string} key Item key.
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {string} [writeLock] Enforces conflict checking when deleting an existing data item. Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCustomItem(
      key: string,
      projectId: string,
      customId: string,
      writeLock?: string,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .deleteCustomItem(key, projectId, customId, writeLock, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deletes all default access level data associated with a given custom ID. Only accessible via an authenticated server authority.
     * @summary Delete Custom Items
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteCustomItems(
      projectId: string,
      customId: string,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .deleteCustomItems(projectId, customId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deletes a data item by the specified key for the given player.
     * @summary Delete Player Item
     * @param {string} key Item key.
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} [writeLock] Enforces conflict checking when deleting an existing data item. Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteItem(
      key: string,
      projectId: string,
      playerId: string,
      writeLock?: string,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .deleteItem(key, projectId, playerId, writeLock, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deletes all default access level data associated with a given player.
     * @summary Delete Player Items
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteItems(
      projectId: string,
      playerId: string,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .deleteItems(projectId, playerId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deletes a private data item by the specified key for the specified custom ID. Only accessible via an authenticated server authority.
     * @summary Delete Private Custom Item
     * @param {string} key Item key.
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {string} [writeLock] Enforces conflict checking when deleting an existing data item. Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePrivateCustomItem(
      key: string,
      projectId: string,
      customId: string,
      writeLock?: string,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .deletePrivateCustomItem(key, projectId, customId, writeLock, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deletes all private data associated with a given custom ID. Only accessible via an authenticated server authority.
     * @summary Delete Private Custom Items
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePrivateCustomItems(
      projectId: string,
      customId: string,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .deletePrivateCustomItems(projectId, customId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deletes a protected data item by the specified key for the given player. Only accessible via an authenticated server authority.
     * @summary Delete Protected Player Item
     * @param {string} key Item key.
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} [writeLock] Enforces conflict checking when deleting an existing data item. Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProtectedItem(
      key: string,
      projectId: string,
      playerId: string,
      writeLock?: string,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .deleteProtectedItem(key, projectId, playerId, writeLock, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deletes all protected data associated with a given player. Only accessible via an authenticated server authority.
     * @summary Delete Protected Player Items
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteProtectedItems(
      projectId: string,
      playerId: string,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .deleteProtectedItems(projectId, playerId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deletes a public data item by the specified key for the given player.
     * @summary Delete Public Player Item
     * @param {string} key Item key.
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} [writeLock] Enforces conflict checking when deleting an existing data item. Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePublicItem(
      key: string,
      projectId: string,
      playerId: string,
      writeLock?: string,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .deletePublicItem(key, projectId, playerId, writeLock, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deletes all public data associated with a given player.
     * @summary Delete Public Player Items
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePublicItems(
      projectId: string,
      playerId: string,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .deletePublicItems(projectId, playerId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves saved data values for all keys specified, ordered alphabetically in pages of 20. If no keys are supplied then returns all keys, ordered alphabetically in pages of 20.
     * @summary Get Custom Items
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {Array<string>} [keys] The keys to retrieve, in exploded form style, e.g. &#x60;keys&#x3D;KEY1&amp;keys&#x3D;KEY2&amp;keys&#x3D;KEY3&#x60;.
     * @param {string} [after] The key after which to retrieve the next page of keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCustomItems(
      projectId: string,
      customId: string,
      keys?: Array<string>,
      after?: string,
      options?: any,
    ): AxiosPromise<GetItemsResponse> {
      return localVarFp
        .getCustomItems(projectId, customId, keys, after, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Gets a paged list of keys for the given custom ID, ordered alphabetically in pages of 100.
     * @summary Get Custom Keys
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {string} [after] Returns the page of results after the key specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCustomKeys(
      projectId: string,
      customId: string,
      after?: string,
      options?: any,
    ): AxiosPromise<GetKeysResponse> {
      return localVarFp
        .getCustomKeys(projectId, customId, after, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves saved data values for all keys specified, ordered alphabetically in pages of 20. If no keys are supplied then returns all keys, ordered alphabetically in pages of 20.
     * @summary Get Player Items
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {Array<string>} [keys] The keys to retrieve, in exploded form style, e.g. &#x60;keys&#x3D;KEY1&amp;keys&#x3D;KEY2&amp;keys&#x3D;KEY3&#x60;.
     * @param {string} [after] The key after which to retrieve the next page of keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getItems(
      projectId: string,
      playerId: string,
      keys?: Array<string>,
      after?: string,
      options?: any,
    ): AxiosPromise<GetItemsResponse> {
      return localVarFp
        .getItems(projectId, playerId, keys, after, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Gets a paged list of keys for the given player, ordered alphabetically in pages of 100.
     * @summary Get Player Keys
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} [after] Returns the page of results after the key specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getKeys(
      projectId: string,
      playerId: string,
      after?: string,
      options?: any,
    ): AxiosPromise<GetKeysResponse> {
      return localVarFp
        .getKeys(projectId, playerId, after, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves private save data values for all keys specified, ordered alphabetically in pages of 20. If no keys are supplied then returns all keys, ordered alphabetically in pages of 20. Only accessible via an authenticated server authority.
     * @summary Get Private Custom Items
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {Array<string>} [keys] The keys to retrieve, in exploded form style, e.g. &#x60;keys&#x3D;KEY1&amp;keys&#x3D;KEY2&amp;keys&#x3D;KEY3&#x60;.
     * @param {string} [after] The key after which to retrieve the next page of keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPrivateCustomItems(
      projectId: string,
      customId: string,
      keys?: Array<string>,
      after?: string,
      options?: any,
    ): AxiosPromise<GetItemsResponse> {
      return localVarFp
        .getPrivateCustomItems(projectId, customId, keys, after, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Gets a paged list of private keys for the given custom ID, ordered alphabetically in pages of 100. Only accessible via an authenticated server authority.
     * @summary Get Private Custom Keys
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {string} [after] Returns the page of results after the key specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPrivateCustomKeys(
      projectId: string,
      customId: string,
      after?: string,
      options?: any,
    ): AxiosPromise<GetKeysResponse> {
      return localVarFp
        .getPrivateCustomKeys(projectId, customId, after, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves protected save data values for all keys specified, ordered alphabetically in pages of 20. If no keys are supplied then returns all keys, ordered alphabetically in pages of 20.
     * @summary Get Protected Player Items
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {Array<string>} [keys] The keys to retrieve, in exploded form style, e.g. &#x60;keys&#x3D;KEY1&amp;keys&#x3D;KEY2&amp;keys&#x3D;KEY3&#x60;.
     * @param {string} [after] The key after which to retrieve the next page of keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProtectedItems(
      projectId: string,
      playerId: string,
      keys?: Array<string>,
      after?: string,
      options?: any,
    ): AxiosPromise<GetItemsResponse> {
      return localVarFp
        .getProtectedItems(projectId, playerId, keys, after, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Gets a paged list of protected keys for the given player, ordered alphabetically in pages of 100.
     * @summary Get Protected Player Keys
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} [after] Returns the page of results after the key specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProtectedKeys(
      projectId: string,
      playerId: string,
      after?: string,
      options?: any,
    ): AxiosPromise<GetKeysResponse> {
      return localVarFp
        .getProtectedKeys(projectId, playerId, after, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves saved data values for all keys specified, ordered alphabetically in pages of 20. If no keys are supplied then returns all keys, ordered alphabetically in pages of 20. Accessible by any player for any other player\'s data.
     * @summary Get Public Player Items
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {Array<string>} [keys] The keys to retrieve, in exploded form style, e.g. &#x60;keys&#x3D;KEY1&amp;keys&#x3D;KEY2&amp;keys&#x3D;KEY3&#x60;.
     * @param {string} [after] The key after which to retrieve the next page of keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPublicItems(
      projectId: string,
      playerId: string,
      keys?: Array<string>,
      after?: string,
      options?: any,
    ): AxiosPromise<GetItemsResponse> {
      return localVarFp
        .getPublicItems(projectId, playerId, keys, after, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Gets a paged list of public keys for the given player, ordered alphabetically in pages of 100. Accessible by any player for any other player\'s data.
     * @summary Get Public Player Keys
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} [after] Returns the page of results after the key specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPublicKeys(
      projectId: string,
      playerId: string,
      after?: string,
      options?: any,
    ): AxiosPromise<GetKeysResponse> {
      return localVarFp
        .getPublicKeys(projectId, playerId, after, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Query custom data with the default access class. If no index is available to fulfil the query then the query will fail
     * @summary Query Default Custom Data
     * @param {string} projectId ID of the project.
     * @param {QueryIndexBody} [queryIndexBody] Query object with an array of conditions to query the data with.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryDefaultCustomData(
      projectId: string,
      queryIndexBody?: QueryIndexBody,
      options?: any,
    ): AxiosPromise<QueryIndexResponse> {
      return localVarFp
        .queryDefaultCustomData(projectId, queryIndexBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Query player data with the default access class. If no index is available to fulfil the query then the query will fail.
     * @summary Query Default Player Data
     * @param {string} projectId ID of the project.
     * @param {QueryIndexBody} [queryIndexBody] Query object with an array of conditions to query the data with.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryDefaultPlayerData(
      projectId: string,
      queryIndexBody?: QueryIndexBody,
      options?: any,
    ): AxiosPromise<QueryIndexResponse> {
      return localVarFp
        .queryDefaultPlayerData(projectId, queryIndexBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Query custom data with the private access class. If no index is available to fulfil the query then the query will fail.
     * @summary Query Private Custom Data
     * @param {string} projectId ID of the project.
     * @param {QueryIndexBody} [queryIndexBody] Query object with an array of conditions to query the data with.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryPrivateCustomData(
      projectId: string,
      queryIndexBody?: QueryIndexBody,
      options?: any,
    ): AxiosPromise<QueryIndexResponse> {
      return localVarFp
        .queryPrivateCustomData(projectId, queryIndexBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Query player data with the protected access class. If no index is available to fulfil the query then the query will fail.
     * @summary Query Protected Player Data
     * @param {string} projectId ID of the project.
     * @param {QueryIndexBody} [queryIndexBody] Query object with an array of conditions to query the data with.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryProtectedPlayerData(
      projectId: string,
      queryIndexBody?: QueryIndexBody,
      options?: any,
    ): AxiosPromise<QueryIndexResponse> {
      return localVarFp
        .queryProtectedPlayerData(projectId, queryIndexBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Query player data with the public access class. If no index is available to fulfil the query then the query will fail.
     * @summary Query Public Player Data
     * @param {string} projectId ID of the project.
     * @param {QueryIndexBody} [queryIndexBody] Query object with an array of conditions to query the data with.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryPublicPlayerData(
      projectId: string,
      queryIndexBody?: QueryIndexBody,
      options?: any,
    ): AxiosPromise<QueryIndexResponse> {
      return localVarFp
        .queryPublicPlayerData(projectId, queryIndexBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Set a data item with a given key and value for the specified custom ID. The value is limited to a maximum size of 5 MB across all default access level slots. The entire default access level saved state for a custom ID is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error. Only accessible via an authenticated server authority.
     * @summary Set Custom Item
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {SetItemBody} [setItemBody] Add a data item to store for a custom ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setCustomItem(
      projectId: string,
      customId: string,
      setItemBody?: SetItemBody,
      options?: any,
    ): AxiosPromise<SetItemResponse> {
      return localVarFp
        .setCustomItem(projectId, customId, setItemBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Set up to 20 data items with key, value and optional writeLock against the custom ID. The values are limited to a maximum size of 5 MB across all default access level slots for the custom ID. The entire default access level saved state for a custom ID is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error. The batch set operation is considered atomic and if any of the set key operation fails, the entire operation is failed. Error responses should identify the affected key operations that failed. Only accessible via an authenticated server authority.
     * @summary Set Custom Item Batch
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {SetItemBatchBody} [setItemBatchBody] Set batch data items for a custom ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setCustomItemBatch(
      projectId: string,
      customId: string,
      setItemBatchBody?: SetItemBatchBody,
      options?: any,
    ): AxiosPromise<SetItemBatchResponse> {
      return localVarFp
        .setCustomItemBatch(projectId, customId, setItemBatchBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Set a data item with a given key and value for the specified player. The value is limited to a maximum size of 5 MB across all default access level slots. The entire default access level saved state for a player is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error.
     * @summary Set Player Item
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {SetItemBody} [setItemBody] Add a data item to store for a player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setItem(
      projectId: string,
      playerId: string,
      setItemBody?: SetItemBody,
      options?: any,
    ): AxiosPromise<SetItemResponse> {
      return localVarFp
        .setItem(projectId, playerId, setItemBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Set up to 20 data items with key, value and optional writeLock for the given player. The values are limited to a maximum size of 5 MB across all default access level slots for the player. The entire default access level saved state for a player is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error. The batch set operation is considered atomic and if any of the set key operation fails, the entire operation is failed. Error responses should identify the affected key operations that failed.
     * @summary Set Player Item Batch
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {SetItemBatchBody} [setItemBatchBody] Set batch data items for a player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setItemBatch(
      projectId: string,
      playerId: string,
      setItemBatchBody?: SetItemBatchBody,
      options?: any,
    ): AxiosPromise<SetItemBatchResponse> {
      return localVarFp
        .setItemBatch(projectId, playerId, setItemBatchBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Set a private data item with a given key and value for the specified custom ID. The value is limited to a maximum size of 5 MB across all private access level slots. The entire private saved state for a custom ID is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error. Only accessible via an authenticated server authority.
     * @summary Set Private Custom Item
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {SetItemBody} [setItemBody] Add a data item to store for a custom ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setPrivateCustomItem(
      projectId: string,
      customId: string,
      setItemBody?: SetItemBody,
      options?: any,
    ): AxiosPromise<SetItemResponse> {
      return localVarFp
        .setPrivateCustomItem(projectId, customId, setItemBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Set up to 20 private data items with key, value and optional writeLock against the custom ID. The values are limited to a maximum size of 5 MB across all private access level slots for the custom ID. The entire private saved state for a custom ID is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error. The batch set operation is considered atomic and if any of the set key operation fails, the entire operation is failed. Error responses should identify the affected key operations that failed. Only accessible via an authenticated server authority.
     * @summary Set Private Custom Item Batch
     * @param {string} projectId ID of the project.
     * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
     * @param {SetItemBatchBody} [setItemBatchBody] Set batch data items for a custom ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setPrivateCustomItemBatch(
      projectId: string,
      customId: string,
      setItemBatchBody?: SetItemBatchBody,
      options?: any,
    ): AxiosPromise<SetItemBatchResponse> {
      return localVarFp
        .setPrivateCustomItemBatch(
          projectId,
          customId,
          setItemBatchBody,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Set a protected data item with a given key and value for the specified player. The value is limited to a maximum size of 5 MB across all protected access level slots. The entire protected saved state for a player is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error. Only accessible via an authenticated server authority.
     * @summary Set Protected Player Item
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {SetItemBody} [setItemBody] Add a data item to store for a player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setProtectedItem(
      projectId: string,
      playerId: string,
      setItemBody?: SetItemBody,
      options?: any,
    ): AxiosPromise<SetItemResponse> {
      return localVarFp
        .setProtectedItem(projectId, playerId, setItemBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Set up to 20 protected data items with key, value and optional writeLock for the given player. The values are limited to a maximum size of 5 MB across all slots for the player. The entire protected saved state for a player is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error. The batch set operation is considered atomic and if any of the set key operation fails, the entire operation is failed. Error responses should identify the affected key operations that failed. Only accessible via an authenticated server authority.
     * @summary Set Protected Player Item Batch
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {SetItemBatchBody} [setItemBatchBody] Set batch data items for a player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setProtectedItemBatch(
      projectId: string,
      playerId: string,
      setItemBatchBody?: SetItemBatchBody,
      options?: any,
    ): AxiosPromise<SetItemBatchResponse> {
      return localVarFp
        .setProtectedItemBatch(projectId, playerId, setItemBatchBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Set a public data item with a given key and value for the specified player. The value is limited to a maximum size of 5 MB across all public access level slots. The entire public saved state for a player is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error. The value set will be publicly readable by any player.
     * @summary Set Public Player Item
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {SetItemBody} [setItemBody] Add a data item to store for a player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setPublicItem(
      projectId: string,
      playerId: string,
      setItemBody?: SetItemBody,
      options?: any,
    ): AxiosPromise<SetItemResponse> {
      return localVarFp
        .setPublicItem(projectId, playerId, setItemBody, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Set up to 20 public data items with key, value and optional writeLock for the given player. The values are limited to a maximum size of 5 MB across all slots for the player. The entire public saved state for a player is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error. The batch set operation is considered atomic and if any of the set key operation fails, the entire operation is failed. Error responses should identify the affected key operations that failed.
     * @summary Set Public Player Item Batch
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {SetItemBatchBody} [setItemBatchBody] Set batch data items for a player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setPublicItemBatch(
      projectId: string,
      playerId: string,
      setItemBatchBody?: SetItemBatchBody,
      options?: any,
    ): AxiosPromise<SetItemBatchResponse> {
      return localVarFp
        .setPublicItemBatch(projectId, playerId, setItemBatchBody, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * DataApi - object-oriented interface
 * @export
 * @class DataApi
 * @extends {BaseAPI}
 */
export class DataApi extends BaseAPI {
  /**
   * Deletes a data item by the specified key for the specified custom ID. Only accessible via an authenticated server authority.
   * @summary Delete Custom Item
   * @param {string} key Item key.
   * @param {string} projectId ID of the project.
   * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
   * @param {string} [writeLock] Enforces conflict checking when deleting an existing data item. Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public deleteCustomItem(
    key: string,
    projectId: string,
    customId: string,
    writeLock?: string,
    options?: AxiosRequestConfig,
  ) {
    return DataApiFp(this.configuration)
      .deleteCustomItem(key, projectId, customId, writeLock, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes all default access level data associated with a given custom ID. Only accessible via an authenticated server authority.
   * @summary Delete Custom Items
   * @param {string} projectId ID of the project.
   * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public deleteCustomItems(
    projectId: string,
    customId: string,
    options?: AxiosRequestConfig,
  ) {
    return DataApiFp(this.configuration)
      .deleteCustomItems(projectId, customId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes a data item by the specified key for the given player.
   * @summary Delete Player Item
   * @param {string} key Item key.
   * @param {string} projectId ID of the project.
   * @param {string} playerId The player ID supplied by the Authorization service.
   * @param {string} [writeLock] Enforces conflict checking when deleting an existing data item. Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public deleteItem(
    key: string,
    projectId: string,
    playerId: string,
    writeLock?: string,
    options?: AxiosRequestConfig,
  ) {
    return DataApiFp(this.configuration)
      .deleteItem(key, projectId, playerId, writeLock, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes all default access level data associated with a given player.
   * @summary Delete Player Items
   * @param {string} projectId ID of the project.
   * @param {string} playerId The player ID supplied by the Authorization service.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public deleteItems(
    projectId: string,
    playerId: string,
    options?: AxiosRequestConfig,
  ) {
    return DataApiFp(this.configuration)
      .deleteItems(projectId, playerId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes a private data item by the specified key for the specified custom ID. Only accessible via an authenticated server authority.
   * @summary Delete Private Custom Item
   * @param {string} key Item key.
   * @param {string} projectId ID of the project.
   * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
   * @param {string} [writeLock] Enforces conflict checking when deleting an existing data item. Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public deletePrivateCustomItem(
    key: string,
    projectId: string,
    customId: string,
    writeLock?: string,
    options?: AxiosRequestConfig,
  ) {
    return DataApiFp(this.configuration)
      .deletePrivateCustomItem(key, projectId, customId, writeLock, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes all private data associated with a given custom ID. Only accessible via an authenticated server authority.
   * @summary Delete Private Custom Items
   * @param {string} projectId ID of the project.
   * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public deletePrivateCustomItems(
    projectId: string,
    customId: string,
    options?: AxiosRequestConfig,
  ) {
    return DataApiFp(this.configuration)
      .deletePrivateCustomItems(projectId, customId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes a protected data item by the specified key for the given player. Only accessible via an authenticated server authority.
   * @summary Delete Protected Player Item
   * @param {string} key Item key.
   * @param {string} projectId ID of the project.
   * @param {string} playerId The player ID supplied by the Authorization service.
   * @param {string} [writeLock] Enforces conflict checking when deleting an existing data item. Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public deleteProtectedItem(
    key: string,
    projectId: string,
    playerId: string,
    writeLock?: string,
    options?: AxiosRequestConfig,
  ) {
    return DataApiFp(this.configuration)
      .deleteProtectedItem(key, projectId, playerId, writeLock, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes all protected data associated with a given player. Only accessible via an authenticated server authority.
   * @summary Delete Protected Player Items
   * @param {string} projectId ID of the project.
   * @param {string} playerId The player ID supplied by the Authorization service.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public deleteProtectedItems(
    projectId: string,
    playerId: string,
    options?: AxiosRequestConfig,
  ) {
    return DataApiFp(this.configuration)
      .deleteProtectedItems(projectId, playerId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes a public data item by the specified key for the given player.
   * @summary Delete Public Player Item
   * @param {string} key Item key.
   * @param {string} projectId ID of the project.
   * @param {string} playerId The player ID supplied by the Authorization service.
   * @param {string} [writeLock] Enforces conflict checking when deleting an existing data item. Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public deletePublicItem(
    key: string,
    projectId: string,
    playerId: string,
    writeLock?: string,
    options?: AxiosRequestConfig,
  ) {
    return DataApiFp(this.configuration)
      .deletePublicItem(key, projectId, playerId, writeLock, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes all public data associated with a given player.
   * @summary Delete Public Player Items
   * @param {string} projectId ID of the project.
   * @param {string} playerId The player ID supplied by the Authorization service.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public deletePublicItems(
    projectId: string,
    playerId: string,
    options?: AxiosRequestConfig,
  ) {
    return DataApiFp(this.configuration)
      .deletePublicItems(projectId, playerId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves saved data values for all keys specified, ordered alphabetically in pages of 20. If no keys are supplied then returns all keys, ordered alphabetically in pages of 20.
   * @summary Get Custom Items
   * @param {string} projectId ID of the project.
   * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
   * @param {Array<string>} [keys] The keys to retrieve, in exploded form style, e.g. &#x60;keys&#x3D;KEY1&amp;keys&#x3D;KEY2&amp;keys&#x3D;KEY3&#x60;.
   * @param {string} [after] The key after which to retrieve the next page of keys.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public getCustomItems(
    projectId: string,
    customId: string,
    keys?: Array<string>,
    after?: string,
    options?: AxiosRequestConfig,
  ) {
    return DataApiFp(this.configuration)
      .getCustomItems(projectId, customId, keys, after, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Gets a paged list of keys for the given custom ID, ordered alphabetically in pages of 100.
   * @summary Get Custom Keys
   * @param {string} projectId ID of the project.
   * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
   * @param {string} [after] Returns the page of results after the key specified.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public getCustomKeys(
    projectId: string,
    customId: string,
    after?: string,
    options?: AxiosRequestConfig,
  ) {
    return DataApiFp(this.configuration)
      .getCustomKeys(projectId, customId, after, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves saved data values for all keys specified, ordered alphabetically in pages of 20. If no keys are supplied then returns all keys, ordered alphabetically in pages of 20.
   * @summary Get Player Items
   * @param {string} projectId ID of the project.
   * @param {string} playerId The player ID supplied by the Authorization service.
   * @param {Array<string>} [keys] The keys to retrieve, in exploded form style, e.g. &#x60;keys&#x3D;KEY1&amp;keys&#x3D;KEY2&amp;keys&#x3D;KEY3&#x60;.
   * @param {string} [after] The key after which to retrieve the next page of keys.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public getItems(
    projectId: string,
    playerId: string,
    keys?: Array<string>,
    after?: string,
    options?: AxiosRequestConfig,
  ) {
    return DataApiFp(this.configuration)
      .getItems(projectId, playerId, keys, after, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Gets a paged list of keys for the given player, ordered alphabetically in pages of 100.
   * @summary Get Player Keys
   * @param {string} projectId ID of the project.
   * @param {string} playerId The player ID supplied by the Authorization service.
   * @param {string} [after] Returns the page of results after the key specified.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public getKeys(
    projectId: string,
    playerId: string,
    after?: string,
    options?: AxiosRequestConfig,
  ) {
    return DataApiFp(this.configuration)
      .getKeys(projectId, playerId, after, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves private save data values for all keys specified, ordered alphabetically in pages of 20. If no keys are supplied then returns all keys, ordered alphabetically in pages of 20. Only accessible via an authenticated server authority.
   * @summary Get Private Custom Items
   * @param {string} projectId ID of the project.
   * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
   * @param {Array<string>} [keys] The keys to retrieve, in exploded form style, e.g. &#x60;keys&#x3D;KEY1&amp;keys&#x3D;KEY2&amp;keys&#x3D;KEY3&#x60;.
   * @param {string} [after] The key after which to retrieve the next page of keys.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public getPrivateCustomItems(
    projectId: string,
    customId: string,
    keys?: Array<string>,
    after?: string,
    options?: AxiosRequestConfig,
  ) {
    return DataApiFp(this.configuration)
      .getPrivateCustomItems(projectId, customId, keys, after, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Gets a paged list of private keys for the given custom ID, ordered alphabetically in pages of 100. Only accessible via an authenticated server authority.
   * @summary Get Private Custom Keys
   * @param {string} projectId ID of the project.
   * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
   * @param {string} [after] Returns the page of results after the key specified.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public getPrivateCustomKeys(
    projectId: string,
    customId: string,
    after?: string,
    options?: AxiosRequestConfig,
  ) {
    return DataApiFp(this.configuration)
      .getPrivateCustomKeys(projectId, customId, after, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves protected save data values for all keys specified, ordered alphabetically in pages of 20. If no keys are supplied then returns all keys, ordered alphabetically in pages of 20.
   * @summary Get Protected Player Items
   * @param {string} projectId ID of the project.
   * @param {string} playerId The player ID supplied by the Authorization service.
   * @param {Array<string>} [keys] The keys to retrieve, in exploded form style, e.g. &#x60;keys&#x3D;KEY1&amp;keys&#x3D;KEY2&amp;keys&#x3D;KEY3&#x60;.
   * @param {string} [after] The key after which to retrieve the next page of keys.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public getProtectedItems(
    projectId: string,
    playerId: string,
    keys?: Array<string>,
    after?: string,
    options?: AxiosRequestConfig,
  ) {
    return DataApiFp(this.configuration)
      .getProtectedItems(projectId, playerId, keys, after, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Gets a paged list of protected keys for the given player, ordered alphabetically in pages of 100.
   * @summary Get Protected Player Keys
   * @param {string} projectId ID of the project.
   * @param {string} playerId The player ID supplied by the Authorization service.
   * @param {string} [after] Returns the page of results after the key specified.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public getProtectedKeys(
    projectId: string,
    playerId: string,
    after?: string,
    options?: AxiosRequestConfig,
  ) {
    return DataApiFp(this.configuration)
      .getProtectedKeys(projectId, playerId, after, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves saved data values for all keys specified, ordered alphabetically in pages of 20. If no keys are supplied then returns all keys, ordered alphabetically in pages of 20. Accessible by any player for any other player\'s data.
   * @summary Get Public Player Items
   * @param {string} projectId ID of the project.
   * @param {string} playerId The player ID supplied by the Authorization service.
   * @param {Array<string>} [keys] The keys to retrieve, in exploded form style, e.g. &#x60;keys&#x3D;KEY1&amp;keys&#x3D;KEY2&amp;keys&#x3D;KEY3&#x60;.
   * @param {string} [after] The key after which to retrieve the next page of keys.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public getPublicItems(
    projectId: string,
    playerId: string,
    keys?: Array<string>,
    after?: string,
    options?: AxiosRequestConfig,
  ) {
    return DataApiFp(this.configuration)
      .getPublicItems(projectId, playerId, keys, after, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Gets a paged list of public keys for the given player, ordered alphabetically in pages of 100. Accessible by any player for any other player\'s data.
   * @summary Get Public Player Keys
   * @param {string} projectId ID of the project.
   * @param {string} playerId The player ID supplied by the Authorization service.
   * @param {string} [after] Returns the page of results after the key specified.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public getPublicKeys(
    projectId: string,
    playerId: string,
    after?: string,
    options?: AxiosRequestConfig,
  ) {
    return DataApiFp(this.configuration)
      .getPublicKeys(projectId, playerId, after, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Query custom data with the default access class. If no index is available to fulfil the query then the query will fail
   * @summary Query Default Custom Data
   * @param {string} projectId ID of the project.
   * @param {QueryIndexBody} [queryIndexBody] Query object with an array of conditions to query the data with.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public queryDefaultCustomData(
    projectId: string,
    queryIndexBody?: QueryIndexBody,
    options?: AxiosRequestConfig,
  ) {
    return DataApiFp(this.configuration)
      .queryDefaultCustomData(projectId, queryIndexBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Query player data with the default access class. If no index is available to fulfil the query then the query will fail.
   * @summary Query Default Player Data
   * @param {string} projectId ID of the project.
   * @param {QueryIndexBody} [queryIndexBody] Query object with an array of conditions to query the data with.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public queryDefaultPlayerData(
    projectId: string,
    queryIndexBody?: QueryIndexBody,
    options?: AxiosRequestConfig,
  ) {
    return DataApiFp(this.configuration)
      .queryDefaultPlayerData(projectId, queryIndexBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Query custom data with the private access class. If no index is available to fulfil the query then the query will fail.
   * @summary Query Private Custom Data
   * @param {string} projectId ID of the project.
   * @param {QueryIndexBody} [queryIndexBody] Query object with an array of conditions to query the data with.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public queryPrivateCustomData(
    projectId: string,
    queryIndexBody?: QueryIndexBody,
    options?: AxiosRequestConfig,
  ) {
    return DataApiFp(this.configuration)
      .queryPrivateCustomData(projectId, queryIndexBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Query player data with the protected access class. If no index is available to fulfil the query then the query will fail.
   * @summary Query Protected Player Data
   * @param {string} projectId ID of the project.
   * @param {QueryIndexBody} [queryIndexBody] Query object with an array of conditions to query the data with.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public queryProtectedPlayerData(
    projectId: string,
    queryIndexBody?: QueryIndexBody,
    options?: AxiosRequestConfig,
  ) {
    return DataApiFp(this.configuration)
      .queryProtectedPlayerData(projectId, queryIndexBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Query player data with the public access class. If no index is available to fulfil the query then the query will fail.
   * @summary Query Public Player Data
   * @param {string} projectId ID of the project.
   * @param {QueryIndexBody} [queryIndexBody] Query object with an array of conditions to query the data with.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public queryPublicPlayerData(
    projectId: string,
    queryIndexBody?: QueryIndexBody,
    options?: AxiosRequestConfig,
  ) {
    return DataApiFp(this.configuration)
      .queryPublicPlayerData(projectId, queryIndexBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Set a data item with a given key and value for the specified custom ID. The value is limited to a maximum size of 5 MB across all default access level slots. The entire default access level saved state for a custom ID is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error. Only accessible via an authenticated server authority.
   * @summary Set Custom Item
   * @param {string} projectId ID of the project.
   * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
   * @param {SetItemBody} [setItemBody] Add a data item to store for a custom ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public setCustomItem(
    projectId: string,
    customId: string,
    setItemBody?: SetItemBody,
    options?: AxiosRequestConfig,
  ) {
    return DataApiFp(this.configuration)
      .setCustomItem(projectId, customId, setItemBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Set up to 20 data items with key, value and optional writeLock against the custom ID. The values are limited to a maximum size of 5 MB across all default access level slots for the custom ID. The entire default access level saved state for a custom ID is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error. The batch set operation is considered atomic and if any of the set key operation fails, the entire operation is failed. Error responses should identify the affected key operations that failed. Only accessible via an authenticated server authority.
   * @summary Set Custom Item Batch
   * @param {string} projectId ID of the project.
   * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
   * @param {SetItemBatchBody} [setItemBatchBody] Set batch data items for a custom ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public setCustomItemBatch(
    projectId: string,
    customId: string,
    setItemBatchBody?: SetItemBatchBody,
    options?: AxiosRequestConfig,
  ) {
    return DataApiFp(this.configuration)
      .setCustomItemBatch(projectId, customId, setItemBatchBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Set a data item with a given key and value for the specified player. The value is limited to a maximum size of 5 MB across all default access level slots. The entire default access level saved state for a player is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error.
   * @summary Set Player Item
   * @param {string} projectId ID of the project.
   * @param {string} playerId The player ID supplied by the Authorization service.
   * @param {SetItemBody} [setItemBody] Add a data item to store for a player.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public setItem(
    projectId: string,
    playerId: string,
    setItemBody?: SetItemBody,
    options?: AxiosRequestConfig,
  ) {
    return DataApiFp(this.configuration)
      .setItem(projectId, playerId, setItemBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Set up to 20 data items with key, value and optional writeLock for the given player. The values are limited to a maximum size of 5 MB across all default access level slots for the player. The entire default access level saved state for a player is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error. The batch set operation is considered atomic and if any of the set key operation fails, the entire operation is failed. Error responses should identify the affected key operations that failed.
   * @summary Set Player Item Batch
   * @param {string} projectId ID of the project.
   * @param {string} playerId The player ID supplied by the Authorization service.
   * @param {SetItemBatchBody} [setItemBatchBody] Set batch data items for a player.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public setItemBatch(
    projectId: string,
    playerId: string,
    setItemBatchBody?: SetItemBatchBody,
    options?: AxiosRequestConfig,
  ) {
    return DataApiFp(this.configuration)
      .setItemBatch(projectId, playerId, setItemBatchBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Set a private data item with a given key and value for the specified custom ID. The value is limited to a maximum size of 5 MB across all private access level slots. The entire private saved state for a custom ID is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error. Only accessible via an authenticated server authority.
   * @summary Set Private Custom Item
   * @param {string} projectId ID of the project.
   * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
   * @param {SetItemBody} [setItemBody] Add a data item to store for a custom ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public setPrivateCustomItem(
    projectId: string,
    customId: string,
    setItemBody?: SetItemBody,
    options?: AxiosRequestConfig,
  ) {
    return DataApiFp(this.configuration)
      .setPrivateCustomItem(projectId, customId, setItemBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Set up to 20 private data items with key, value and optional writeLock against the custom ID. The values are limited to a maximum size of 5 MB across all private access level slots for the custom ID. The entire private saved state for a custom ID is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error. The batch set operation is considered atomic and if any of the set key operation fails, the entire operation is failed. Error responses should identify the affected key operations that failed. Only accessible via an authenticated server authority.
   * @summary Set Private Custom Item Batch
   * @param {string} projectId ID of the project.
   * @param {string} customId The custom data ID specified by the user. Must be between 1 and 50 characters long and contain only alphanumeric characters, underscores, and hyphens.
   * @param {SetItemBatchBody} [setItemBatchBody] Set batch data items for a custom ID.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public setPrivateCustomItemBatch(
    projectId: string,
    customId: string,
    setItemBatchBody?: SetItemBatchBody,
    options?: AxiosRequestConfig,
  ) {
    return DataApiFp(this.configuration)
      .setPrivateCustomItemBatch(projectId, customId, setItemBatchBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Set a protected data item with a given key and value for the specified player. The value is limited to a maximum size of 5 MB across all protected access level slots. The entire protected saved state for a player is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error. Only accessible via an authenticated server authority.
   * @summary Set Protected Player Item
   * @param {string} projectId ID of the project.
   * @param {string} playerId The player ID supplied by the Authorization service.
   * @param {SetItemBody} [setItemBody] Add a data item to store for a player.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public setProtectedItem(
    projectId: string,
    playerId: string,
    setItemBody?: SetItemBody,
    options?: AxiosRequestConfig,
  ) {
    return DataApiFp(this.configuration)
      .setProtectedItem(projectId, playerId, setItemBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Set up to 20 protected data items with key, value and optional writeLock for the given player. The values are limited to a maximum size of 5 MB across all slots for the player. The entire protected saved state for a player is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error. The batch set operation is considered atomic and if any of the set key operation fails, the entire operation is failed. Error responses should identify the affected key operations that failed. Only accessible via an authenticated server authority.
   * @summary Set Protected Player Item Batch
   * @param {string} projectId ID of the project.
   * @param {string} playerId The player ID supplied by the Authorization service.
   * @param {SetItemBatchBody} [setItemBatchBody] Set batch data items for a player.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public setProtectedItemBatch(
    projectId: string,
    playerId: string,
    setItemBatchBody?: SetItemBatchBody,
    options?: AxiosRequestConfig,
  ) {
    return DataApiFp(this.configuration)
      .setProtectedItemBatch(projectId, playerId, setItemBatchBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Set a public data item with a given key and value for the specified player. The value is limited to a maximum size of 5 MB across all public access level slots. The entire public saved state for a player is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error. The value set will be publicly readable by any player.
   * @summary Set Public Player Item
   * @param {string} projectId ID of the project.
   * @param {string} playerId The player ID supplied by the Authorization service.
   * @param {SetItemBody} [setItemBody] Add a data item to store for a player.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public setPublicItem(
    projectId: string,
    playerId: string,
    setItemBody?: SetItemBody,
    options?: AxiosRequestConfig,
  ) {
    return DataApiFp(this.configuration)
      .setPublicItem(projectId, playerId, setItemBody, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Set up to 20 public data items with key, value and optional writeLock for the given player. The values are limited to a maximum size of 5 MB across all slots for the player. The entire public saved state for a player is limited to 2000 keys. Attempting to set a new key beyond this limit will result in an error. The batch set operation is considered atomic and if any of the set key operation fails, the entire operation is failed. Error responses should identify the affected key operations that failed.
   * @summary Set Public Player Item Batch
   * @param {string} projectId ID of the project.
   * @param {string} playerId The player ID supplied by the Authorization service.
   * @param {SetItemBatchBody} [setItemBatchBody] Set batch data items for a player.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DataApi
   */
  public setPublicItemBatch(
    projectId: string,
    playerId: string,
    setItemBatchBody?: SetItemBatchBody,
    options?: AxiosRequestConfig,
  ) {
    return DataApiFp(this.configuration)
      .setPublicItemBatch(projectId, playerId, setItemBatchBody, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * FilesApi - axios parameter creator
 * @export
 */
export const FilesApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Deletes the specified player file. If a WriteLock is provided, the file will only be deleted if it matches the stored WriteLock.
     * @summary Delete Player File
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} key Item key.
     * @param {string} [writeLock] Enforces conflict checking when deleting an existing file. Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFile: async (
      projectId: string,
      playerId: string,
      key: string,
      writeLock?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("deleteFile", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("deleteFile", "playerId", playerId);
      // verify required parameter 'key' is not null or undefined
      assertParamExists("deleteFile", "key", key);
      const localVarPath =
        `/v1/files/projects/{projectId}/players/{playerId}/items/{key}`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)))
          .replace(`{${"key"}}`, encodeURIComponent(String(key)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication Client required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (writeLock !== undefined) {
        localVarQueryParameter["writeLock"] = writeLock;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Generates a signed URL that will allow the client to download the requested player file for a limited period of time. If successful, an object will be returned containing all necessary information to perform the download.
     * @summary Get Player File Download URL
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} key Item key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDownloadUrl: async (
      projectId: string,
      playerId: string,
      key: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("getDownloadUrl", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("getDownloadUrl", "playerId", playerId);
      // verify required parameter 'key' is not null or undefined
      assertParamExists("getDownloadUrl", "key", key);
      const localVarPath =
        `/v1/files/projects/{projectId}/players/{playerId}/items/{key}`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)))
          .replace(`{${"key"}}`, encodeURIComponent(String(key)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication Client required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves the metadata (size, date last modified and created, key, content type, and current WriteLock) of a single player file.
     * @summary Get Player File Metadata
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} key Item key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileMetadata: async (
      projectId: string,
      playerId: string,
      key: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("getFileMetadata", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("getFileMetadata", "playerId", playerId);
      // verify required parameter 'key' is not null or undefined
      assertParamExists("getFileMetadata", "key", key);
      const localVarPath =
        `/v1/files/projects/{projectId}/players/{playerId}/items/{key}/metadata`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)))
          .replace(`{${"key"}}`, encodeURIComponent(String(key)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication Client required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Initiates the player file upload process and returns a URL to which the actual file contents can be uploaded. The type, length and MD5 hash of the file have to be provided up-front. If successful, an object will be returned containing all necessary information to perform the upload.
     * @summary Get Player File upload URL
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} key Item key.
     * @param {FileDetails} [fileDetails]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUploadUrl: async (
      projectId: string,
      playerId: string,
      key: string,
      fileDetails?: FileDetails,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("getUploadUrl", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("getUploadUrl", "playerId", playerId);
      // verify required parameter 'key' is not null or undefined
      assertParamExists("getUploadUrl", "key", key);
      const localVarPath =
        `/v1/files/projects/{projectId}/players/{playerId}/items/{key}`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)))
          .replace(`{${"key"}}`, encodeURIComponent(String(key)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication Client required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        fileDetails,
        localVarRequestOptions,
        configuration,
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves a list of names of all the files currently saved in storage for a player along with size (in bytes), last date modified and current WriteLock. Ordered alphabetically in page sizes of 20.
     * @summary List Player Files
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} [after] The key after which to retrieve the next page of files.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPlayerFiles: async (
      projectId: string,
      playerId: string,
      after?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'projectId' is not null or undefined
      assertParamExists("listPlayerFiles", "projectId", projectId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("listPlayerFiles", "playerId", playerId);
      const localVarPath =
        `/v1/files/projects/{projectId}/players/{playerId}/items`
          .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
          .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication ServiceAccount required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      // authentication Client required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (after !== undefined) {
        localVarQueryParameter["after"] = after;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FilesApi - functional programming interface
 * @export
 */
export const FilesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FilesApiAxiosParamCreator(configuration);
  return {
    /**
     * Deletes the specified player file. If a WriteLock is provided, the file will only be deleted if it matches the stored WriteLock.
     * @summary Delete Player File
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} key Item key.
     * @param {string} [writeLock] Enforces conflict checking when deleting an existing file. Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteFile(
      projectId: string,
      playerId: string,
      key: string,
      writeLock?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFile(
        projectId,
        playerId,
        key,
        writeLock,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Generates a signed URL that will allow the client to download the requested player file for a limited period of time. If successful, an object will be returned containing all necessary information to perform the download.
     * @summary Get Player File Download URL
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} key Item key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getDownloadUrl(
      projectId: string,
      playerId: string,
      key: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SignedUrlResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getDownloadUrl(
        projectId,
        playerId,
        key,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Retrieves the metadata (size, date last modified and created, key, content type, and current WriteLock) of a single player file.
     * @summary Get Player File Metadata
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} key Item key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFileMetadata(
      projectId: string,
      playerId: string,
      key: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileItem>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getFileMetadata(
        projectId,
        playerId,
        key,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Initiates the player file upload process and returns a URL to which the actual file contents can be uploaded. The type, length and MD5 hash of the file have to be provided up-front. If successful, an object will be returned containing all necessary information to perform the upload.
     * @summary Get Player File upload URL
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} key Item key.
     * @param {FileDetails} [fileDetails]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUploadUrl(
      projectId: string,
      playerId: string,
      key: string,
      fileDetails?: FileDetails,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<SignedUrlResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getUploadUrl(
        projectId,
        playerId,
        key,
        fileDetails,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
    /**
     * Retrieves a list of names of all the files currently saved in storage for a player along with size (in bytes), last date modified and current WriteLock. Ordered alphabetically in page sizes of 20.
     * @summary List Player Files
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} [after] The key after which to retrieve the next page of files.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listPlayerFiles(
      projectId: string,
      playerId: string,
      after?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileList>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.listPlayerFiles(
        projectId,
        playerId,
        after,
        options,
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration,
      );
    },
  };
};

/**
 * FilesApi - factory interface
 * @export
 */
export const FilesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  const localVarFp = FilesApiFp(configuration);
  return {
    /**
     * Deletes the specified player file. If a WriteLock is provided, the file will only be deleted if it matches the stored WriteLock.
     * @summary Delete Player File
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} key Item key.
     * @param {string} [writeLock] Enforces conflict checking when deleting an existing file. Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFile(
      projectId: string,
      playerId: string,
      key: string,
      writeLock?: string,
      options?: any,
    ): AxiosPromise<void> {
      return localVarFp
        .deleteFile(projectId, playerId, key, writeLock, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Generates a signed URL that will allow the client to download the requested player file for a limited period of time. If successful, an object will be returned containing all necessary information to perform the download.
     * @summary Get Player File Download URL
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} key Item key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getDownloadUrl(
      projectId: string,
      playerId: string,
      key: string,
      options?: any,
    ): AxiosPromise<SignedUrlResponse> {
      return localVarFp
        .getDownloadUrl(projectId, playerId, key, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves the metadata (size, date last modified and created, key, content type, and current WriteLock) of a single player file.
     * @summary Get Player File Metadata
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} key Item key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileMetadata(
      projectId: string,
      playerId: string,
      key: string,
      options?: any,
    ): AxiosPromise<FileItem> {
      return localVarFp
        .getFileMetadata(projectId, playerId, key, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Initiates the player file upload process and returns a URL to which the actual file contents can be uploaded. The type, length and MD5 hash of the file have to be provided up-front. If successful, an object will be returned containing all necessary information to perform the upload.
     * @summary Get Player File upload URL
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} key Item key.
     * @param {FileDetails} [fileDetails]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUploadUrl(
      projectId: string,
      playerId: string,
      key: string,
      fileDetails?: FileDetails,
      options?: any,
    ): AxiosPromise<SignedUrlResponse> {
      return localVarFp
        .getUploadUrl(projectId, playerId, key, fileDetails, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves a list of names of all the files currently saved in storage for a player along with size (in bytes), last date modified and current WriteLock. Ordered alphabetically in page sizes of 20.
     * @summary List Player Files
     * @param {string} projectId ID of the project.
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} [after] The key after which to retrieve the next page of files.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listPlayerFiles(
      projectId: string,
      playerId: string,
      after?: string,
      options?: any,
    ): AxiosPromise<FileList> {
      return localVarFp
        .listPlayerFiles(projectId, playerId, after, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export class FilesApi extends BaseAPI {
  /**
   * Deletes the specified player file. If a WriteLock is provided, the file will only be deleted if it matches the stored WriteLock.
   * @summary Delete Player File
   * @param {string} projectId ID of the project.
   * @param {string} playerId The player ID supplied by the Authorization service.
   * @param {string} key Item key.
   * @param {string} [writeLock] Enforces conflict checking when deleting an existing file. Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FilesApi
   */
  public deleteFile(
    projectId: string,
    playerId: string,
    key: string,
    writeLock?: string,
    options?: AxiosRequestConfig,
  ) {
    return FilesApiFp(this.configuration)
      .deleteFile(projectId, playerId, key, writeLock, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Generates a signed URL that will allow the client to download the requested player file for a limited period of time. If successful, an object will be returned containing all necessary information to perform the download.
   * @summary Get Player File Download URL
   * @param {string} projectId ID of the project.
   * @param {string} playerId The player ID supplied by the Authorization service.
   * @param {string} key Item key.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FilesApi
   */
  public getDownloadUrl(
    projectId: string,
    playerId: string,
    key: string,
    options?: AxiosRequestConfig,
  ) {
    return FilesApiFp(this.configuration)
      .getDownloadUrl(projectId, playerId, key, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves the metadata (size, date last modified and created, key, content type, and current WriteLock) of a single player file.
   * @summary Get Player File Metadata
   * @param {string} projectId ID of the project.
   * @param {string} playerId The player ID supplied by the Authorization service.
   * @param {string} key Item key.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FilesApi
   */
  public getFileMetadata(
    projectId: string,
    playerId: string,
    key: string,
    options?: AxiosRequestConfig,
  ) {
    return FilesApiFp(this.configuration)
      .getFileMetadata(projectId, playerId, key, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Initiates the player file upload process and returns a URL to which the actual file contents can be uploaded. The type, length and MD5 hash of the file have to be provided up-front. If successful, an object will be returned containing all necessary information to perform the upload.
   * @summary Get Player File upload URL
   * @param {string} projectId ID of the project.
   * @param {string} playerId The player ID supplied by the Authorization service.
   * @param {string} key Item key.
   * @param {FileDetails} [fileDetails]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FilesApi
   */
  public getUploadUrl(
    projectId: string,
    playerId: string,
    key: string,
    fileDetails?: FileDetails,
    options?: AxiosRequestConfig,
  ) {
    return FilesApiFp(this.configuration)
      .getUploadUrl(projectId, playerId, key, fileDetails, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Retrieves a list of names of all the files currently saved in storage for a player along with size (in bytes), last date modified and current WriteLock. Ordered alphabetically in page sizes of 20.
   * @summary List Player Files
   * @param {string} projectId ID of the project.
   * @param {string} playerId The player ID supplied by the Authorization service.
   * @param {string} [after] The key after which to retrieve the next page of files.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FilesApi
   */
  public listPlayerFiles(
    projectId: string,
    playerId: string,
    after?: string,
    options?: AxiosRequestConfig,
  ) {
    return FilesApiFp(this.configuration)
      .listPlayerFiles(projectId, playerId, after, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
