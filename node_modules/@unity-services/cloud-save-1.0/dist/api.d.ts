/**
 * Cloud Save API
 * # Introduction This is the API specification for the Unity Cloud Save service that allows player state to be persisted from a game client. To use this API, you must first enable it through the Unity Gaming Services dashboard. ### Notes about the Alpha version This API is currently in its alpha phase and is only available to invited users. During the Alpha period, the information in this document is not guaranteed to be up-to-date and may change without notice. # General Information ## Concepts There are two concepts for saving state in the Cloud Save service, \'Data\' and \'Files\'. Both types of state are stored against a specific player. ### Data \'Data\' are small JSON serializable data, up to 1KB in size, stored as key/value pairs. Limits: - Max 1KB in size - Max 200 items per player  ### Files \'Files\' are larger blobs of arbitrary data, up to 100MB. Limits: - Max 100MB in size - Max 20 files per player ## Rate Limits The API has rate limiting in place. Requests are limited to 30 requests per minute on a per-player basis. The API responds with a `429` HTTP status code if the rate limit is exceeded. It will also respond with a `Retry-After` header to be used in conjunction with a client\'s retry logic. The value is the number of seconds until a request for the given player will be accepted.
 *
 * The version of the OpenAPI document: 1.0-alpha
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import { Configuration } from "./configuration";
import { AxiosPromise, AxiosInstance, AxiosRequestConfig } from "axios";
import { RequestArgs, BaseAPI } from "./base";
/**
 * Response type for an attempted Data Item sent to the Cloud Save service.
 * @export
 * @interface AttemptedItem
 */
export interface AttemptedItem {
    /**
     * Item key
     * @type {string}
     * @memberof AttemptedItem
     */
    key: string;
    /**
     * Any JSON serializable structure
     * @type {object}
     * @memberof AttemptedItem
     */
    value: object;
    /**
     * Enforces conflict checking when updating an existing data item. This field should be omitted when creating a new data item. When updating an existing item, omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
     * @type {string}
     * @memberof AttemptedItem
     */
    writeLock: string;
}
/**
 * @type BadRequestOneOfErrorResponse
 * @export
 */
export declare type BadRequestOneOfErrorResponse = BasicErrorResponse | ValidationErrorResponse;
/**
 * Referenced from - https://tools.ietf.org/html/rfc7807#page-3 Consumers MUST use the \'type\' string as the primary identifier for the problem type; the \'title\' string is advisory and included only for users who are not aware of the semantics of the URI and do not have the ability to discover them (e.g., offline log analysis). Consumers SHOULD NOT automatically dereference the type URI. The \"status\" member, if present, is only advisory; it conveys the HTTP status code used for the convenience of the consumer. Generators MUST use the same status code in the actual HTTP response, to assure that generic HTTP software that does not understand this format still behaves correctly.  See Section 5 for further caveats regarding its use. Consumers can use the status member to determine what the original status code used by the generator was, in cases where it has been changed (e.g., by an intermediary or cache), and when message bodies persist without HTTP information.  Generic HTTP software will still use the HTTP status code. The \"detail\" member, if present, ought to focus on helping the client correct the problem, rather than giving debugging information.
 * @export
 * @interface BasicErrorResponse
 */
export interface BasicErrorResponse {
    /**
     * A URI reference [RFC3986] that identifies the problem type. This specification encourages that, when dereferenced, it provide human-readable documentation for the problem type (e.g., using HTML [W3C.REC-html5-20141028]). When this member is not present, its value is assumed to be \"about:blank\".
     * @type {string}
     * @memberof BasicErrorResponse
     */
    type: string;
    /**
     * A short, human-readable summary of the problem type. It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization (e.g., using proactive content negotiation; see [RFC7231], Section 3.4).
     * @type {string}
     * @memberof BasicErrorResponse
     */
    title?: string;
    /**
     * The HTTP status code ([RFC7231], Section 6) generated by the origin server for this occurrence of the problem.
     * @type {number}
     * @memberof BasicErrorResponse
     */
    status?: number;
    /**
     * Service specific error code
     * @type {number}
     * @memberof BasicErrorResponse
     */
    code?: number;
    /**
     * A human-readable explanation specific to this occurrence of the problem.
     * @type {string}
     * @memberof BasicErrorResponse
     */
    detail?: string;
    /**
     * A URI reference that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.
     * @type {string}
     * @memberof BasicErrorResponse
     */
    instance?: string;
    /**
     * Machine readable service specific errors.
     * @type {Array<object>}
     * @memberof BasicErrorResponse
     */
    details?: Array<object>;
}
/**
 * Single error in the Batch Basic Error Response.
 * @export
 * @interface BatchBasicErrorBody
 */
export interface BatchBasicErrorBody {
    /**
     *
     * @type {Array<string>}
     * @memberof BatchBasicErrorBody
     */
    messages: Array<string>;
    /**
     *
     * @type {string}
     * @memberof BatchBasicErrorBody
     */
    key: string;
}
/**
 * Batch basic error response when one or more values provided from the client fails some condition
 * @export
 * @interface BatchBasicErrorResponse
 */
export interface BatchBasicErrorResponse {
    /**
     *
     * @type {string}
     * @memberof BatchBasicErrorResponse
     */
    type: string;
    /**
     *
     * @type {string}
     * @memberof BatchBasicErrorResponse
     */
    title: string;
    /**
     *
     * @type {number}
     * @memberof BatchBasicErrorResponse
     */
    status: number;
    /**
     *
     * @type {number}
     * @memberof BatchBasicErrorResponse
     */
    code: number;
    /**
     *
     * @type {string}
     * @memberof BatchBasicErrorResponse
     */
    detail: string;
    /**
     *
     * @type {string}
     * @memberof BatchBasicErrorResponse
     */
    instance?: string;
    /**
     *
     * @type {Array<BatchBasicErrorBody>}
     * @memberof BatchBasicErrorResponse
     */
    errors: Array<BatchBasicErrorBody>;
}
/**
 * An error response sent back upon a batch update containing a resource conflict. All Data Items within the request should be considered unprocessed. The error response data[] property contains the Data Items that conflicted
 * @export
 * @interface BatchConflictErrorResponse
 */
export interface BatchConflictErrorResponse {
    /**
     *
     * @type {string}
     * @memberof BatchConflictErrorResponse
     */
    type: string;
    /**
     *
     * @type {string}
     * @memberof BatchConflictErrorResponse
     */
    title: string;
    /**
     * e.g 409
     * @type {number}
     * @memberof BatchConflictErrorResponse
     */
    status: number;
    /**
     * e.g. 1013
     * @type {number}
     * @memberof BatchConflictErrorResponse
     */
    code: number;
    /**
     *
     * @type {string}
     * @memberof BatchConflictErrorResponse
     */
    detail: string;
    /**
     *
     * @type {string}
     * @memberof BatchConflictErrorResponse
     */
    instance?: string;
    /**
     *
     * @type {Array<BatchConflictErrorResponseData>}
     * @memberof BatchConflictErrorResponse
     */
    data: Array<BatchConflictErrorResponseData>;
}
/**
 *
 * @export
 * @interface BatchConflictErrorResponseData
 */
export interface BatchConflictErrorResponseData {
    /**
     *
     * @type {AttemptedItem}
     * @memberof BatchConflictErrorResponseData
     */
    attempted?: AttemptedItem;
    /**
     *
     * @type {Item}
     * @memberof BatchConflictErrorResponseData
     */
    existing?: Item;
}
/**
 * Single error in the Batch Validation Error Response.
 * @export
 * @interface BatchValidationErrorBody
 */
export interface BatchValidationErrorBody {
    /**
     *
     * @type {string}
     * @memberof BatchValidationErrorBody
     */
    field: string;
    /**
     *
     * @type {Array<string>}
     * @memberof BatchValidationErrorBody
     */
    messages: Array<string>;
    /**
     *
     * @type {string}
     * @memberof BatchValidationErrorBody
     */
    key: string;
}
/**
 * Batch validation error response when one or more values provided from the client does not pass validation on server
 * @export
 * @interface BatchValidationErrorResponse
 */
export interface BatchValidationErrorResponse {
    /**
     *
     * @type {string}
     * @memberof BatchValidationErrorResponse
     */
    type: string;
    /**
     *
     * @type {string}
     * @memberof BatchValidationErrorResponse
     */
    title: string;
    /**
     *
     * @type {number}
     * @memberof BatchValidationErrorResponse
     */
    status: number;
    /**
     *
     * @type {number}
     * @memberof BatchValidationErrorResponse
     */
    code: number;
    /**
     *
     * @type {string}
     * @memberof BatchValidationErrorResponse
     */
    detail: string;
    /**
     *
     * @type {string}
     * @memberof BatchValidationErrorResponse
     */
    instance?: string;
    /**
     *
     * @type {Array<BatchValidationErrorBody>}
     * @memberof BatchValidationErrorResponse
     */
    errors: Array<BatchValidationErrorBody>;
}
/**
 * An error response sent back upon resource conflict
 * @export
 * @interface ConflictErrorResponse
 */
export interface ConflictErrorResponse {
    /**
     *
     * @type {string}
     * @memberof ConflictErrorResponse
     */
    type: string;
    /**
     *
     * @type {string}
     * @memberof ConflictErrorResponse
     */
    title: string;
    /**
     * e.g 409
     * @type {number}
     * @memberof ConflictErrorResponse
     */
    status: number;
    /**
     * e.g. 1013
     * @type {number}
     * @memberof ConflictErrorResponse
     */
    code: number;
    /**
     *
     * @type {string}
     * @memberof ConflictErrorResponse
     */
    detail: string;
    /**
     *
     * @type {string}
     * @memberof ConflictErrorResponse
     */
    instance?: string;
    /**
     *
     * @type {ConflictErrorResponseData}
     * @memberof ConflictErrorResponse
     */
    data: ConflictErrorResponseData;
}
/**
 *
 * @export
 * @interface ConflictErrorResponseData
 */
export interface ConflictErrorResponseData {
    /**
     *
     * @type {AttemptedItem}
     * @memberof ConflictErrorResponseData
     */
    attempted: AttemptedItem;
    /**
     *
     * @type {Item}
     * @memberof ConflictErrorResponseData
     */
    existing: Item;
}
/**
 *
 * @export
 * @interface FileDetails
 */
export interface FileDetails {
    /**
     * The MIME type of the file that will be uploaded
     * @type {string}
     * @memberof FileDetails
     */
    contentType: string;
    /**
     * The content length in bytes of the file that will be uploaded
     * @type {number}
     * @memberof FileDetails
     */
    contentLength: number;
    /**
     * The base64 encoded MD5 checksum of the file contents that will be uploaded
     * @type {string}
     * @memberof FileDetails
     */
    contentMd5: string;
}
/**
 *
 * @export
 * @interface FileItem
 */
export interface FileItem {
    /**
     *
     * @type {string}
     * @memberof FileItem
     */
    size: string;
    /**
     *
     * @type {ModifiedMetadata}
     * @memberof FileItem
     */
    modified: ModifiedMetadata;
    /**
     *
     * @type {ModifiedMetadata}
     * @memberof FileItem
     */
    created: ModifiedMetadata;
    /**
     *
     * @type {string}
     * @memberof FileItem
     */
    writeLock: string;
    /**
     *
     * @type {string}
     * @memberof FileItem
     */
    contentType: string;
    /**
     *
     * @type {string}
     * @memberof FileItem
     */
    filename?: string;
}
/**
 *
 * @export
 * @interface FileListResponse
 */
export interface FileListResponse {
    /**
     *
     * @type {Array<FileItem>}
     * @memberof FileListResponse
     */
    results?: Array<FileItem>;
    /**
     *
     * @type {FileListResponseLinks}
     * @memberof FileListResponse
     */
    links?: FileListResponseLinks;
}
/**
 *
 * @export
 * @interface FileListResponseLinks
 */
export interface FileListResponseLinks {
    /**
     *
     * @type {string}
     * @memberof FileListResponseLinks
     */
    next?: string | null;
}
/**
 *
 * @export
 * @interface FileStorageSetupDetails
 */
export interface FileStorageSetupDetails {
    /**
     *
     * @type {string}
     * @memberof FileStorageSetupDetails
     */
    organizationId: string;
    /**
     *
     * @type {string}
     * @memberof FileStorageSetupDetails
     */
    projectName: string;
}
/**
 *
 * @export
 * @interface GetItemsResponse
 */
export interface GetItemsResponse {
    /**
     *
     * @type {Array<Item>}
     * @memberof GetItemsResponse
     */
    results: Array<Item>;
    /**
     *
     * @type {GetItemsResponseLinks}
     * @memberof GetItemsResponse
     */
    links: GetItemsResponseLinks;
}
/**
 *
 * @export
 * @interface GetItemsResponseLinks
 */
export interface GetItemsResponseLinks {
    /**
     * Contains the URL path for requesting the next page of results. This value is null when there are no pages remaining.
     * @type {string}
     * @memberof GetItemsResponseLinks
     */
    next: string | null;
}
/**
 *
 * @export
 * @interface GetKeysResponse
 */
export interface GetKeysResponse {
    /**
     *
     * @type {Array<KeyMetadata>}
     * @memberof GetKeysResponse
     */
    results: Array<KeyMetadata>;
    /**
     *
     * @type {GetItemsResponseLinks}
     * @memberof GetKeysResponse
     */
    links: GetItemsResponseLinks;
}
/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * Indicates whether the project has been provisioned by the Cloud Save service
     * @type {boolean}
     * @memberof InlineResponse200
     */
    isProvisioned: boolean;
}
/**
 * Response type for a Data Item stored in the Cloud Save service.
 * @export
 * @interface Item
 */
export interface Item {
    /**
     * Item key
     * @type {string}
     * @memberof Item
     */
    key: string;
    /**
     * Any JSON serializable structure
     * @type {object}
     * @memberof Item
     */
    value: object;
    /**
     * Enforces conflict checking when updating an existing data item. This field should be omitted when creating a new data item. When updating an existing item, omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
     * @type {string}
     * @memberof Item
     */
    writeLock: string;
    /**
     *
     * @type {ModifiedMetadata}
     * @memberof Item
     */
    modified: ModifiedMetadata;
    /**
     *
     * @type {ModifiedMetadata}
     * @memberof Item
     */
    created: ModifiedMetadata;
}
/**
 * Response type Key + Metadata for an individual data item stored in the Cloud Save service.
 * @export
 * @interface KeyMetadata
 */
export interface KeyMetadata {
    /**
     * Item key
     * @type {string}
     * @memberof KeyMetadata
     */
    key: string;
    /**
     * Enforces conflict checking when updating an existing data item. This field should be omitted when creating a new data item. When updating an existing item, omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
     * @type {string}
     * @memberof KeyMetadata
     */
    writeLock: string;
    /**
     *
     * @type {ModifiedMetadata}
     * @memberof KeyMetadata
     */
    modified: ModifiedMetadata;
}
/**
 *
 * @export
 * @interface ModifiedMetadata
 */
export interface ModifiedMetadata {
    /**
     * Date time in ISO 8601 format. Null if there is no associated value.
     * @type {string}
     * @memberof ModifiedMetadata
     */
    date: string | null;
}
/**
 *
 * @export
 * @interface SetItemBatchBody
 */
export interface SetItemBatchBody {
    /**
     *
     * @type {Array<SetItemBody>}
     * @memberof SetItemBatchBody
     */
    data?: Array<SetItemBody>;
}
/**
 *
 * @export
 * @interface SetItemBatchResponse
 */
export interface SetItemBatchResponse {
    /**
     *
     * @type {Array<SetItemBatchResponseResults>}
     * @memberof SetItemBatchResponse
     */
    results?: Array<SetItemBatchResponseResults>;
}
/**
 *
 * @export
 * @interface SetItemBatchResponseResults
 */
export interface SetItemBatchResponseResults {
    /**
     * Item key
     * @type {string}
     * @memberof SetItemBatchResponseResults
     */
    key: string;
    /**
     * Enforces conflict checking when updating an existing data item. This field should be omitted when creating a new data item. When updating an existing item, omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
     * @type {string}
     * @memberof SetItemBatchResponseResults
     */
    writeLock: string;
}
/**
 * Request type for a Data Item to store in the Cloud Save service.
 * @export
 * @interface SetItemBody
 */
export interface SetItemBody {
    /**
     * The key will be created if it does not exist, provided the item limit has not been reached for this entity.
     * @type {string}
     * @memberof SetItemBody
     */
    key: string;
    /**
     * Any JSON serializable structure
     * @type {object}
     * @memberof SetItemBody
     */
    value: object;
    /**
     * Enforces conflict checking when updating an existing data item. This field should be omitted when creating a new data item. When updating an existing item, omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
     * @type {string}
     * @memberof SetItemBody
     */
    writeLock?: string;
}
/**
 *
 * @export
 * @interface SetItemResponse
 */
export interface SetItemResponse {
    /**
     * Enforces conflict checking when updating an existing data item. This field should be omitted when creating a new data item. When updating an existing item, omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
     * @type {string}
     * @memberof SetItemResponse
     */
    writeLock: string;
}
/**
 * An object containing a signed URL for a resource and the necessary information needed to access it.
 * @export
 * @interface SignedUrlResponse
 */
export interface SignedUrlResponse {
    /**
     * The signed URL used to access the resource.
     * @type {string}
     * @memberof SignedUrlResponse
     */
    signedUrl?: string;
    /**
     * The HTTP method that must be used on the signedUrl.
     * @type {string}
     * @memberof SignedUrlResponse
     */
    httpMethod?: string;
    /**
     * The set of HTTP headers that must be sent with the  request for it to succeed.
     * @type {object}
     * @memberof SignedUrlResponse
     */
    requiredHeaders?: object;
}
/**
 * Single error in the Validation Error Response.
 * @export
 * @interface ValidationErrorBody
 */
export interface ValidationErrorBody {
    /**
     *
     * @type {string}
     * @memberof ValidationErrorBody
     */
    field: string;
    /**
     *
     * @type {Array<string>}
     * @memberof ValidationErrorBody
     */
    messages: Array<string>;
}
/**
 * Validation error response when a value provided from the client does not pass validation on server
 * @export
 * @interface ValidationErrorResponse
 */
export interface ValidationErrorResponse {
    /**
     *
     * @type {string}
     * @memberof ValidationErrorResponse
     */
    type: string;
    /**
     *
     * @type {string}
     * @memberof ValidationErrorResponse
     */
    title: string;
    /**
     *
     * @type {number}
     * @memberof ValidationErrorResponse
     */
    status: number;
    /**
     *
     * @type {number}
     * @memberof ValidationErrorResponse
     */
    code: number;
    /**
     *
     * @type {string}
     * @memberof ValidationErrorResponse
     */
    detail: string;
    /**
     *
     * @type {string}
     * @memberof ValidationErrorResponse
     */
    instance?: string;
    /**
     *
     * @type {Array<ValidationErrorBody>}
     * @memberof ValidationErrorResponse
     */
    errors: Array<ValidationErrorBody>;
}
/**
 * DataApi - axios parameter creator
 * @export
 */
export declare const DataApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Deletes a data item by the specified key.
     * @summary Delete Item
     * @param {string} key
     * @param {string} projectId Project ID
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} [writeLock] Enforces conflict checking when deleting an existing data item.  Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteItem: (key: string, projectId: string, playerId: string, writeLock?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieves save data values for all keys specified, ordered alphabetically in pages of 20. If no keys are supplied then returns all keys, ordered alphabetically in pages of 20.
     * @summary Get Items
     * @param {string} projectId Project ID
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {Array<string>} [keys] The keys to retrieve, in exploded form style, e.g. &#x60;keys&#x3D;KEY1&amp;keys&#x3D;KEY2&amp;keys&#x3D;KEY3&#x60;
     * @param {string} [after] The key after which to retrieve the next page of keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getItems: (projectId: string, playerId: string, keys?: Array<string>, after?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Gets a paged list of keys for the given player, ordered alphabetically in pages of 100.
     * @summary Get Keys
     * @param {string} projectId Project ID
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} [after] Returns the page of results after the key specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getKeys: (projectId: string, playerId: string, after?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Set a data item with a given key and value for the specified player. The value is limited to a maximum size of 1KB. The entire save state for a player is limited to 200 keys. Attempting to set a new key beyond this limit will result in an error.
     * @summary Set Item
     * @param {string} projectId Project ID
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {SetItemBody} [setItemBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setItem: (projectId: string, playerId: string, setItemBody?: SetItemBody, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Set up to 20 data items with key, value and optional writeLock. The values are each limited to a maximum size of 1KB. The entire save state for a player is limited to 200 keys. Attempting to set a new key beyond this limit will result in an error. The batch set operation is considered atomic and if any of the set key operation fails, the entire operation is failed. Error responses should identify the affected key operations that failed.
     * @summary Set Item Batch
     * @param {string} projectId Project ID
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {SetItemBatchBody} [setItemBatchBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setItemBatch: (projectId: string, playerId: string, setItemBatchBody?: SetItemBatchBody, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * DataApi - functional programming interface
 * @export
 */
export declare const DataApiFp: (configuration?: Configuration) => {
    /**
     * Deletes a data item by the specified key.
     * @summary Delete Item
     * @param {string} key
     * @param {string} projectId Project ID
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} [writeLock] Enforces conflict checking when deleting an existing data item.  Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteItem(key: string, projectId: string, playerId: string, writeLock?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Retrieves save data values for all keys specified, ordered alphabetically in pages of 20. If no keys are supplied then returns all keys, ordered alphabetically in pages of 20.
     * @summary Get Items
     * @param {string} projectId Project ID
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {Array<string>} [keys] The keys to retrieve, in exploded form style, e.g. &#x60;keys&#x3D;KEY1&amp;keys&#x3D;KEY2&amp;keys&#x3D;KEY3&#x60;
     * @param {string} [after] The key after which to retrieve the next page of keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getItems(projectId: string, playerId: string, keys?: Array<string>, after?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetItemsResponse>>;
    /**
     * Gets a paged list of keys for the given player, ordered alphabetically in pages of 100.
     * @summary Get Keys
     * @param {string} projectId Project ID
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} [after] Returns the page of results after the key specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getKeys(projectId: string, playerId: string, after?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetKeysResponse>>;
    /**
     * Set a data item with a given key and value for the specified player. The value is limited to a maximum size of 1KB. The entire save state for a player is limited to 200 keys. Attempting to set a new key beyond this limit will result in an error.
     * @summary Set Item
     * @param {string} projectId Project ID
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {SetItemBody} [setItemBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setItem(projectId: string, playerId: string, setItemBody?: SetItemBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetItemResponse>>;
    /**
     * Set up to 20 data items with key, value and optional writeLock. The values are each limited to a maximum size of 1KB. The entire save state for a player is limited to 200 keys. Attempting to set a new key beyond this limit will result in an error. The batch set operation is considered atomic and if any of the set key operation fails, the entire operation is failed. Error responses should identify the affected key operations that failed.
     * @summary Set Item Batch
     * @param {string} projectId Project ID
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {SetItemBatchBody} [setItemBatchBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setItemBatch(projectId: string, playerId: string, setItemBatchBody?: SetItemBatchBody, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetItemBatchResponse>>;
};
/**
 * DataApi - factory interface
 * @export
 */
export declare const DataApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Deletes a data item by the specified key.
     * @summary Delete Item
     * @param {string} key
     * @param {string} projectId Project ID
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} [writeLock] Enforces conflict checking when deleting an existing data item.  Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteItem(key: string, projectId: string, playerId: string, writeLock?: string, options?: any): AxiosPromise<void>;
    /**
     * Retrieves save data values for all keys specified, ordered alphabetically in pages of 20. If no keys are supplied then returns all keys, ordered alphabetically in pages of 20.
     * @summary Get Items
     * @param {string} projectId Project ID
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {Array<string>} [keys] The keys to retrieve, in exploded form style, e.g. &#x60;keys&#x3D;KEY1&amp;keys&#x3D;KEY2&amp;keys&#x3D;KEY3&#x60;
     * @param {string} [after] The key after which to retrieve the next page of keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getItems(projectId: string, playerId: string, keys?: Array<string>, after?: string, options?: any): AxiosPromise<GetItemsResponse>;
    /**
     * Gets a paged list of keys for the given player, ordered alphabetically in pages of 100.
     * @summary Get Keys
     * @param {string} projectId Project ID
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} [after] Returns the page of results after the key specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getKeys(projectId: string, playerId: string, after?: string, options?: any): AxiosPromise<GetKeysResponse>;
    /**
     * Set a data item with a given key and value for the specified player. The value is limited to a maximum size of 1KB. The entire save state for a player is limited to 200 keys. Attempting to set a new key beyond this limit will result in an error.
     * @summary Set Item
     * @param {string} projectId Project ID
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {SetItemBody} [setItemBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setItem(projectId: string, playerId: string, setItemBody?: SetItemBody, options?: any): AxiosPromise<SetItemResponse>;
    /**
     * Set up to 20 data items with key, value and optional writeLock. The values are each limited to a maximum size of 1KB. The entire save state for a player is limited to 200 keys. Attempting to set a new key beyond this limit will result in an error. The batch set operation is considered atomic and if any of the set key operation fails, the entire operation is failed. Error responses should identify the affected key operations that failed.
     * @summary Set Item Batch
     * @param {string} projectId Project ID
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {SetItemBatchBody} [setItemBatchBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setItemBatch(projectId: string, playerId: string, setItemBatchBody?: SetItemBatchBody, options?: any): AxiosPromise<SetItemBatchResponse>;
};
/**
 * DataApi - object-oriented interface
 * @export
 * @class DataApi
 * @extends {BaseAPI}
 */
export declare class DataApi extends BaseAPI {
    /**
     * Deletes a data item by the specified key.
     * @summary Delete Item
     * @param {string} key
     * @param {string} projectId Project ID
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} [writeLock] Enforces conflict checking when deleting an existing data item.  Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    deleteItem(key: string, projectId: string, playerId: string, writeLock?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Retrieves save data values for all keys specified, ordered alphabetically in pages of 20. If no keys are supplied then returns all keys, ordered alphabetically in pages of 20.
     * @summary Get Items
     * @param {string} projectId Project ID
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {Array<string>} [keys] The keys to retrieve, in exploded form style, e.g. &#x60;keys&#x3D;KEY1&amp;keys&#x3D;KEY2&amp;keys&#x3D;KEY3&#x60;
     * @param {string} [after] The key after which to retrieve the next page of keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    getItems(projectId: string, playerId: string, keys?: Array<string>, after?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GetItemsResponse>>;
    /**
     * Gets a paged list of keys for the given player, ordered alphabetically in pages of 100.
     * @summary Get Keys
     * @param {string} projectId Project ID
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} [after] Returns the page of results after the key specified.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    getKeys(projectId: string, playerId: string, after?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<GetKeysResponse>>;
    /**
     * Set a data item with a given key and value for the specified player. The value is limited to a maximum size of 1KB. The entire save state for a player is limited to 200 keys. Attempting to set a new key beyond this limit will result in an error.
     * @summary Set Item
     * @param {string} projectId Project ID
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {SetItemBody} [setItemBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    setItem(projectId: string, playerId: string, setItemBody?: SetItemBody, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<SetItemResponse>>;
    /**
     * Set up to 20 data items with key, value and optional writeLock. The values are each limited to a maximum size of 1KB. The entire save state for a player is limited to 200 keys. Attempting to set a new key beyond this limit will result in an error. The batch set operation is considered atomic and if any of the set key operation fails, the entire operation is failed. Error responses should identify the affected key operations that failed.
     * @summary Set Item Batch
     * @param {string} projectId Project ID
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {SetItemBatchBody} [setItemBatchBody]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataApi
     */
    setItemBatch(projectId: string, playerId: string, setItemBatchBody?: SetItemBatchBody, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<SetItemBatchResponse>>;
}
/**
 * FilesApi - axios parameter creator
 * @export
 */
export declare const FilesApiAxiosParamCreator: (configuration?: Configuration) => {
    /**
     * Initiates the file upload process and returns a URL to which the actual file contents can be uploaded. The type, length and MD5 hash of the file have to be provided up-front. If successful, an object will be returned containing all necessary information to perform the upload. There are limits to how many files and how much total storage a single entity can have, if they are exceeded an error will be returned.
     * @summary Create File Upload Location
     * @param {string} projectId Project ID
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} filename
     * @param {FileDetails} [fileDetails]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUploadUrl: (projectId: string, playerId: string, filename: string, fileDetails?: FileDetails, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Deletes the specified file. If a WriteLock is provided, the file will only be deleted if it matches the stored WriteLock.
     * @summary Delete File
     * @param {string} projectId Project ID
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} filename
     * @param {string} [writeLock] Enforces conflict checking when deleting a file. Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFile: (projectId: string, playerId: string, filename: string, writeLock?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Generates a signed URL that will allow the client to download the requested file for a limited period of time.  If successful, an object will be returned containing all necessary information to perform the download.
     * @summary Get file download URL
     * @param {string} projectId Project ID
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} filename
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileUrl: (projectId: string, playerId: string, filename: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Returns details about a Cloud Save project. In this version, only the provisioning status is returned.
     * @summary Get project details
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectDetails: (projectId: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Retrieves a list of names of all the files currently saved in storage along with size (in bytes), last date modified and current WriteLock.  Ordered alphabetically in page sizes of 20.
     * @summary List files
     * @param {string} projectId Project ID
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} [after] The filename after which to retrieve the list of files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listFiles: (projectId: string, playerId: string, after?: string, options?: AxiosRequestConfig) => Promise<RequestArgs>;
    /**
     * Provisions a bucket for the project if one does not already exist using the data from the request body as labels for the bucket.  If successful, a bucket will be created and made available for further files operations.
     * @summary Provision File Storage
     * @param {string} projectId Project ID
     * @param {FileStorageSetupDetails} [fileStorageSetupDetails] JSON containing 2 properties which are: organization ID and the project name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setupFileStorage: (projectId: string, fileStorageSetupDetails?: FileStorageSetupDetails, options?: AxiosRequestConfig) => Promise<RequestArgs>;
};
/**
 * FilesApi - functional programming interface
 * @export
 */
export declare const FilesApiFp: (configuration?: Configuration) => {
    /**
     * Initiates the file upload process and returns a URL to which the actual file contents can be uploaded. The type, length and MD5 hash of the file have to be provided up-front. If successful, an object will be returned containing all necessary information to perform the upload. There are limits to how many files and how much total storage a single entity can have, if they are exceeded an error will be returned.
     * @summary Create File Upload Location
     * @param {string} projectId Project ID
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} filename
     * @param {FileDetails} [fileDetails]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUploadUrl(projectId: string, playerId: string, filename: string, fileDetails?: FileDetails, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignedUrlResponse>>;
    /**
     * Deletes the specified file. If a WriteLock is provided, the file will only be deleted if it matches the stored WriteLock.
     * @summary Delete File
     * @param {string} projectId Project ID
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} filename
     * @param {string} [writeLock] Enforces conflict checking when deleting a file. Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFile(projectId: string, playerId: string, filename: string, writeLock?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
    /**
     * Generates a signed URL that will allow the client to download the requested file for a limited period of time.  If successful, an object will be returned containing all necessary information to perform the download.
     * @summary Get file download URL
     * @param {string} projectId Project ID
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} filename
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileUrl(projectId: string, playerId: string, filename: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SignedUrlResponse>>;
    /**
     * Returns details about a Cloud Save project. In this version, only the provisioning status is returned.
     * @summary Get project details
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectDetails(projectId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>>;
    /**
     * Retrieves a list of names of all the files currently saved in storage along with size (in bytes), last date modified and current WriteLock.  Ordered alphabetically in page sizes of 20.
     * @summary List files
     * @param {string} projectId Project ID
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} [after] The filename after which to retrieve the list of files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listFiles(projectId: string, playerId: string, after?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileListResponse>>;
    /**
     * Provisions a bucket for the project if one does not already exist using the data from the request body as labels for the bucket.  If successful, a bucket will be created and made available for further files operations.
     * @summary Provision File Storage
     * @param {string} projectId Project ID
     * @param {FileStorageSetupDetails} [fileStorageSetupDetails] JSON containing 2 properties which are: organization ID and the project name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setupFileStorage(projectId: string, fileStorageSetupDetails?: FileStorageSetupDetails, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>>;
};
/**
 * FilesApi - factory interface
 * @export
 */
export declare const FilesApiFactory: (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) => {
    /**
     * Initiates the file upload process and returns a URL to which the actual file contents can be uploaded. The type, length and MD5 hash of the file have to be provided up-front. If successful, an object will be returned containing all necessary information to perform the upload. There are limits to how many files and how much total storage a single entity can have, if they are exceeded an error will be returned.
     * @summary Create File Upload Location
     * @param {string} projectId Project ID
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} filename
     * @param {FileDetails} [fileDetails]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUploadUrl(projectId: string, playerId: string, filename: string, fileDetails?: FileDetails, options?: any): AxiosPromise<SignedUrlResponse>;
    /**
     * Deletes the specified file. If a WriteLock is provided, the file will only be deleted if it matches the stored WriteLock.
     * @summary Delete File
     * @param {string} projectId Project ID
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} filename
     * @param {string} [writeLock] Enforces conflict checking when deleting a file. Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteFile(projectId: string, playerId: string, filename: string, writeLock?: string, options?: any): AxiosPromise<void>;
    /**
     * Generates a signed URL that will allow the client to download the requested file for a limited period of time.  If successful, an object will be returned containing all necessary information to perform the download.
     * @summary Get file download URL
     * @param {string} projectId Project ID
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} filename
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileUrl(projectId: string, playerId: string, filename: string, options?: any): AxiosPromise<SignedUrlResponse>;
    /**
     * Returns details about a Cloud Save project. In this version, only the provisioning status is returned.
     * @summary Get project details
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getProjectDetails(projectId: string, options?: any): AxiosPromise<InlineResponse200>;
    /**
     * Retrieves a list of names of all the files currently saved in storage along with size (in bytes), last date modified and current WriteLock.  Ordered alphabetically in page sizes of 20.
     * @summary List files
     * @param {string} projectId Project ID
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} [after] The filename after which to retrieve the list of files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listFiles(projectId: string, playerId: string, after?: string, options?: any): AxiosPromise<FileListResponse>;
    /**
     * Provisions a bucket for the project if one does not already exist using the data from the request body as labels for the bucket.  If successful, a bucket will be created and made available for further files operations.
     * @summary Provision File Storage
     * @param {string} projectId Project ID
     * @param {FileStorageSetupDetails} [fileStorageSetupDetails] JSON containing 2 properties which are: organization ID and the project name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setupFileStorage(projectId: string, fileStorageSetupDetails?: FileStorageSetupDetails, options?: any): AxiosPromise<void>;
};
/**
 * FilesApi - object-oriented interface
 * @export
 * @class FilesApi
 * @extends {BaseAPI}
 */
export declare class FilesApi extends BaseAPI {
    /**
     * Initiates the file upload process and returns a URL to which the actual file contents can be uploaded. The type, length and MD5 hash of the file have to be provided up-front. If successful, an object will be returned containing all necessary information to perform the upload. There are limits to how many files and how much total storage a single entity can have, if they are exceeded an error will be returned.
     * @summary Create File Upload Location
     * @param {string} projectId Project ID
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} filename
     * @param {FileDetails} [fileDetails]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    createUploadUrl(projectId: string, playerId: string, filename: string, fileDetails?: FileDetails, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<SignedUrlResponse>>;
    /**
     * Deletes the specified file. If a WriteLock is provided, the file will only be deleted if it matches the stored WriteLock.
     * @summary Delete File
     * @param {string} projectId Project ID
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} filename
     * @param {string} [writeLock] Enforces conflict checking when deleting a file. Omitting this field ignores write conflicts. When present, an error response will be returned if the writeLock in the request does not match the stored writeLock.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    deleteFile(projectId: string, playerId: string, filename: string, writeLock?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void>>;
    /**
     * Generates a signed URL that will allow the client to download the requested file for a limited period of time.  If successful, an object will be returned containing all necessary information to perform the download.
     * @summary Get file download URL
     * @param {string} projectId Project ID
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} filename
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    getFileUrl(projectId: string, playerId: string, filename: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<SignedUrlResponse>>;
    /**
     * Returns details about a Cloud Save project. In this version, only the provisioning status is returned.
     * @summary Get project details
     * @param {string} projectId Project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    getProjectDetails(projectId: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<InlineResponse200>>;
    /**
     * Retrieves a list of names of all the files currently saved in storage along with size (in bytes), last date modified and current WriteLock.  Ordered alphabetically in page sizes of 20.
     * @summary List files
     * @param {string} projectId Project ID
     * @param {string} playerId The player ID supplied by the Authorization service.
     * @param {string} [after] The filename after which to retrieve the list of files
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    listFiles(projectId: string, playerId: string, after?: string, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<FileListResponse>>;
    /**
     * Provisions a bucket for the project if one does not already exist using the data from the request body as labels for the bucket.  If successful, a bucket will be created and made available for further files operations.
     * @summary Provision File Storage
     * @param {string} projectId Project ID
     * @param {FileStorageSetupDetails} [fileStorageSetupDetails] JSON containing 2 properties which are: organization ID and the project name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FilesApi
     */
    setupFileStorage(projectId: string, fileStorageSetupDetails?: FileStorageSetupDetails, options?: AxiosRequestConfig): Promise<import("axios").AxiosResponse<void>>;
}
