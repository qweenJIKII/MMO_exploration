/* tslint:disable */
/* eslint-disable */
/**
 * Lobby
 * The Lobby service is a flexible system for games to enable different styles of multiplayer experiences quickly and easily.  A lobby provides a way to browse and join public games, create private games that can be easily joined by others using a code, gather a group together in a party before matchmaking as a group, and more!
 *
 * The version of the OpenAPI document: v1
 * Contact: multiplayer-suite-devs@unity3d.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration";
import globalAxios, {
  AxiosPromise,
  AxiosInstance,
  AxiosRequestConfig,
} from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from "./base";

/**
 * The body of a Bulk Update request.
 * @export
 * @interface BulkUpdateRequest
 */
export interface BulkUpdateRequest {
  /**
   *
   * @type {UpdateRequest}
   * @memberof BulkUpdateRequest
   */
  lobbyUpdate?: UpdateRequest;
  /**
   * A mapping from player IDs to player update requests.
   * @type {{ [key: string]: PlayerUpdateRequest; }}
   * @memberof BulkUpdateRequest
   */
  playerUpdates?: { [key: string]: PlayerUpdateRequest } | null;
  /**
   * An array of players to add to the lobby.
   * @type {Array<Player>}
   * @memberof BulkUpdateRequest
   */
  playersToAdd?: Array<Player> | null;
  /**
   * An array of player IDs to remove from the lobby.
   * @type {Array<string>}
   * @memberof BulkUpdateRequest
   */
  playersToRemove?: Array<string> | null;
  /**
   * Whether or not to silently ignore ineffectual updates (i.e. removing or updating players who are not in the lobby) instead of failing.
   * @type {boolean}
   * @memberof BulkUpdateRequest
   */
  ignoreIneffectualUpdates?: boolean | null;
}
/**
 * The body of a Create Lobby request.
 * @export
 * @interface CreateRequest
 */
export interface CreateRequest {
  /**
   * The name of the lobby that should be displayed to users.  All whitespace will be trimmed from the name.
   * @type {string}
   * @memberof CreateRequest
   */
  name: string;
  /**
   * The maximum number of players that can be members of the lobby.
   * @type {number}
   * @memberof CreateRequest
   */
  maxPlayers: number;
  /**
   * Whether or not the lobby is private.  Private lobbies do not appear in query results.  If the lobby is not publicly visible, the creator can share the `lobbyCode` with other users who can use it to join this lobby.
   * @type {boolean}
   * @memberof CreateRequest
   */
  isPrivate?: boolean | null;
  /**
   * Whether or not the lobby is locked.  If true, new players will not be able to join.
   * @type {boolean}
   * @memberof CreateRequest
   */
  isLocked?: boolean | null;
  /**
   *
   * @type {Player}
   * @memberof CreateRequest
   */
  player?: Player;
  /**
   * Custom game-specific properties that apply to the lobby (e.g. `mapName` or `gameType`).
   * @type {{ [key: string]: DataObject; }}
   * @memberof CreateRequest
   */
  data?: { [key: string]: DataObject } | null;
}
/**
 * Custom data property for a lobby.
 * @export
 * @interface DataObject
 */
export interface DataObject {
  /**
   * The value of the custom property.  This property can be set to null or an empty string.  If this property is indexed (by setting the `index` field) then the length of the value must be less than 128 bytes.
   * @type {string}
   * @memberof DataObject
   */
  value?: string | null;
  /**
   * Indicates for whom the property should be visible.  If `public`, the property will be visible to everyone and will be included in query results.  If `member`, the data will only be visible to users who are members of the lobby (i.e. those who have successfully joined).  If `private`, the metadata will only be visible to the host.
   * @type {string}
   * @memberof DataObject
   */
  visibility: DataObjectVisibilityEnum;
  /**
   * The name of the column to index this property value under, either `S#` for strings or `N#` for numeric values.  If an index is specified on a property, then you can use that index name in a `QueryFilter` to filter results by that property.  You will not be prevented from indexing multiple objects having properties with different names but the same index, but you will likely receive unexpected results from a query.
   * @type {string}
   * @memberof DataObject
   */
  index?: DataObjectIndexEnum;
}

export const DataObjectVisibilityEnum = {
  Public: "public",
  Member: "member",
  Private: "private",
} as const;

export type DataObjectVisibilityEnum =
  typeof DataObjectVisibilityEnum[keyof typeof DataObjectVisibilityEnum];
export const DataObjectIndexEnum = {
  S1: "S1",
  S2: "S2",
  S3: "S3",
  S4: "S4",
  S5: "S5",
  N1: "N1",
  N2: "N2",
  N3: "N3",
  N4: "N4",
  N5: "N5",
} as const;

export type DataObjectIndexEnum =
  typeof DataObjectIndexEnum[keyof typeof DataObjectIndexEnum];

/**
 * Additional detail about an error.  This may include detailed validation failure messages, debugging information, troubleshooting steps, or more.
 * @export
 * @interface Detail
 */
export interface Detail {
  /**
   *
   * @type {string}
   * @memberof Detail
   */
  errorType?: string;
  /**
   *
   * @type {string}
   * @memberof Detail
   */
  message?: string;
}
/**
 * The body that will be returned for any failing request.  We are using the [RFC 7807 Error Format](https://www.rfc-editor.org/rfc/rfc7807.html#section-3.1).
 * @export
 * @interface ErrorStatus
 */
export interface ErrorStatus {
  /**
   * A URI that identifies the problem type and should provide documentation for the problem.
   * @type {string}
   * @memberof ErrorStatus
   */
  type?: string;
  /**
   * The HTTP status code of the response.
   * @type {number}
   * @memberof ErrorStatus
   */
  status?: number;
  /**
   * A short, human-readable summary of the problem type.  It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
   * @type {string}
   * @memberof ErrorStatus
   */
  title?: string;
  /**
   * A human-readable explanation specific to this occurrence of the problem.
   * @type {string}
   * @memberof ErrorStatus
   */
  detail?: string;
  /**
   * An integer in the range 16000-16999 that uniquely identifies an error type.  This can be used to programatically identify the type of error.
   * @type {number}
   * @memberof ErrorStatus
   */
  code?: number;
  /**
   * A list of additional details about specific errors.
   * @type {Array<Detail>}
   * @memberof ErrorStatus
   */
  details?: Array<Detail>;
}
/**
 * The body of a Join Lobby request using lobby code.
 * @export
 * @interface JoinByCodeRequest
 */
export interface JoinByCodeRequest {
  /**
   * The lobby code of the lobby to join.  Mutually exclusive with `id`.  This is used to join a private lobby where the lobby code was shared to other users manually.
   * @type {string}
   * @memberof JoinByCodeRequest
   */
  lobbyCode: string;
  /**
   *
   * @type {Player}
   * @memberof JoinByCodeRequest
   */
  player?: Player;
}
/**
 * Data about an individual lobby.
 * @export
 * @interface Lobby
 */
export interface Lobby {
  /**
   *
   * @type {string}
   * @memberof Lobby
   */
  id?: string;
  /**
   * A short code that can be used to join a lobby.  This is only visible to lobby members.  Typically this is displayed to the user so they can share it with other players out-of-game.  Users with the code can join a lobby even when it is private.
   * @type {string}
   * @memberof Lobby
   */
  lobbyCode?: string | null;
  /**
   * The Unity project ID of the game.
   * @type {string}
   * @memberof Lobby
   */
  upid?: string;
  /**
   * The ID of the environment this lobby exists in.
   * @type {string}
   * @memberof Lobby
   */
  environmentId?: string;
  /**
   * The name of the lobby.  Typically this is shown in game UI to represent the lobby.
   * @type {string}
   * @memberof Lobby
   */
  name?: string | null;
  /**
   * The maximum number of players that can be members of the lobby.
   * @type {number}
   * @memberof Lobby
   */
  maxPlayers?: number;
  /**
   * The number of remaining open slots for players before the lobby becomes full.
   * @type {number}
   * @memberof Lobby
   */
  availableSlots?: number;
  /**
   * Whether or not the lobby is private.  Private lobbies do not appear in query results.
   * @type {boolean}
   * @memberof Lobby
   */
  isPrivate?: boolean;
  /**
   * Whether or not the lobby is locked.  If true, new players will not be able to join.
   * @type {boolean}
   * @memberof Lobby
   */
  isLocked?: boolean;
  /**
   * The members of the lobby.
   * @type {Array<Player>}
   * @memberof Lobby
   */
  players?: Array<Player>;
  /**
   * Properties of the lobby set by the host.
   * @type {{ [key: string]: DataObject; }}
   * @memberof Lobby
   */
  data?: { [key: string]: DataObject } | null;
  /**
   * The ID of the player that is the lobby host.
   * @type {string}
   * @memberof Lobby
   */
  hostId?: string;
  /**
   * When the lobby was created.  The timestamp is in UTC and conforms to ISO 8601.
   * @type {string}
   * @memberof Lobby
   */
  created?: string;
  /**
   * When the lobby was last updated.  The timestamp is in UTC and conforms to ISO 8601.
   * @type {string}
   * @memberof Lobby
   */
  lastUpdated?: string;
}
/**
 * Information about a specific player creating, joining, or already in a lobby.
 * @export
 * @interface Player
 */
export interface Player {
  /**
   * The unique identifier for the player.  If not provided for a create or join request, it will be set to the ID of the caller.
   * @type {string}
   * @memberof Player
   */
  id?: string | null;
  /**
   * Connection information for connecting to a relay with this player.
   * @type {string}
   * @memberof Player
   * @deprecated
   */
  connectionInfo?: string | null;
  /**
   * Custom game-specific properties that apply to an individual player (e.g. `role` or `skill`).
   * @type {{ [key: string]: PlayerDataObject; }}
   * @memberof Player
   */
  data?: { [key: string]: PlayerDataObject } | null;
  /**
   * The `allocationId` from the Relay service which associates this player in this lobby with a persistent connection.  When a disconnect notification is received, this value is used to identify the associated player in a lobby to mark them as disconnected.
   * @type {string}
   * @memberof Player
   */
  allocationId?: string | null;
  /**
   * The time at which the player joined the lobby.
   * @type {string}
   * @memberof Player
   */
  joined?: string;
  /**
   * The last time the metadata for this player was updated.
   * @type {string}
   * @memberof Player
   */
  lastUpdated?: string;
}
/**
 * Custom data property for a player.
 * @export
 * @interface PlayerDataObject
 */
export interface PlayerDataObject {
  /**
   * The value of the custom property.  This property can be set to null or an empty string.
   * @type {string}
   * @memberof PlayerDataObject
   */
  value?: string | null;
  /**
   * Indicates for whom the property should be visible.  If `public`, the property will be visible to everyone and will be included in query results.  If `member`, the data will only be visible to users who are members of the lobby (i.e. those who have successfully joined).  If `private`, the metadata will only be visible to the player.
   * @type {string}
   * @memberof PlayerDataObject
   */
  visibility: PlayerDataObjectVisibilityEnum;
}

export const PlayerDataObjectVisibilityEnum = {
  Public: "public",
  Member: "member",
  Private: "private",
} as const;

export type PlayerDataObjectVisibilityEnum =
  typeof PlayerDataObjectVisibilityEnum[keyof typeof PlayerDataObjectVisibilityEnum];

/**
 * The body of an Update Player Data request.
 * @export
 * @interface PlayerUpdateRequest
 */
export interface PlayerUpdateRequest {
  /**
   * Connection information for connecting to a relay with this player.
   * @type {string}
   * @memberof PlayerUpdateRequest
   * @deprecated
   */
  connectionInfo?: string | null;
  /**
   * Custom game-specific properties to add, update, or remove from the player (e.g. `role` or `skill`).  To remove an existing property, include it in `data` but set the property object to `null`.  To update the value to `null`, set the `value` property of the object to `null`.
   * @type {{ [key: string]: PlayerDataObject; }}
   * @memberof PlayerUpdateRequest
   */
  data?: { [key: string]: PlayerDataObject } | null;
  /**
   * The `allocationId` from the Relay service which associates this player in this lobby with a persistent connection.  When a disconnect notification is received, this value is used to identify the associated player in a lobby to mark them as disconnected.
   * @type {string}
   * @memberof PlayerUpdateRequest
   */
  allocationId?: string | null;
}
/**
 * A filter for an individual field that is applied to a query.
 * @export
 * @interface QueryFilter
 */
export interface QueryFilter {
  /**
   * The name of the field to filter on.  For custom data fields, the name of the index must be used instead of the field name.
   * @type {string}
   * @memberof QueryFilter
   */
  field: QueryFilterFieldEnum;
  /**
   * The value to compare to the field being filtered.  This value must be a string and it must be parsable as the same type as `field` (e.g. `integer` for MaxPlayers, `datetime` for Created, etc.).  The value for `datetime` fields (Created, LastUpdated) must be in RFC3339 format.  For example, in C# this can be achieved using the \"o\" format specifier: `return dateTime.ToString(\"o\", DateTimeFormatInfo.InvariantInfo);`.  Refer to your language documentation for other methods to generate RFC3339-compatible datetime strings.
   * @type {string}
   * @memberof QueryFilter
   */
  value: string;
  /**
   * The operator used to compare the field to the filter value.  Supports `CONTAINS` (only on the `Name` field), `EQ` (Equal), `NE` (Not Equal), `LT` (Less Than), `LE` (Less Than or Equal), `GT` (Greater Than), and `GE` (Greater Than or Equal).
   * @type {string}
   * @memberof QueryFilter
   */
  op: QueryFilterOpEnum;
}

export const QueryFilterFieldEnum = {
  MaxPlayers: "MaxPlayers",
  AvailableSlots: "AvailableSlots",
  Name: "Name",
  Created: "Created",
  LastUpdated: "LastUpdated",
  S1: "S1",
  S2: "S2",
  S3: "S3",
  S4: "S4",
  S5: "S5",
  N1: "N1",
  N2: "N2",
  N3: "N3",
  N4: "N4",
  N5: "N5",
  IsLocked: "IsLocked",
} as const;

export type QueryFilterFieldEnum =
  typeof QueryFilterFieldEnum[keyof typeof QueryFilterFieldEnum];
export const QueryFilterOpEnum = {
  Contains: "CONTAINS",
  Eq: "EQ",
  Ne: "NE",
  Lt: "LT",
  Le: "LE",
  Gt: "GT",
  Ge: "GE",
} as const;

export type QueryFilterOpEnum =
  typeof QueryFilterOpEnum[keyof typeof QueryFilterOpEnum];

/**
 * An order for an individual field that is applied to a query.
 * @export
 * @interface QueryOrder
 */
export interface QueryOrder {
  /**
   * Whether to sort in ascending or descending order.
   * @type {boolean}
   * @memberof QueryOrder
   */
  asc?: boolean;
  /**
   * The name of the field to order on.
   * @type {string}
   * @memberof QueryOrder
   */
  field?: QueryOrderFieldEnum;
}

export const QueryOrderFieldEnum = {
  Name: "Name",
  MaxPlayers: "MaxPlayers",
  AvailableSlots: "AvailableSlots",
  Created: "Created",
  LastUpdated: "LastUpdated",
  Id: "ID",
  S1: "S1",
  S2: "S2",
  S3: "S3",
  S4: "S4",
  S5: "S5",
  N1: "N1",
  N2: "N2",
  N3: "N3",
  N4: "N4",
  N5: "N5",
} as const;

export type QueryOrderFieldEnum =
  typeof QueryOrderFieldEnum[keyof typeof QueryOrderFieldEnum];

/**
 * The body of a Query request which defines how to sort and filter results, how many results to return, etc.
 * @export
 * @interface QueryRequest
 */
export interface QueryRequest {
  /**
   * The number of results to return.
   * @type {number}
   * @memberof QueryRequest
   */
  count?: number | null;
  /**
   * The number of results to skip before selecting results to return.
   * @type {number}
   * @memberof QueryRequest
   */
  skip?: number | null;
  /**
   * Whether a random sample of results that match the search filter should be returned.
   * @type {boolean}
   * @memberof QueryRequest
   */
  sampleResults?: boolean;
  /**
   * A list of filters which can be used to narrow down which lobbies to return.
   * @type {Array<QueryFilter>}
   * @memberof QueryRequest
   */
  filter?: Array<QueryFilter>;
  /**
   * A list of orders which define how the results should be ordered in the response.
   * @type {Array<QueryOrder>}
   * @memberof QueryRequest
   */
  order?: Array<QueryOrder>;
  /**
   * A continuation token that can be passed to subsequent query requests to fetch the next page of results.
   * @type {string}
   * @memberof QueryRequest
   */
  continuationToken?: string | null;
}
/**
 * A list of lobbies that matched the specified query.  Only the public top-level data and player data properties are returned.
 * @export
 * @interface QueryResponse
 */
export interface QueryResponse {
  /**
   *
   * @type {Array<Lobby>}
   * @memberof QueryResponse
   */
  results?: Array<Lobby>;
  /**
   *
   * @type {string}
   * @memberof QueryResponse
   */
  continuationToken?: string | null;
}
/**
 * The body of a QuickJoin request.
 * @export
 * @interface QuickJoinRequest
 */
export interface QuickJoinRequest {
  /**
   * A list of filters which can be used to narrow down which lobbies to attempt to join.
   * @type {Array<QueryFilter>}
   * @memberof QuickJoinRequest
   */
  filter?: Array<QueryFilter>;
  /**
   *
   * @type {Player}
   * @memberof QuickJoinRequest
   */
  player?: Player;
}
/**
 * The data associated with the token.
 * @export
 * @interface TokenData
 */
export interface TokenData {
  /**
   * The value of the token.
   * @type {string}
   * @memberof TokenData
   */
  tokenValue?: string;
  /**
   * The URI of the token, if applicable.
   * @type {string}
   * @memberof TokenData
   */
  uri?: string;
}
/**
 * Details about a token being requested.
 * @export
 * @interface TokenRequest
 */
export interface TokenRequest {
  /**
   *
   * @type {string}
   * @memberof TokenRequest
   */
  tokenType: TokenRequestTokenTypeEnum;
}

export const TokenRequestTokenTypeEnum = {
  VivoxJoin: "vivoxJoin",
  WireJoin: "wireJoin",
} as const;

export type TokenRequestTokenTypeEnum =
  typeof TokenRequestTokenTypeEnum[keyof typeof TokenRequestTokenTypeEnum];

/**
 * The body of an Update Lobby request.
 * @export
 * @interface UpdateRequest
 */
export interface UpdateRequest {
  /**
   * The name of the lobby that should be displayed to users.  All whitespace will be trimmed from the name.
   * @type {string}
   * @memberof UpdateRequest
   */
  name?: string | null;
  /**
   * The maximum number of players that can be members of the lobby.  Must be greater than or equal to the current number of players in the lobby.
   * @type {number}
   * @memberof UpdateRequest
   */
  maxPlayers?: number | null;
  /**
   * Whether or not the lobby is private.  Private lobbies do not appear in query results.  If the lobby is not publicly visible, the creator can share the `lobbyCode` with other users who can use it to join this lobby.
   * @type {boolean}
   * @memberof UpdateRequest
   */
  isPrivate?: boolean | null;
  /**
   * Whether or not the lobby is locked.  If true, new players will not be able to join.
   * @type {boolean}
   * @memberof UpdateRequest
   */
  isLocked?: boolean | null;
  /**
   * Custom game-specific properties to add, update, or remove from the lobby (e.g. `mapName` or `gameType`).  To remove an existing property, include it in `data` but set the property object to `null`.  To update the value to `null`, set the `value` property of the object to `null`.
   * @type {{ [key: string]: DataObject; }}
   * @memberof UpdateRequest
   */
  data?: { [key: string]: DataObject } | null;
  /**
   * The ID of the player to make the host of the lobby.  As soon as this is updated, the current host will no longer have permission to modify the lobby.
   * @type {string}
   * @memberof UpdateRequest
   */
  hostId?: string | null;
}

/**
 * LobbyApi - axios parameter creator
 * @export
 */
export const LobbyApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Apply a bulk update to a lobby. This can modify the lobby\'s metadata, add players, update players, and remove players. This operation is only allowed for service accounts.
     * @summary Bulk update
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {BulkUpdateRequest} [bulkUpdateRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkUpdateLobby: async (
      lobbyId: string,
      serviceId?: string,
      impersonatedUserId?: string,
      bulkUpdateRequest?: BulkUpdateRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'lobbyId' is not null or undefined
      assertParamExists("bulkUpdateLobby", "lobbyId", lobbyId);
      const localVarPath = `/{lobbyId}/bulkupdate`.replace(
        `{${"lobbyId"}}`,
        encodeURIComponent(String(lobbyId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication JWT required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (serviceId !== undefined && serviceId !== null) {
        localVarHeaderParameter["service-id"] = String(serviceId);
      }

      if (impersonatedUserId !== undefined && impersonatedUserId !== null) {
        localVarHeaderParameter["impersonated-user-id"] =
          String(impersonatedUserId);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        bulkUpdateRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Create a new lobby and return the lobby metadata.
     * @summary Create a lobby
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {CreateRequest} [createRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLobby: async (
      serviceId?: string,
      impersonatedUserId?: string,
      createRequest?: CreateRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/create`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication JWT required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (serviceId !== undefined && serviceId !== null) {
        localVarHeaderParameter["service-id"] = String(serviceId);
      }

      if (impersonatedUserId !== undefined && impersonatedUserId !== null) {
        localVarHeaderParameter["impersonated-user-id"] =
          String(impersonatedUserId);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        createRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Delete a lobby so it\'s no longer discoverable/joinable.
     * @summary Delete a lobby
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLobby: async (
      lobbyId: string,
      serviceId?: string,
      impersonatedUserId?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'lobbyId' is not null or undefined
      assertParamExists("deleteLobby", "lobbyId", lobbyId);
      const localVarPath = `/{lobbyId}`.replace(
        `{${"lobbyId"}}`,
        encodeURIComponent(String(lobbyId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication JWT required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (serviceId !== undefined && serviceId !== null) {
        localVarHeaderParameter["service-id"] = String(serviceId);
      }

      if (impersonatedUserId !== undefined && impersonatedUserId !== null) {
        localVarHeaderParameter["impersonated-user-id"] =
          String(impersonatedUserId);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of lobby IDs that are currently hosted by the player/service.
     * @summary Get a player/service\'s hosted lobbies
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHostedLobbies: async (
      serviceId?: string,
      impersonatedUserId?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/hosted`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication JWT required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (serviceId !== undefined && serviceId !== null) {
        localVarHeaderParameter["service-id"] = String(serviceId);
      }

      if (impersonatedUserId !== undefined && impersonatedUserId !== null) {
        localVarHeaderParameter["impersonated-user-id"] =
          String(impersonatedUserId);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of lobby IDs that the player is currently a member of.
     * @summary Get a player\'s joined lobbies
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getJoinedLobbies: async (
      serviceId?: string,
      impersonatedUserId?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/joined`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication JWT required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (serviceId !== undefined && serviceId !== null) {
        localVarHeaderParameter["service-id"] = String(serviceId);
      }

      if (impersonatedUserId !== undefined && impersonatedUserId !== null) {
        localVarHeaderParameter["impersonated-user-id"] =
          String(impersonatedUserId);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the full details for a lobby including the game-specific metadata and player details.
     * @summary Get lobby details
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLobby: async (
      lobbyId: string,
      serviceId?: string,
      impersonatedUserId?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'lobbyId' is not null or undefined
      assertParamExists("getLobby", "lobbyId", lobbyId);
      const localVarPath = `/{lobbyId}`.replace(
        `{${"lobbyId"}}`,
        encodeURIComponent(String(lobbyId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication JWT required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (serviceId !== undefined && serviceId !== null) {
        localVarHeaderParameter["service-id"] = String(serviceId);
      }

      if (impersonatedUserId !== undefined && impersonatedUserId !== null) {
        localVarHeaderParameter["impersonated-user-id"] =
          String(impersonatedUserId);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Heartbeat a lobby, updating its `LastUpdated` property, to signify that the lobby is not stale.
     * @summary Heartbeat a lobby
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    heartbeat: async (
      lobbyId: string,
      serviceId?: string,
      impersonatedUserId?: string,
      body?: object,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'lobbyId' is not null or undefined
      assertParamExists("heartbeat", "lobbyId", lobbyId);
      const localVarPath = `/{lobbyId}/heartbeat`.replace(
        `{${"lobbyId"}}`,
        encodeURIComponent(String(lobbyId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication JWT required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (serviceId !== undefined && serviceId !== null) {
        localVarHeaderParameter["service-id"] = String(serviceId);
      }

      if (impersonatedUserId !== undefined && impersonatedUserId !== null) {
        localVarHeaderParameter["impersonated-user-id"] =
          String(impersonatedUserId);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Join an existing lobby using the lobby code if there is space available (i.e. total number of players is less than the value of `MaxPlayers`).
     * @summary Join a lobby with lobby code
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {JoinByCodeRequest} [joinByCodeRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    joinLobbyByCode: async (
      serviceId?: string,
      impersonatedUserId?: string,
      joinByCodeRequest?: JoinByCodeRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/joinbycode`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication JWT required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (serviceId !== undefined && serviceId !== null) {
        localVarHeaderParameter["service-id"] = String(serviceId);
      }

      if (impersonatedUserId !== undefined && impersonatedUserId !== null) {
        localVarHeaderParameter["impersonated-user-id"] =
          String(impersonatedUserId);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        joinByCodeRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Join an existing lobby using the lobby ID if there is space available (i.e. total number of players is less than the value of `MaxPlayers`).
     * @summary Join a lobby with lobby ID
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {Player} [player]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    joinLobbyById: async (
      lobbyId: string,
      serviceId?: string,
      impersonatedUserId?: string,
      player?: Player,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'lobbyId' is not null or undefined
      assertParamExists("joinLobbyById", "lobbyId", lobbyId);
      const localVarPath = `/{lobbyId}/join`.replace(
        `{${"lobbyId"}}`,
        encodeURIComponent(String(lobbyId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication JWT required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (serviceId !== undefined && serviceId !== null) {
        localVarHeaderParameter["service-id"] = String(serviceId);
      }

      if (impersonatedUserId !== undefined && impersonatedUserId !== null) {
        localVarHeaderParameter["impersonated-user-id"] =
          String(impersonatedUserId);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        player,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Query all of the public lobbies for a title and filter them down according to parameters provided by the client.
     * @summary Query public lobbies
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {QueryRequest} [queryRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryLobbies: async (
      serviceId?: string,
      impersonatedUserId?: string,
      queryRequest?: QueryRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/query`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication JWT required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (serviceId !== undefined && serviceId !== null) {
        localVarHeaderParameter["service-id"] = String(serviceId);
      }

      if (impersonatedUserId !== undefined && impersonatedUserId !== null) {
        localVarHeaderParameter["impersonated-user-id"] =
          String(impersonatedUserId);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        queryRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Query all of the available lobbies for a title and filter them down according to parameters provided by the client.  If possible, join one and return its information.
     * @summary Query available lobbies and join a random one
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {QuickJoinRequest} [quickJoinRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    quickJoinLobby: async (
      serviceId?: string,
      impersonatedUserId?: string,
      quickJoinRequest?: QuickJoinRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/quickjoin`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication JWT required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (serviceId !== undefined && serviceId !== null) {
        localVarHeaderParameter["service-id"] = String(serviceId);
      }

      if (impersonatedUserId !== undefined && impersonatedUserId !== null) {
        localVarHeaderParameter["impersonated-user-id"] =
          String(impersonatedUserId);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        quickJoinRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Reconnect a disconnected player to a lobby using the lobby ID.
     * @summary Reconnect to a lobby after disconnecting
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reconnect: async (
      lobbyId: string,
      serviceId?: string,
      impersonatedUserId?: string,
      body?: object,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'lobbyId' is not null or undefined
      assertParamExists("reconnect", "lobbyId", lobbyId);
      const localVarPath = `/{lobbyId}/reconnect`.replace(
        `{${"lobbyId"}}`,
        encodeURIComponent(String(lobbyId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication JWT required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (serviceId !== undefined && serviceId !== null) {
        localVarHeaderParameter["service-id"] = String(serviceId);
      }

      if (impersonatedUserId !== undefined && impersonatedUserId !== null) {
        localVarHeaderParameter["impersonated-user-id"] =
          String(impersonatedUserId);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Remove an individual player from a lobby.  If the player being removed is the host, a random player is chosen as the new host.  Hosts can avoid this by changing the `hostId` to another player using the **Update Lobby** API before leaving.
     * @summary Remove a player
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {string} playerId The ID of the player to execute the request against.
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removePlayer: async (
      lobbyId: string,
      playerId: string,
      serviceId?: string,
      impersonatedUserId?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'lobbyId' is not null or undefined
      assertParamExists("removePlayer", "lobbyId", lobbyId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("removePlayer", "playerId", playerId);
      const localVarPath = `/{lobbyId}/players/{playerId}`
        .replace(`{${"lobbyId"}}`, encodeURIComponent(String(lobbyId)))
        .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication JWT required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (serviceId !== undefined && serviceId !== null) {
        localVarHeaderParameter["service-id"] = String(serviceId);
      }

      if (impersonatedUserId !== undefined && impersonatedUserId !== null) {
        localVarHeaderParameter["impersonated-user-id"] =
          String(impersonatedUserId);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Request authentication tokens for use with other services that interact with Lobby.
     * @summary Authentication token request
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {Array<TokenRequest>} tokenRequest
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestTokens: async (
      lobbyId: string,
      tokenRequest: Array<TokenRequest>,
      serviceId?: string,
      impersonatedUserId?: string,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'lobbyId' is not null or undefined
      assertParamExists("requestTokens", "lobbyId", lobbyId);
      // verify required parameter 'tokenRequest' is not null or undefined
      assertParamExists("requestTokens", "tokenRequest", tokenRequest);
      const localVarPath = `/{lobbyId}/tokens`.replace(
        `{${"lobbyId"}}`,
        encodeURIComponent(String(lobbyId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication JWT required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (serviceId !== undefined && serviceId !== null) {
        localVarHeaderParameter["service-id"] = String(serviceId);
      }

      if (impersonatedUserId !== undefined && impersonatedUserId !== null) {
        localVarHeaderParameter["impersonated-user-id"] =
          String(impersonatedUserId);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        tokenRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update the properties of a lobby.  This could include the lobby name, number of max players, the lobby\'s `data` property, etc.
     * @summary Update lobby data
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {UpdateRequest} [updateRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLobby: async (
      lobbyId: string,
      serviceId?: string,
      impersonatedUserId?: string,
      updateRequest?: UpdateRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'lobbyId' is not null or undefined
      assertParamExists("updateLobby", "lobbyId", lobbyId);
      const localVarPath = `/{lobbyId}`.replace(
        `{${"lobbyId"}}`,
        encodeURIComponent(String(lobbyId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication JWT required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (serviceId !== undefined && serviceId !== null) {
        localVarHeaderParameter["service-id"] = String(serviceId);
      }

      if (impersonatedUserId !== undefined && impersonatedUserId !== null) {
        localVarHeaderParameter["impersonated-user-id"] =
          String(impersonatedUserId);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        updateRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update the properties of a player.  Only the player matching the player ID can perform this action.  This could include updating the `data` property for an individual player to include game-specific metadata.  The index data property is not allowed on player data objects at this time.
     * @summary Update player data
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {string} playerId The ID of the player to execute the request against.
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {PlayerUpdateRequest} [playerUpdateRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePlayer: async (
      lobbyId: string,
      playerId: string,
      serviceId?: string,
      impersonatedUserId?: string,
      playerUpdateRequest?: PlayerUpdateRequest,
      options: AxiosRequestConfig = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'lobbyId' is not null or undefined
      assertParamExists("updatePlayer", "lobbyId", lobbyId);
      // verify required parameter 'playerId' is not null or undefined
      assertParamExists("updatePlayer", "playerId", playerId);
      const localVarPath = `/{lobbyId}/players/{playerId}`
        .replace(`{${"lobbyId"}}`, encodeURIComponent(String(lobbyId)))
        .replace(`{${"playerId"}}`, encodeURIComponent(String(playerId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication JWT required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (serviceId !== undefined && serviceId !== null) {
        localVarHeaderParameter["service-id"] = String(serviceId);
      }

      if (impersonatedUserId !== undefined && impersonatedUserId !== null) {
        localVarHeaderParameter["impersonated-user-id"] =
          String(impersonatedUserId);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        playerUpdateRequest,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * LobbyApi - functional programming interface
 * @export
 */
export const LobbyApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = LobbyApiAxiosParamCreator(configuration);
  return {
    /**
     * Apply a bulk update to a lobby. This can modify the lobby\'s metadata, add players, update players, and remove players. This operation is only allowed for service accounts.
     * @summary Bulk update
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {BulkUpdateRequest} [bulkUpdateRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bulkUpdateLobby(
      lobbyId: string,
      serviceId?: string,
      impersonatedUserId?: string,
      bulkUpdateRequest?: BulkUpdateRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Lobby>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.bulkUpdateLobby(
        lobbyId,
        serviceId,
        impersonatedUserId,
        bulkUpdateRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Create a new lobby and return the lobby metadata.
     * @summary Create a lobby
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {CreateRequest} [createRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createLobby(
      serviceId?: string,
      impersonatedUserId?: string,
      createRequest?: CreateRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Lobby>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.createLobby(
        serviceId,
        impersonatedUserId,
        createRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Delete a lobby so it\'s no longer discoverable/joinable.
     * @summary Delete a lobby
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteLobby(
      lobbyId: string,
      serviceId?: string,
      impersonatedUserId?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLobby(
        lobbyId,
        serviceId,
        impersonatedUserId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a list of lobby IDs that are currently hosted by the player/service.
     * @summary Get a player/service\'s hosted lobbies
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getHostedLobbies(
      serviceId?: string,
      impersonatedUserId?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getHostedLobbies(
          serviceId,
          impersonatedUserId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a list of lobby IDs that the player is currently a member of.
     * @summary Get a player\'s joined lobbies
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getJoinedLobbies(
      serviceId?: string,
      impersonatedUserId?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.getJoinedLobbies(
          serviceId,
          impersonatedUserId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get the full details for a lobby including the game-specific metadata and player details.
     * @summary Get lobby details
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLobby(
      lobbyId: string,
      serviceId?: string,
      impersonatedUserId?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Lobby>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getLobby(
        lobbyId,
        serviceId,
        impersonatedUserId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Heartbeat a lobby, updating its `LastUpdated` property, to signify that the lobby is not stale.
     * @summary Heartbeat a lobby
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async heartbeat(
      lobbyId: string,
      serviceId?: string,
      impersonatedUserId?: string,
      body?: object,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.heartbeat(
        lobbyId,
        serviceId,
        impersonatedUserId,
        body,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Join an existing lobby using the lobby code if there is space available (i.e. total number of players is less than the value of `MaxPlayers`).
     * @summary Join a lobby with lobby code
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {JoinByCodeRequest} [joinByCodeRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async joinLobbyByCode(
      serviceId?: string,
      impersonatedUserId?: string,
      joinByCodeRequest?: JoinByCodeRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Lobby>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.joinLobbyByCode(
        serviceId,
        impersonatedUserId,
        joinByCodeRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Join an existing lobby using the lobby ID if there is space available (i.e. total number of players is less than the value of `MaxPlayers`).
     * @summary Join a lobby with lobby ID
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {Player} [player]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async joinLobbyById(
      lobbyId: string,
      serviceId?: string,
      impersonatedUserId?: string,
      player?: Player,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Lobby>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.joinLobbyById(
        lobbyId,
        serviceId,
        impersonatedUserId,
        player,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Query all of the public lobbies for a title and filter them down according to parameters provided by the client.
     * @summary Query public lobbies
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {QueryRequest} [queryRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async queryLobbies(
      serviceId?: string,
      impersonatedUserId?: string,
      queryRequest?: QueryRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<QueryResponse>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.queryLobbies(
        serviceId,
        impersonatedUserId,
        queryRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Query all of the available lobbies for a title and filter them down according to parameters provided by the client.  If possible, join one and return its information.
     * @summary Query available lobbies and join a random one
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {QuickJoinRequest} [quickJoinRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async quickJoinLobby(
      serviceId?: string,
      impersonatedUserId?: string,
      quickJoinRequest?: QuickJoinRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Lobby>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.quickJoinLobby(
        serviceId,
        impersonatedUserId,
        quickJoinRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Reconnect a disconnected player to a lobby using the lobby ID.
     * @summary Reconnect to a lobby after disconnecting
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async reconnect(
      lobbyId: string,
      serviceId?: string,
      impersonatedUserId?: string,
      body?: object,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Lobby>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.reconnect(
        lobbyId,
        serviceId,
        impersonatedUserId,
        body,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Remove an individual player from a lobby.  If the player being removed is the host, a random player is chosen as the new host.  Hosts can avoid this by changing the `hostId` to another player using the **Update Lobby** API before leaving.
     * @summary Remove a player
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {string} playerId The ID of the player to execute the request against.
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removePlayer(
      lobbyId: string,
      playerId: string,
      serviceId?: string,
      impersonatedUserId?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.removePlayer(
        lobbyId,
        playerId,
        serviceId,
        impersonatedUserId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Request authentication tokens for use with other services that interact with Lobby.
     * @summary Authentication token request
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {Array<TokenRequest>} tokenRequest
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async requestTokens(
      lobbyId: string,
      tokenRequest: Array<TokenRequest>,
      serviceId?: string,
      impersonatedUserId?: string,
      options?: AxiosRequestConfig
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<{ [key: string]: TokenData }>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.requestTokens(
        lobbyId,
        tokenRequest,
        serviceId,
        impersonatedUserId,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Update the properties of a lobby.  This could include the lobby name, number of max players, the lobby\'s `data` property, etc.
     * @summary Update lobby data
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {UpdateRequest} [updateRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateLobby(
      lobbyId: string,
      serviceId?: string,
      impersonatedUserId?: string,
      updateRequest?: UpdateRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Lobby>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateLobby(
        lobbyId,
        serviceId,
        impersonatedUserId,
        updateRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Update the properties of a player.  Only the player matching the player ID can perform this action.  This could include updating the `data` property for an individual player to include game-specific metadata.  The index data property is not allowed on player data objects at this time.
     * @summary Update player data
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {string} playerId The ID of the player to execute the request against.
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {PlayerUpdateRequest} [playerUpdateRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePlayer(
      lobbyId: string,
      playerId: string,
      serviceId?: string,
      impersonatedUserId?: string,
      playerUpdateRequest?: PlayerUpdateRequest,
      options?: AxiosRequestConfig
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Lobby>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updatePlayer(
        lobbyId,
        playerId,
        serviceId,
        impersonatedUserId,
        playerUpdateRequest,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * LobbyApi - factory interface
 * @export
 */
export const LobbyApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = LobbyApiFp(configuration);
  return {
    /**
     * Apply a bulk update to a lobby. This can modify the lobby\'s metadata, add players, update players, and remove players. This operation is only allowed for service accounts.
     * @summary Bulk update
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {BulkUpdateRequest} [bulkUpdateRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bulkUpdateLobby(
      lobbyId: string,
      serviceId?: string,
      impersonatedUserId?: string,
      bulkUpdateRequest?: BulkUpdateRequest,
      options?: any
    ): AxiosPromise<Lobby> {
      return localVarFp
        .bulkUpdateLobby(
          lobbyId,
          serviceId,
          impersonatedUserId,
          bulkUpdateRequest,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Create a new lobby and return the lobby metadata.
     * @summary Create a lobby
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {CreateRequest} [createRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLobby(
      serviceId?: string,
      impersonatedUserId?: string,
      createRequest?: CreateRequest,
      options?: any
    ): AxiosPromise<Lobby> {
      return localVarFp
        .createLobby(serviceId, impersonatedUserId, createRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Delete a lobby so it\'s no longer discoverable/joinable.
     * @summary Delete a lobby
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLobby(
      lobbyId: string,
      serviceId?: string,
      impersonatedUserId?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .deleteLobby(lobbyId, serviceId, impersonatedUserId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a list of lobby IDs that are currently hosted by the player/service.
     * @summary Get a player/service\'s hosted lobbies
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getHostedLobbies(
      serviceId?: string,
      impersonatedUserId?: string,
      options?: any
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .getHostedLobbies(serviceId, impersonatedUserId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a list of lobby IDs that the player is currently a member of.
     * @summary Get a player\'s joined lobbies
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getJoinedLobbies(
      serviceId?: string,
      impersonatedUserId?: string,
      options?: any
    ): AxiosPromise<Array<string>> {
      return localVarFp
        .getJoinedLobbies(serviceId, impersonatedUserId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get the full details for a lobby including the game-specific metadata and player details.
     * @summary Get lobby details
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLobby(
      lobbyId: string,
      serviceId?: string,
      impersonatedUserId?: string,
      options?: any
    ): AxiosPromise<Lobby> {
      return localVarFp
        .getLobby(lobbyId, serviceId, impersonatedUserId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Heartbeat a lobby, updating its `LastUpdated` property, to signify that the lobby is not stale.
     * @summary Heartbeat a lobby
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    heartbeat(
      lobbyId: string,
      serviceId?: string,
      impersonatedUserId?: string,
      body?: object,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .heartbeat(lobbyId, serviceId, impersonatedUserId, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Join an existing lobby using the lobby code if there is space available (i.e. total number of players is less than the value of `MaxPlayers`).
     * @summary Join a lobby with lobby code
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {JoinByCodeRequest} [joinByCodeRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    joinLobbyByCode(
      serviceId?: string,
      impersonatedUserId?: string,
      joinByCodeRequest?: JoinByCodeRequest,
      options?: any
    ): AxiosPromise<Lobby> {
      return localVarFp
        .joinLobbyByCode(
          serviceId,
          impersonatedUserId,
          joinByCodeRequest,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Join an existing lobby using the lobby ID if there is space available (i.e. total number of players is less than the value of `MaxPlayers`).
     * @summary Join a lobby with lobby ID
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {Player} [player]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    joinLobbyById(
      lobbyId: string,
      serviceId?: string,
      impersonatedUserId?: string,
      player?: Player,
      options?: any
    ): AxiosPromise<Lobby> {
      return localVarFp
        .joinLobbyById(lobbyId, serviceId, impersonatedUserId, player, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Query all of the public lobbies for a title and filter them down according to parameters provided by the client.
     * @summary Query public lobbies
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {QueryRequest} [queryRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    queryLobbies(
      serviceId?: string,
      impersonatedUserId?: string,
      queryRequest?: QueryRequest,
      options?: any
    ): AxiosPromise<QueryResponse> {
      return localVarFp
        .queryLobbies(serviceId, impersonatedUserId, queryRequest, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Query all of the available lobbies for a title and filter them down according to parameters provided by the client.  If possible, join one and return its information.
     * @summary Query available lobbies and join a random one
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {QuickJoinRequest} [quickJoinRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    quickJoinLobby(
      serviceId?: string,
      impersonatedUserId?: string,
      quickJoinRequest?: QuickJoinRequest,
      options?: any
    ): AxiosPromise<Lobby> {
      return localVarFp
        .quickJoinLobby(
          serviceId,
          impersonatedUserId,
          quickJoinRequest,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Reconnect a disconnected player to a lobby using the lobby ID.
     * @summary Reconnect to a lobby after disconnecting
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    reconnect(
      lobbyId: string,
      serviceId?: string,
      impersonatedUserId?: string,
      body?: object,
      options?: any
    ): AxiosPromise<Lobby> {
      return localVarFp
        .reconnect(lobbyId, serviceId, impersonatedUserId, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Remove an individual player from a lobby.  If the player being removed is the host, a random player is chosen as the new host.  Hosts can avoid this by changing the `hostId` to another player using the **Update Lobby** API before leaving.
     * @summary Remove a player
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {string} playerId The ID of the player to execute the request against.
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removePlayer(
      lobbyId: string,
      playerId: string,
      serviceId?: string,
      impersonatedUserId?: string,
      options?: any
    ): AxiosPromise<void> {
      return localVarFp
        .removePlayer(lobbyId, playerId, serviceId, impersonatedUserId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Request authentication tokens for use with other services that interact with Lobby.
     * @summary Authentication token request
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {Array<TokenRequest>} tokenRequest
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    requestTokens(
      lobbyId: string,
      tokenRequest: Array<TokenRequest>,
      serviceId?: string,
      impersonatedUserId?: string,
      options?: any
    ): AxiosPromise<{ [key: string]: TokenData }> {
      return localVarFp
        .requestTokens(
          lobbyId,
          tokenRequest,
          serviceId,
          impersonatedUserId,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Update the properties of a lobby.  This could include the lobby name, number of max players, the lobby\'s `data` property, etc.
     * @summary Update lobby data
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {UpdateRequest} [updateRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLobby(
      lobbyId: string,
      serviceId?: string,
      impersonatedUserId?: string,
      updateRequest?: UpdateRequest,
      options?: any
    ): AxiosPromise<Lobby> {
      return localVarFp
        .updateLobby(
          lobbyId,
          serviceId,
          impersonatedUserId,
          updateRequest,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Update the properties of a player.  Only the player matching the player ID can perform this action.  This could include updating the `data` property for an individual player to include game-specific metadata.  The index data property is not allowed on player data objects at this time.
     * @summary Update player data
     * @param {string} lobbyId The ID of the lobby to execute the request against.
     * @param {string} playerId The ID of the player to execute the request against.
     * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
     * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
     * @param {PlayerUpdateRequest} [playerUpdateRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePlayer(
      lobbyId: string,
      playerId: string,
      serviceId?: string,
      impersonatedUserId?: string,
      playerUpdateRequest?: PlayerUpdateRequest,
      options?: any
    ): AxiosPromise<Lobby> {
      return localVarFp
        .updatePlayer(
          lobbyId,
          playerId,
          serviceId,
          impersonatedUserId,
          playerUpdateRequest,
          options
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * LobbyApi - object-oriented interface
 * @export
 * @class LobbyApi
 * @extends {BaseAPI}
 */
export class LobbyApi extends BaseAPI {
  /**
   * Apply a bulk update to a lobby. This can modify the lobby\'s metadata, add players, update players, and remove players. This operation is only allowed for service accounts.
   * @summary Bulk update
   * @param {string} lobbyId The ID of the lobby to execute the request against.
   * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
   * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
   * @param {BulkUpdateRequest} [bulkUpdateRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LobbyApi
   */
  public bulkUpdateLobby(
    lobbyId: string,
    serviceId?: string,
    impersonatedUserId?: string,
    bulkUpdateRequest?: BulkUpdateRequest,
    options?: AxiosRequestConfig
  ) {
    return LobbyApiFp(this.configuration)
      .bulkUpdateLobby(
        lobbyId,
        serviceId,
        impersonatedUserId,
        bulkUpdateRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Create a new lobby and return the lobby metadata.
   * @summary Create a lobby
   * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
   * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
   * @param {CreateRequest} [createRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LobbyApi
   */
  public createLobby(
    serviceId?: string,
    impersonatedUserId?: string,
    createRequest?: CreateRequest,
    options?: AxiosRequestConfig
  ) {
    return LobbyApiFp(this.configuration)
      .createLobby(serviceId, impersonatedUserId, createRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Delete a lobby so it\'s no longer discoverable/joinable.
   * @summary Delete a lobby
   * @param {string} lobbyId The ID of the lobby to execute the request against.
   * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
   * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LobbyApi
   */
  public deleteLobby(
    lobbyId: string,
    serviceId?: string,
    impersonatedUserId?: string,
    options?: AxiosRequestConfig
  ) {
    return LobbyApiFp(this.configuration)
      .deleteLobby(lobbyId, serviceId, impersonatedUserId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of lobby IDs that are currently hosted by the player/service.
   * @summary Get a player/service\'s hosted lobbies
   * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
   * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LobbyApi
   */
  public getHostedLobbies(
    serviceId?: string,
    impersonatedUserId?: string,
    options?: AxiosRequestConfig
  ) {
    return LobbyApiFp(this.configuration)
      .getHostedLobbies(serviceId, impersonatedUserId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of lobby IDs that the player is currently a member of.
   * @summary Get a player\'s joined lobbies
   * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
   * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LobbyApi
   */
  public getJoinedLobbies(
    serviceId?: string,
    impersonatedUserId?: string,
    options?: AxiosRequestConfig
  ) {
    return LobbyApiFp(this.configuration)
      .getJoinedLobbies(serviceId, impersonatedUserId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get the full details for a lobby including the game-specific metadata and player details.
   * @summary Get lobby details
   * @param {string} lobbyId The ID of the lobby to execute the request against.
   * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
   * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LobbyApi
   */
  public getLobby(
    lobbyId: string,
    serviceId?: string,
    impersonatedUserId?: string,
    options?: AxiosRequestConfig
  ) {
    return LobbyApiFp(this.configuration)
      .getLobby(lobbyId, serviceId, impersonatedUserId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Heartbeat a lobby, updating its `LastUpdated` property, to signify that the lobby is not stale.
   * @summary Heartbeat a lobby
   * @param {string} lobbyId The ID of the lobby to execute the request against.
   * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
   * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
   * @param {object} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LobbyApi
   */
  public heartbeat(
    lobbyId: string,
    serviceId?: string,
    impersonatedUserId?: string,
    body?: object,
    options?: AxiosRequestConfig
  ) {
    return LobbyApiFp(this.configuration)
      .heartbeat(lobbyId, serviceId, impersonatedUserId, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Join an existing lobby using the lobby code if there is space available (i.e. total number of players is less than the value of `MaxPlayers`).
   * @summary Join a lobby with lobby code
   * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
   * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
   * @param {JoinByCodeRequest} [joinByCodeRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LobbyApi
   */
  public joinLobbyByCode(
    serviceId?: string,
    impersonatedUserId?: string,
    joinByCodeRequest?: JoinByCodeRequest,
    options?: AxiosRequestConfig
  ) {
    return LobbyApiFp(this.configuration)
      .joinLobbyByCode(
        serviceId,
        impersonatedUserId,
        joinByCodeRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Join an existing lobby using the lobby ID if there is space available (i.e. total number of players is less than the value of `MaxPlayers`).
   * @summary Join a lobby with lobby ID
   * @param {string} lobbyId The ID of the lobby to execute the request against.
   * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
   * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
   * @param {Player} [player]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LobbyApi
   */
  public joinLobbyById(
    lobbyId: string,
    serviceId?: string,
    impersonatedUserId?: string,
    player?: Player,
    options?: AxiosRequestConfig
  ) {
    return LobbyApiFp(this.configuration)
      .joinLobbyById(lobbyId, serviceId, impersonatedUserId, player, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Query all of the public lobbies for a title and filter them down according to parameters provided by the client.
   * @summary Query public lobbies
   * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
   * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
   * @param {QueryRequest} [queryRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LobbyApi
   */
  public queryLobbies(
    serviceId?: string,
    impersonatedUserId?: string,
    queryRequest?: QueryRequest,
    options?: AxiosRequestConfig
  ) {
    return LobbyApiFp(this.configuration)
      .queryLobbies(serviceId, impersonatedUserId, queryRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Query all of the available lobbies for a title and filter them down according to parameters provided by the client.  If possible, join one and return its information.
   * @summary Query available lobbies and join a random one
   * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
   * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
   * @param {QuickJoinRequest} [quickJoinRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LobbyApi
   */
  public quickJoinLobby(
    serviceId?: string,
    impersonatedUserId?: string,
    quickJoinRequest?: QuickJoinRequest,
    options?: AxiosRequestConfig
  ) {
    return LobbyApiFp(this.configuration)
      .quickJoinLobby(serviceId, impersonatedUserId, quickJoinRequest, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Reconnect a disconnected player to a lobby using the lobby ID.
   * @summary Reconnect to a lobby after disconnecting
   * @param {string} lobbyId The ID of the lobby to execute the request against.
   * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
   * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
   * @param {object} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LobbyApi
   */
  public reconnect(
    lobbyId: string,
    serviceId?: string,
    impersonatedUserId?: string,
    body?: object,
    options?: AxiosRequestConfig
  ) {
    return LobbyApiFp(this.configuration)
      .reconnect(lobbyId, serviceId, impersonatedUserId, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Remove an individual player from a lobby.  If the player being removed is the host, a random player is chosen as the new host.  Hosts can avoid this by changing the `hostId` to another player using the **Update Lobby** API before leaving.
   * @summary Remove a player
   * @param {string} lobbyId The ID of the lobby to execute the request against.
   * @param {string} playerId The ID of the player to execute the request against.
   * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
   * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LobbyApi
   */
  public removePlayer(
    lobbyId: string,
    playerId: string,
    serviceId?: string,
    impersonatedUserId?: string,
    options?: AxiosRequestConfig
  ) {
    return LobbyApiFp(this.configuration)
      .removePlayer(lobbyId, playerId, serviceId, impersonatedUserId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Request authentication tokens for use with other services that interact with Lobby.
   * @summary Authentication token request
   * @param {string} lobbyId The ID of the lobby to execute the request against.
   * @param {Array<TokenRequest>} tokenRequest
   * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
   * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LobbyApi
   */
  public requestTokens(
    lobbyId: string,
    tokenRequest: Array<TokenRequest>,
    serviceId?: string,
    impersonatedUserId?: string,
    options?: AxiosRequestConfig
  ) {
    return LobbyApiFp(this.configuration)
      .requestTokens(
        lobbyId,
        tokenRequest,
        serviceId,
        impersonatedUserId,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update the properties of a lobby.  This could include the lobby name, number of max players, the lobby\'s `data` property, etc.
   * @summary Update lobby data
   * @param {string} lobbyId The ID of the lobby to execute the request against.
   * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
   * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
   * @param {UpdateRequest} [updateRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LobbyApi
   */
  public updateLobby(
    lobbyId: string,
    serviceId?: string,
    impersonatedUserId?: string,
    updateRequest?: UpdateRequest,
    options?: AxiosRequestConfig
  ) {
    return LobbyApiFp(this.configuration)
      .updateLobby(
        lobbyId,
        serviceId,
        impersonatedUserId,
        updateRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update the properties of a player.  Only the player matching the player ID can perform this action.  This could include updating the `data` property for an individual player to include game-specific metadata.  The index data property is not allowed on player data objects at this time.
   * @summary Update player data
   * @param {string} lobbyId The ID of the lobby to execute the request against.
   * @param {string} playerId The ID of the player to execute the request against.
   * @param {string} [serviceId] When service authentication is used, this provides a logical identity for the service
   * @param {string} [impersonatedUserId] When service authentication is used, this provides a \&#39;playerId\&#39; to execute as. If this header is detected, the service request will be identical to a request from the specified player.
   * @param {PlayerUpdateRequest} [playerUpdateRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LobbyApi
   */
  public updatePlayer(
    lobbyId: string,
    playerId: string,
    serviceId?: string,
    impersonatedUserId?: string,
    playerUpdateRequest?: PlayerUpdateRequest,
    options?: AxiosRequestConfig
  ) {
    return LobbyApiFp(this.configuration)
      .updatePlayer(
        lobbyId,
        playerId,
        serviceId,
        impersonatedUserId,
        playerUpdateRequest,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }
}
